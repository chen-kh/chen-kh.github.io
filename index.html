<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="Java, Python, C, Go language">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="其鬼不神" type="application/atom+xml" />






<meta name="description" content="道莅天下，其鬼不神">
<meta name="keywords" content="分布式系统，数据结构与算法，操作系统与网络，编程语言与设计模式">
<meta property="og:type" content="website">
<meta property="og:title" content="其鬼不神">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="其鬼不神">
<meta property="og:description" content="道莅天下，其鬼不神">
<meta property="og:locale" content="Java, Python, C, Go language">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="其鬼不神">
<meta name="twitter:description" content="道莅天下，其鬼不神">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>其鬼不神</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="Java, Python, C, Go language">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">其鬼不神</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">ACT北航愣头青的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/linux和操作系统/os/随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/linux和操作系统/os/随笔/" itemprop="url">操作系统随笔</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T17:13:51+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="操作系统随笔"><a href="#操作系统随笔" class="headerlink" title="操作系统随笔"></a>操作系统随笔</h1><!-- TOC -->
<ul>
<li><a href="#1-锁的概念以及死锁的概念">1. 锁的概念以及死锁的概念</a></li>
<li><a href="#2-计算机ip保留地址">2. 计算机IP保留地址</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-锁的概念以及死锁的概念"><a href="#1-锁的概念以及死锁的概念" class="headerlink" title="1. 锁的概念以及死锁的概念"></a>1. 锁的概念以及死锁的概念</h2><ul>
<li><p>牛客网参考答案：<a href="https://www.nowcoder.com/ta/review-java/review?page=16" target="_blank" rel="noopener">JAVA面试常考知识点：page16</a></p>
<blockquote>
<p>所谓死锁是指多个进 程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：</p>
<ul>
<li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。</li>
</ul>
</blockquote>
</li>
<li><p>如何解决死锁问题</p>
</li>
</ul>
<p>目标就是破坏产生死锁的四个条件，一般最后一个条件比较容易破坏，也就是所有锁的需求都是按照一定顺序来的。可参考：<a href="https://www.jianshu.com/p/44125bb12ebf" target="_blank" rel="noopener">死锁是什么？如何避免死锁？</a></p>
<h2 id="2-计算机IP保留地址"><a href="#2-计算机IP保留地址" class="headerlink" title="2. 计算机IP保留地址"></a>2. 计算机IP保留地址</h2><p>参考文章：<a href="http://www.cnblogs.com/ZJoy/archive/2011/03/24/1994308.html" target="_blank" rel="noopener">IP地址中的保留地址</a><br>根据用途和安全性级别的不同，IP地址还可以大致分为两类：公共地址和私有地址。</p>
<ul>
<li>公用地址在Internet中使用，可以在Internet中随意访问。</li>
<li>私有地址只能在内部网络中使用，只有通过代理服务器才能与Internet通信。</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/data_struc_algo/sortsummary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/data_struc_algo/sortsummary/" itemprop="url">各种排序方法的简单总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T17:13:51+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="各种排序方法的简单总结"><a href="#各种排序方法的简单总结" class="headerlink" title="各种排序方法的简单总结"></a>各种排序方法的简单总结</h1><p>排序算法算是计算机的经典算法，解决很多问题的时候排序算法的思想都值得参考。<br><!-- TOC --></p>
<ul>
<li><a href="#1-快速排序的思想">1. 快速排序的思想</a></li>
<li><a href="#2-归并排序的思想">2. 归并排序的思想</a></li>
<li><a href="#3-堆排序的思路">3. 堆排序的思路</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-快速排序的思想"><a href="#1-快速排序的思想" class="headerlink" title="1. 快速排序的思想"></a>1. 快速排序的思想</h2><p>学习容易记住的快排算法过程（Partition函数式最重要的，有两种写法，一种高效，另一种普通，参考<a href="http://selfboot.cn/2016/09/01/lost_partition/" target="_blank" rel="noopener">这里</a>）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main sort function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start == end)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> index = partition(arr, len, start, end);</span><br><span class="line">	print_arr(arr, len);</span><br><span class="line">	<span class="keyword">if</span>(index &gt; start)</span><br><span class="line">		qsort(arr, len, start, index - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(index &lt; end)</span><br><span class="line">		qsort(arr, len, index + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition function 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span> || start &lt; <span class="number">0</span> || end &lt; <span class="number">0</span> || end &gt;= len || end &lt; start)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"partition input invalid\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[end];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = start; i &lt; end; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] &lt; pivot)&#123;</span><br><span class="line">			small++;</span><br><span class="line">			<span class="keyword">if</span>(i != small)</span><br><span class="line">				swap(&amp;arr[small], &amp;arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	small++;</span><br><span class="line">	swap(&amp;arr[small], &amp;arr[end]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition function which is more efficient</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span> || start &lt; <span class="number">0</span> || end &lt; <span class="number">0</span> || end &gt;= len || end &lt; start)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"partition input invalid\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[end];</span><br><span class="line">	start--;</span><br><span class="line">	<span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end &amp;&amp; arr[++start] &lt;= pivot);</span><br><span class="line">		arr[end] = arr[start];</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end &amp;&amp; arr[--end] &gt;= pivot);</span><br><span class="line">		arr[start] = arr[end];</span><br><span class="line">	&#125;</span><br><span class="line">	arr[start] = pivot;</span><br><span class="line">	<span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-归并排序的思想"><a href="#2-归并排序的思想" class="headerlink" title="2. 归并排序的思想"></a>2. 归并排序的思想</h2><p>归并排序就是将数组分成两个部分，然后分别对两个部分进行排序，然后再融合起来。可以递归实现，算法时间复杂度时O(nlogn)，空间复杂度O(n)，也就是需要辅助空间。</p>
<h2 id="3-堆排序的思路"><a href="#3-堆排序的思路" class="headerlink" title="3. 堆排序的思路"></a>3. 堆排序的思路</h2><p>参考：<a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法 - 堆排序 (Heap Sort)</a></p>
<p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p>
<ul>
<li>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</li>
<li>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<p>最大堆调整（MAX‐HEAPIFY）的作用是保持最大堆的性质，是创建最大堆的核心子程序。下面是Java版本的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/* 堆排序的思路：</span></span><br><span class="line"><span class="comment"> * 1. 首先明确堆是一种数据结构，利用堆这种数据结构的特性可以很高效地做排序算法。</span></span><br><span class="line"><span class="comment"> * 2. 第一步：堆化。将原本不是堆结构的数组转换成堆，方法时从第一个不是叶节点的节点开始，到根节点，进行堆化操作。堆化操作就是数字的上浮和下沉，要注意的是下沉要彻底，也就是需要递归或者迭代处理下沉的点。</span></span><br><span class="line"><span class="comment"> * 3. 第二步：排序。以最大堆为例，堆顶（也就是树结构的根节点，也就是数组第一个元素）存的是最大值，堆顶元素与最末尾叶节点交换，交换后堆就不是最大堆了，需要重新调整，但是调整的时候就不管最后一个元素了，所以堆的长度减少1。循环此过程直到堆内只剩下一个元素。排序完成。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSortWiki</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeapSortWiki</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.arr = arr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 堆排序的主要入口方法，共两步。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 第一步：将数组堆化 beginIndex = 第一个非叶子节点。 从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment">		 * 叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> beginIndex = (len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = beginIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			maxHeapify(i, len);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 第二步：对堆化数据排序 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span></span><br><span class="line"><span class="comment">		 * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。 直至未排序的堆长度为 0。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			swap(<span class="number">0</span>, i);</span><br><span class="line">			maxHeapify(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 调整索引为 index 处的数据，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 *            需要堆化处理的数据的索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">	 *            未排序的堆（数组）的长度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> li = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">		<span class="keyword">int</span> ri = li + <span class="number">1</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line">		<span class="keyword">int</span> cMax = li; <span class="comment">// 子节点值最大索引，默认左子节点。</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (li &gt; len)</span><br><span class="line">			<span class="keyword">return</span>; <span class="comment">// 左子节点索引超出计算范围，直接返回。</span></span><br><span class="line">		<span class="keyword">if</span> (ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) <span class="comment">// 先判断左右子节点，哪个较大。</span></span><br><span class="line">			cMax = ri;</span><br><span class="line">		<span class="keyword">if</span> (arr[cMax] &gt; arr[index]) &#123;</span><br><span class="line">			swap(cMax, index); <span class="comment">// 如果父节点被子节点调换，</span></span><br><span class="line">			maxHeapify(cMax, len); <span class="comment">// 则需要继续判断换下后的父节点是否符合堆的特性。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试用例</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 输出： [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7,</span></span><br><span class="line"><span class="comment">	 * 7, 8, 8, 8, 9, 9, 9]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">				<span class="number">6</span> &#125;;</span><br><span class="line">		<span class="keyword">new</span> HeapSortWiki(arr).sort();</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/data_struc_algo/data structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/data_struc_algo/data structure/" itemprop="url">数据结构与算法随笔</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T17:13:51+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Data-Struture-Note"><a href="#Data-Struture-Note" class="headerlink" title="Data Struture Note"></a>Data Struture Note</h1><!-- TOC -->
<ul>
<li><a href="#1-如何解决hash冲突有哪几种方案">1. 如何解决<code>hash</code>冲突，有哪几种方案</a><ul>
<li><a href="#11-开放定址法">1.1. 开放定址法</a></li>
<li><a href="#12-链地址法拉链法">1.2. 链地址法（拉链法）</a></li>
<li><a href="#13-再哈希法">1.3. 再哈希法</a></li>
<li><a href="#14-建立公共溢出区">1.4. 建立公共溢出区</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-如何解决hash冲突，有哪几种方案"><a href="#1-如何解决hash冲突，有哪几种方案" class="headerlink" title="1. 如何解决hash冲突，有哪几种方案"></a>1. 如何解决<code>hash</code>冲突，有哪几种方案</h2><p>参考：<a href="https://www.jianshu.com/p/4d3cb99d7580" target="_blank" rel="noopener">解决哈希冲突的常用方法分析</a></p>
<h3 id="1-1-开放定址法"><a href="#1-1-开放定址法" class="headerlink" title="1.1. 开放定址法"></a>1.1. 开放定址法</h3><ul>
<li>线性探查法：找到下一个有空的位置放进去，查找的时候遍历（其实也可以有一个辅助的数组专门记录移动的位置），这个方法容易出现“聚集”的现象</li>
<li>平方探查法：二次探测法的地址增量序列为 di = 12， -12， 22， -22，… ， q2, -q2 (q &lt;= m/2)。二次探测能有效避免“聚集”现象，但是不能够探测到哈希表上所有的存储单元，但是至少能够探测到一半。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</li>
<li>双散列函数探查法： hp (key)若h(key)出现冲突，则再使用hp (key)求取散列地址。探查序列为：<code>h(k), h(k)+ hp(k),…, h((k)+ i*hp(k))</code>。</li>
</ul>
<h3 id="1-2-链地址法（拉链法）"><a href="#1-2-链地址法（拉链法）" class="headerlink" title="1.2. 链地址法（拉链法）"></a>1.2. 链地址法（拉链法）</h3><p><code>Java</code>中<code>HashMap</code>的经典实现算法。</p>
<h3 id="1-3-再哈希法"><a href="#1-3-再哈希法" class="headerlink" title="1.3. 再哈希法"></a>1.3. 再哈希法</h3><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。</p>
<h3 id="1-4-建立公共溢出区"><a href="#1-4-建立公共溢出区" class="headerlink" title="1.4. 建立公共溢出区"></a>1.4. 建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/offer/面试随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/offer/面试随笔/" itemprop="url">面试随笔</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试随笔"><a href="#面试随笔" class="headerlink" title="面试随笔"></a>面试随笔</h1><p>记录一些在面试过程中遇到的问题</p>
<!-- TOC -->
<ul>
<li><a href="#1-程序lang掉无响应">1. 程序lang掉（无响应）</a></li>
<li><a href="#3-网易的两道题">3. 网易的两道题</a><ul>
<li><a href="#31-符合nk的数对有多少种">3.1. 符合n，k的数对有多少种</a></li>
<li><a href="#32-有多少种装法">3.2. 有多少种装法</a></li>
</ul>
</li>
<li><a href="#腾讯面试题">腾讯面试题</a><ul>
<li><a href="#带符号大数加减">带符号大数加减</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-程序lang掉（无响应）"><a href="#1-程序lang掉（无响应）" class="headerlink" title="1. 程序lang掉（无响应）"></a>1. 程序lang掉（无响应）</h2><h2 id="3-网易的两道题"><a href="#3-网易的两道题" class="headerlink" title="3. 网易的两道题"></a>3. 网易的两道题</h2><h3 id="3-1-符合n，k的数对有多少种"><a href="#3-1-符合n，k的数对有多少种" class="headerlink" title="3.1. 符合n，k的数对有多少种"></a>3.1. 符合n，k的数对有多少种</h3><h3 id="3-2-有多少种装法"><a href="#3-2-有多少种装法" class="headerlink" title="3.2. 有多少种装法"></a>3.2. 有多少种装法</h3><h2 id="腾讯面试题"><a href="#腾讯面试题" class="headerlink" title="腾讯面试题"></a>腾讯面试题</h2><h3 id="带符号大数加减"><a href="#带符号大数加减" class="headerlink" title="带符号大数加减"></a>带符号大数加减</h3>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/offer/找实习笔记整理与记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/offer/找实习笔记整理与记录/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="需要准备的考点"><a href="#需要准备的考点" class="headerlink" title="需要准备的考点"></a>需要准备的考点</h1><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h2 id="网络（TCP，UDP）等"><a href="#网络（TCP，UDP）等" class="headerlink" title="网络（TCP，UDP）等"></a>网络（TCP，UDP）等</h2><h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h2><h2 id="Python语言"><a href="#Python语言" class="headerlink" title="Python语言"></a>Python语言</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="分布式系统构建"><a href="#分布式系统构建" class="headerlink" title="分布式系统构建"></a>分布式系统构建</h2><ul>
<li>Kafka</li>
<li>JStorm</li>
<li>Memcached</li>
<li>Hadoop</li>
<li>Spark</li>
<li>HBase<h2 id="关于项目的几个问题"><a href="#关于项目的几个问题" class="headerlink" title="关于项目的几个问题"></a>关于项目的几个问题</h2></li>
</ul>
<ol>
<li>项目为什么使用Postgresql开发？</li>
<li>你在项目中主要负责做什么？</li>
</ol>
<ul>
<li>数据入关系数据库pg</li>
<li>数据入分布式内存数据库memcached</li>
<li>系统分布式架构的运行与维护</li>
</ul>
<ol start="2">
<li>项目的不足是什么？</li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/offer/剑指offer阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/offer/剑指offer阅读笔记/" itemprop="url">剑指offer阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="剑指offer阅读笔记"><a href="#剑指offer阅读笔记" class="headerlink" title="剑指offer阅读笔记"></a>剑指offer阅读笔记</h1><!-- TOC -->
<ul>
<li><a href="#1-面试需要注意的内容">1. 面试需要注意的内容</a></li>
<li><a href="#2-编程题">2. 编程题</a><ul>
<li><a href="#21-从链表中查找倒数第k个值">2.1. 从链表中查找倒数第k个值</a></li>
<li><a href="#22-从矩阵从左到右从上到下依次增大中查找某值">2.2. 从矩阵（从左到右，从上到下依次增大）中查找某值</a></li>
<li><a href="#23-字符串替换">2.3. 字符串替换</a></li>
<li><a href="#24-链表在不改变结构的情况下倒着输出">2.4. 链表在不改变结构的情况下倒着输出</a></li>
<li><a href="#25-根据前序遍历和中序遍历的结果重建一棵树">2.5. 根据前序遍历和中序遍历的结果重建一棵树</a></li>
<li><a href="#26-用两个栈实现队列">2.6. 用两个栈实现队列</a></li>
<li><a href="#27-旋转数组的最小数字">2.7. 旋转数组的最小数字</a></li>
<li><a href="#28-二进制中1的个数">2.8. 二进制中1的个数</a></li>
<li><a href="#29-数值的整数次方">2.9. 数值的整数次方</a></li>
<li><a href="#210-打印1到最大的n位数">2.10. 打印1到最大的n位数</a></li>
<li><a href="#211-在o1时间删除链表节点">2.11. 在O(1)时间删除链表节点</a></li>
<li><a href="#212-调整数组顺序使得奇数位于偶数前面">2.12. 调整数组顺序使得奇数位于偶数前面</a></li>
<li><a href="#213-反转链表">2.13. 反转链表</a></li>
<li><a href="#214-合并两个排序的链表">2.14. 合并两个排序的链表</a></li>
<li><a href="#215-树的子结构">2.15. 树的子结构</a></li>
<li><a href="#216-二叉树的镜像">2.16. 二叉树的镜像</a></li>
<li><a href="#217-顺时针打印矩阵">2.17. 顺时针打印矩阵</a></li>
<li><a href="#218-包含min函数的栈">2.18. 包含min函数的栈</a></li>
<li><a href="#219-栈的压入和弹出顺序匹配">2.19. 栈的压入和弹出顺序匹配</a></li>
<li><a href="#220-从上往下打印二叉树">2.20. 从上往下打印二叉树</a></li>
<li><a href="#221-二叉搜索树的后序遍历序列判断给定数组是不是一颗二叉搜索树的后序遍历序列">2.21. 二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）</a></li>
<li><a href="#222-二叉树中和为某值的路径直到叶节点">2.22. 二叉树中和为某值的路径（直到叶节点）</a></li>
<li><a href="#223-复杂链表的复制">2.23. 复杂链表的复制</a></li>
<li><a href="#224-二叉搜索树改为双向链表只调整树中节点指针的指向">2.24. 二叉搜索树改为双向链表（只调整树中节点指针的指向）</a></li>
<li><a href="#225-字符串的排列">2.25. 字符串的排列</a></li>
<li><a href="#226-数组中出现次数超过一半的数字">2.26. 数组中出现次数超过一半的数字</a></li>
<li><a href="#227-最小的k个数">2.27. 最小的k个数</a></li>
<li><a href="#228-连续子数组最大和">2.28. 连续子数组最大和</a></li>
<li><a href="#229-从1到n中1出现的次数">2.29. 从1到n中1出现的次数</a></li>
<li><a href="#230-数组排成最小的数">2.30. 数组排成最小的数</a></li>
<li><a href="#231-丑数列举">2.31. 丑数列举</a></li>
<li><a href="#232-第一个只出现一次的字符abcdacd输出b">2.32. 第一个只出现一次的字符（abcdacd输出b）</a></li>
<li><a href="#233-数组中的逆序对">2.33. 数组中的逆序对</a></li>
<li><a href="#234-遍历两个有公共节点的链表找到这个连接点">2.34. 遍历两个有公共节点的链表，找到这个连接点</a></li>
<li><a href="#235-数字在排序数组中出现的次数给定数组和数字输出数字在数组中出现的次数">2.35. 数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）</a></li>
<li><a href="#236-二叉树的深度">2.36. 二叉树的深度</a></li>
<li><a href="#237-判断是不是平衡二叉树任意左右子树深度相差不超过1">2.37. 判断是不是平衡二叉树（任意左右子树深度相差不超过1）</a></li>
<li><a href="#238-数组中只出现一次的一个数字">2.38. 数组中只出现一次的一个数字</a></li>
<li><a href="#239-数组中只出现一次的两个数字">2.39. 数组中只出现一次的两个数字</a></li>
<li><a href="#240-从数组中找到和为s的两个数字">2.40. 从数组中找到和为s的两个数字</a></li>
<li><a href="#241-输出所有和为s的连续正数序列">2.41. 输出所有和为S的连续正数序列</a></li>
<li><a href="#242-翻转单词顺序">2.42. 翻转单词顺序</a></li>
<li><a href="#243-左旋转字符串abcdef和数字2输出cdefab">2.43. 左旋转字符串（abcdef和数字2，输出cdefab）</a></li>
<li><a href="#244-n个骰子的点数每种点数的概率">2.44. n个骰子的点数（每种点数的概率）</a></li>
<li><a href="#245-扑克牌的顺子取五张牌判断是不是顺子">2.45. 扑克牌的顺子（取五张牌，判断是不是顺子）</a></li>
<li><a href="#246-圆圈中剩下的数字">2.46. 圆圈中剩下的数字</a></li>
<li><a href="#247-不用加减乘除做加法">2.47. 不用加减乘除做加法</a></li>
<li><a href="#248-两个面试案例">2.48. 两个面试案例</a></li>
<li><a href="#249-数组中重复的数字长度为n的数组并且数字都在0到n-1之间">2.49. 数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）</a></li>
<li><a href="#250-构建乘积数组不能使用除法">2.50. 构建乘积数组（不能使用除法）</a></li>
<li><a href="#251-字符串正则表达式匹配">2.51. 字符串正则表达式匹配</a></li>
<li><a href="#252-链表中环的入口结点">2.52. 链表中环的入口结点</a></li>
<li><a href="#253-删除链表中重复的节点">2.53. 删除链表中重复的节点</a></li>
<li><a href="#254-二叉树的下一个节点数中存在指向父节点的指针找到中序遍历的下一个节点">2.54. 二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）</a></li>
<li><a href="#255-对称的二叉树">2.55. 对称的二叉树</a></li>
<li><a href="#256-二叉树打印成多行">2.56. 二叉树打印成多行</a></li>
<li><a href="#257-序列化二叉树">2.57. 序列化二叉树</a></li>
<li><a href="#258-二叉搜索树的第k个节点第k大的节点">2.58. 二叉搜索树的第k个节点（第k大的节点）</a></li>
<li><a href="#259-数据流的中位数">2.59. 数据流的中位数</a></li>
<li><a href="#260-滑动窗口的最大值">2.60. 滑动窗口的最大值</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-面试需要注意的内容"><a href="#1-面试需要注意的内容" class="headerlink" title="1. 面试需要注意的内容"></a>1. 面试需要注意的内容</h2><ul>
<li>准备几个问题问面试官（根据公司、职位等等）</li>
<li>介绍自己做过的项目：简短的项目背景、完成的任务、未完成任务自己做了哪些方面的工作（以及怎么做的）、总结自己的贡献与收获</li>
<li>扎实的基础知识与高质量的代码：命名与缩进习惯，<strong>边界条件（boundary condition）的考虑</strong>，优化效率的能力，<strong>不合规范的输入的处理</strong>等等。</li>
</ul>
<h2 id="2-编程题"><a href="#2-编程题" class="headerlink" title="2. 编程题"></a>2. 编程题</h2><h3 id="2-1-从链表中查找倒数第k个值"><a href="#2-1-从链表中查找倒数第k个值" class="headerlink" title="2.1. 从链表中查找倒数第k个值"></a>2.1. 从链表中查找倒数第k个值</h3><p>两个指针，但是注意边界条件。</p>
<h3 id="2-2-从矩阵（从左到右，从上到下依次增大）中查找某值"><a href="#2-2-从矩阵（从左到右，从上到下依次增大）中查找某值" class="headerlink" title="2.2. 从矩阵（从左到右，从上到下依次增大）中查找某值"></a>2.2. 从矩阵（从左到右，从上到下依次增大）中查找某值</h3><p>从右往左入手选定列，在从上往下入手选定行。</p>
<h3 id="2-3-字符串替换"><a href="#2-3-字符串替换" class="headerlink" title="2.3. 字符串替换"></a>2.3. 字符串替换</h3><p>将原本一个字符换成多个字符时，注意从右往左（减少移动次数），同样类型的还有归并排序(两个排好序的数组，并且第二个数组后面有足够的空间方数据)，从后往前排。</p>
<h3 id="2-4-链表在不改变结构的情况下倒着输出"><a href="#2-4-链表在不改变结构的情况下倒着输出" class="headerlink" title="2.4. 链表在不改变结构的情况下倒着输出"></a>2.4. 链表在不改变结构的情况下倒着输出</h3><p>使用栈或者用递归的方法</p>
<h3 id="2-5-根据前序遍历和中序遍历的结果重建一棵树"><a href="#2-5-根据前序遍历和中序遍历的结果重建一棵树" class="headerlink" title="2.5. 根据前序遍历和中序遍历的结果重建一棵树"></a>2.5. 根据前序遍历和中序遍历的结果重建一棵树</h3><p>前序遍历第一个都是根节点，中序遍历中间的也是根节点；思路为：取前序第一个，已知为根节点，然后在中序遍历中找到这个值，这个值左边的部分是根节点的左子树（数量为n）的中序遍历结果，右边的部分是根节点的右子树（数量为m）的中序遍历结果，相对应于前序遍历（去掉第一个）结果，前n个为左子树的前序遍历结果，后m个为右子树的前序遍历结果。递归。</p>
<h3 id="2-6-用两个栈实现队列"><a href="#2-6-用两个栈实现队列" class="headerlink" title="2.6. 用两个栈实现队列"></a>2.6. 用两个栈实现队列</h3><p>根据栈和队列的不同（栈先进后出，队列先进先出）。栈1用来实际入栈，栈2用来实际出栈，实现方式：为当需要进栈的时候，数据进入栈1，当需要出栈的时候，查看栈2是否为空，如果为空，则从栈1将所有数据出栈并入到栈2。</p>
<h3 id="2-7-旋转数组的最小数字"><a href="#2-7-旋转数组的最小数字" class="headerlink" title="2.7. 旋转数组的最小数字"></a>2.7. 旋转数组的最小数字</h3><p>使用二分查找的思想。设定两个指针p1和p2，若p1与p2相邻则取p2。若<code>p1&lt;p2</code>，取中间指针p3，若p3大于p1，则最小数字在p3到p2间，否则在p1到p3间。</p>
<h3 id="2-8-二进制中1的个数"><a href="#2-8-二进制中1的个数" class="headerlink" title="2.8. 二进制中1的个数"></a>2.8. 二进制中1的个数</h3><p>注意负数在二进制中最高位是1，如果使用<code>&gt;&gt;</code>进行移位操作，为了保证还是负数，不会改变最高位。两种方法，使用数字1进行二进制与操作，然后把1左移一位<code>&lt;&lt; 1</code>，继续与，直到结果为0。第二种方法，注意到整数a，与a-1进行与操作可以逐步消去最右端的1。</p>
<h3 id="2-9-数值的整数次方"><a href="#2-9-数值的整数次方" class="headerlink" title="2.9. 数值的整数次方"></a>2.9. 数值的整数次方</h3><p>注意整数次方，这里的整数还包含0和负数。还要注意对输入值的是否和法判断，判断两个double类型的数据是否相等不能直接使用<code>==</code>，而应该用差很小来表示。同时考虑整数次方，一次一次的相乘不够快，可以除以二然后相乘，也就是递归了。</p>
<h3 id="2-10-打印1到最大的n位数"><a href="#2-10-打印1到最大的n位数" class="headerlink" title="2.10. 打印1到最大的n位数"></a>2.10. 打印1到最大的n位数</h3><p>注意这里的n位数是否会是大数问题。可以打印全排列，使用递归思想，另外打印的时候注意前面是0的话就不要打印了。</p>
<h3 id="2-11-在O-1-时间删除链表节点"><a href="#2-11-在O-1-时间删除链表节点" class="headerlink" title="2.11. 在O(1)时间删除链表节点"></a>2.11. 在O(1)时间删除链表节点</h3><p>假设这个节点是node2delete，可以把node2delete.nextNode的值赋值给node2.delete，然后让node2delete指向下下个节点。</p>
<h3 id="2-12-调整数组顺序使得奇数位于偶数前面"><a href="#2-12-调整数组顺序使得奇数位于偶数前面" class="headerlink" title="2.12. 调整数组顺序使得奇数位于偶数前面"></a>2.12. 调整数组顺序使得奇数位于偶数前面</h3><p>主要思想是快排里面的Partition思想，只不过是左边找偶数，右边找奇数。通过拓展条件（使用函数），这一思想适用于更多场景。</p>
<h3 id="2-13-反转链表"><a href="#2-13-反转链表" class="headerlink" title="2.13. 反转链表"></a>2.13. 反转链表</h3><p>记录3个指针，分别代表<code>pNodeCurrent, pNodePrev, pReversedHead</code>。注意考虑输入为NULL以及链表的断裂情况</p>
<h3 id="2-14-合并两个排序的链表"><a href="#2-14-合并两个排序的链表" class="headerlink" title="2.14. 合并两个排序的链表"></a>2.14. 合并两个排序的链表</h3><p>基本同上</p>
<h3 id="2-15-树的子结构"><a href="#2-15-树的子结构" class="headerlink" title="2.15. 树的子结构"></a>2.15. 树的子结构</h3><p>递归查找匹配</p>
<h3 id="2-16-二叉树的镜像"><a href="#2-16-二叉树的镜像" class="headerlink" title="2.16. 二叉树的镜像"></a>2.16. 二叉树的镜像</h3><p>递归交换左右子树</p>
<h3 id="2-17-顺时针打印矩阵"><a href="#2-17-顺时针打印矩阵" class="headerlink" title="2.17. 顺时针打印矩阵"></a>2.17. 顺时针打印矩阵</h3><p>打印每一圈都分四步。主要是注意最后一圈可能退化成只有一行或者只有一列。这样打印最后一圈可能只需要3,2,1步。</p>
<h3 id="2-18-包含min函数的栈"><a href="#2-18-包含min函数的栈" class="headerlink" title="2.18. 包含min函数的栈"></a>2.18. 包含min函数的栈</h3><p>使用辅助栈记录每一个数据进栈之后更新的最小值</p>
<h3 id="2-19-栈的压入和弹出顺序匹配"><a href="#2-19-栈的压入和弹出顺序匹配" class="headerlink" title="2.19. 栈的压入和弹出顺序匹配"></a>2.19. 栈的压入和弹出顺序匹配</h3><p>栈的经典题目</p>
<h3 id="2-20-从上往下打印二叉树"><a href="#2-20-从上往下打印二叉树" class="headerlink" title="2.20. 从上往下打印二叉树"></a>2.20. 从上往下打印二叉树</h3><p>使用队列，每从队列中出一个节点，同时把节点的左右节点的值入队列。</p>
<h3 id="2-21-二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）"><a href="#2-21-二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）" class="headerlink" title="2.21. 二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）"></a>2.21. 二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）</h3><p>注意后序遍历的特点，根节点的值在最后面，而且是根节点的左子树遍历结果都小于根节点，右子树比那里结果都大于根节点。选定根节点，将前面的n-1个值切分为2部分，小于根节点值的是左子树，大于根节点值的是右子树。递归。</p>
<h3 id="2-22-二叉树中和为某值的路径（直到叶节点）"><a href="#2-22-二叉树中和为某值的路径（直到叶节点）" class="headerlink" title="2.22. 二叉树中和为某值的路径（直到叶节点）"></a>2.22. 二叉树中和为某值的路径（直到叶节点）</h3><p>其实是二叉树深度优先遍历的变种。每次递归完成之后都要返回父节点。</p>
<h3 id="2-23-复杂链表的复制"><a href="#2-23-复杂链表的复制" class="headerlink" title="2.23. 复杂链表的复制"></a>2.23. 复杂链表的复制</h3><p>举例子：原链表:<code>a-&gt;b-&gt;c-&gt;d</code>，先复制成<code>a-a&#39;-&gt;b-&gt;b&#39;-&gt;c-&gt;c&#39;-&gt;d-&gt;d&#39;</code>。然后挪动复杂指针一位就行。之后再分开。</p>
<h3 id="2-24-二叉搜索树改为双向链表（只调整树中节点指针的指向）"><a href="#2-24-二叉搜索树改为双向链表（只调整树中节点指针的指向）" class="headerlink" title="2.24. 二叉搜索树改为双向链表（只调整树中节点指针的指向）"></a>2.24. 二叉搜索树改为双向链表（只调整树中节点指针的指向）</h3><p>中序遍历思想。<a href="https://github.com/chen-kh/InterviewQuestions/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%9827%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8_ConvertBinarySearchTree.cpp" target="_blank" rel="noopener">戳这里查看代码详细</a></p>
<h3 id="2-25-字符串的排列"><a href="#2-25-字符串的排列" class="headerlink" title="2.25. 字符串的排列"></a>2.25. 字符串的排列</h3><p>主要思想是使用递归，然后把字符串排列看作两种情况：第一种是第一个是a，第二种是第一个不是a。第二种的得到就是把a和后面的每个字符进行互换操作得到。因此可以递归了。<a href="https://github.com/chen-kh/InterviewQuestions/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%9828%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97_StringPermutation.cpp" target="_blank" rel="noopener">戳这里查看代码详细</a></p>
<h3 id="2-26-数组中出现次数超过一半的数字"><a href="#2-26-数组中出现次数超过一半的数字" class="headerlink" title="2.26. 数组中出现次数超过一半的数字"></a>2.26. 数组中出现次数超过一半的数字</h3><p>解法一：基于快排的思想，更改partition函数，复杂度O(n)。跟找第k大的数是一样的，我们这次找第n/2个数。</p>
<p>解法二：根据数组特点完成算法，时间复杂度也是O(n)。保存两个变量<code>currentValue</code>和<code>preValue</code>，二者相同则加1，不同则减1。最有一个使得值为1的书就是超过一半的数字。</p>
<h3 id="2-27-最小的k个数"><a href="#2-27-最小的k个数" class="headerlink" title="2.27. 最小的k个数"></a>2.27. 最小的k个数</h3><p>解法一：基于快排的思想，知道随机找的数字最终落在了k位上。跟第k小数字如出一辙，复杂度O(n)</p>
<p>解法二：使用最小堆。需要堆或者红黑树来进行辅助。但是适用于大量数据的处理。复杂度O(nlogk)</p>
<h3 id="2-28-连续子数组最大和"><a href="#2-28-连续子数组最大和" class="headerlink" title="2.28. 连续子数组最大和"></a>2.28. 连续子数组最大和</h3><p>经典动态规划</p>
<h3 id="2-29-从1到n中1出现的次数"><a href="#2-29-从1到n中1出现的次数" class="headerlink" title="2.29. 从1到n中1出现的次数"></a>2.29. 从1到n中1出现的次数</h3><p>解法一：比较复杂。举例子说明。n=21345，（1-21345）转换为（1-1345）+（1346-21345），只处理第二部分，第一部分用相同的方法递归求解。第二部分分为（1346-11345）和（11346-21345），最高位出现1的次数10000次，最高位之外出现1的次数，固定一位，则其他位任意，<code>2*4*1000=8000</code>次。</p>
<p>解法二：<a href="https://blog.csdn.net/yi_afly/article/details/52012593" target="_blank" rel="noopener">详情戳这里</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（53*1+1）+（5*10+10）+（0*100+100）= 214</span><br><span class="line">530 = （53*1）+（5*10+10）+（0*100+100） = 213</span><br><span class="line">504 = （50*1+1）+（5*10）+（0*100+100） = 201</span><br><span class="line">514 = （51*1+1）+（5*10+4+1）+（0*100+100） = 207</span><br><span class="line">10 = (1*1)+(0*10+0+1) = 2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> round = n;</span><br><span class="line">    <span class="keyword">while</span>(round&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> weight = round%<span class="number">10</span>;</span><br><span class="line">        round/=<span class="number">10</span>;</span><br><span class="line">        count += round*base;</span><br><span class="line">        <span class="keyword">if</span>(weight==<span class="number">1</span>)</span><br><span class="line">            count+=(n%base)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(weight&gt;<span class="number">1</span>)</span><br><span class="line">            count+=base;</span><br><span class="line">        base*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-30-数组排成最小的数"><a href="#2-30-数组排成最小的数" class="headerlink" title="2.30. 数组排成最小的数"></a>2.30. 数组排成最小的数</h3><p>归根结底是比较两个数谁排在前谁排在后的问题。设定规则：数a和数b，若ab&gt;ba，则a&gt;b，根据这个规则对数组进行排序。</p>
<h3 id="2-31-丑数列举"><a href="#2-31-丑数列举" class="headerlink" title="2.31. 丑数列举"></a>2.31. 丑数列举</h3><p>只有2,3,5作为因子组成的数。思想是一直保存这些整数，然后找后面紧邻的一个，紧邻的这个一定是前面的数乘以2,3,5得到，找一个最小的就行。</p>
<h3 id="2-32-第一个只出现一次的字符（abcdacd输出b）"><a href="#2-32-第一个只出现一次的字符（abcdacd输出b）" class="headerlink" title="2.32. 第一个只出现一次的字符（abcdacd输出b）"></a>2.32. 第一个只出现一次的字符（abcdacd输出b）</h3><p>使用hash表进行存储，ascii码表，256长度就够。key就是字符的ascii码值，value就是出现的次数，一次就是1，多次就是-1。</p>
<h3 id="2-33-数组中的逆序对"><a href="#2-33-数组中的逆序对" class="headerlink" title="2.33. 数组中的逆序对"></a>2.33. 数组中的逆序对</h3><p>归并排序思想</p>
<h3 id="2-34-遍历两个有公共节点的链表，找到这个连接点"><a href="#2-34-遍历两个有公共节点的链表，找到这个连接点" class="headerlink" title="2.34. 遍历两个有公共节点的链表，找到这个连接点"></a>2.34. 遍历两个有公共节点的链表，找到这个连接点</h3><p>两种思路，第一种使用两个辅助栈，入栈完毕后，同时出栈，直到最后两个相同的指针；第二种不使用辅助栈，遍历两遍两个链表，第一次确定长短，然后先在长链上走几步，之后齐头并进，直到找到相同的指针。</p>
<h3 id="2-35-数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）"><a href="#2-35-数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）" class="headerlink" title="2.35. 数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）"></a>2.35. 数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）</h3><p>基本思路是遍历，但是这并没有利用排序数组的优势。这里主要思想是使用二分查找的思想。查找两次，第一次找第一次出现的下标，第二次找最后一次出现的下标。第一次找的时候，如果中间值大于等于当前值，往左找（判断是不是第一个）。第二次找的时候反过来。</p>
<h3 id="2-36-二叉树的深度"><a href="#2-36-二叉树的深度" class="headerlink" title="2.36. 二叉树的深度"></a>2.36. 二叉树的深度</h3><p>递归思想</p>
<h3 id="2-37-判断是不是平衡二叉树（任意左右子树深度相差不超过1）"><a href="#2-37-判断是不是平衡二叉树（任意左右子树深度相差不超过1）" class="headerlink" title="2.37. 判断是不是平衡二叉树（任意左右子树深度相差不超过1）"></a>2.37. 判断是不是平衡二叉树（任意左右子树深度相差不超过1）</h3><p>不要直接递归左右子树找到深度然后比较，这样有节点多次被遍历。使用后序遍历，遍历时记录深度。</p>
<h3 id="2-38-数组中只出现一次的一个数字"><a href="#2-38-数组中只出现一次的一个数字" class="headerlink" title="2.38. 数组中只出现一次的一个数字"></a>2.38. 数组中只出现一次的一个数字</h3><p>异或一遍</p>
<h3 id="2-39-数组中只出现一次的两个数字"><a href="#2-39-数组中只出现一次的两个数字" class="headerlink" title="2.39. 数组中只出现一次的两个数字"></a>2.39. 数组中只出现一次的两个数字</h3><p>异或一遍，从结果中找到第一位不是0（是1）的位，假设为第n位。继续异或一遍，分成两个数组，第一个数组第n位都是1，第二个数组都是0。两个数组分别异或就找出来了。</p>
<h3 id="2-40-从数组中找到和为s的两个数字"><a href="#2-40-从数组中找到和为s的两个数字" class="headerlink" title="2.40. 从数组中找到和为s的两个数字"></a>2.40. 从数组中找到和为s的两个数字</h3><p>如果数组是递增的，那么两个指针，一个最前一个最后，如果两个指针的和小于s，那么第一个加一，若大于s，第二个减一。</p>
<h3 id="2-41-输出所有和为S的连续正数序列"><a href="#2-41-输出所有和为S的连续正数序列" class="headerlink" title="2.41. 输出所有和为S的连续正数序列"></a>2.41. 输出所有和为S的连续正数序列</h3><p>跟上面类似，两个指针，一个small，一个big，如果和大于sum，则small++，sum-=small,否则big++,sum+=big</p>
<h3 id="2-42-翻转单词顺序"><a href="#2-42-翻转单词顺序" class="headerlink" title="2.42. 翻转单词顺序"></a>2.42. 翻转单词顺序</h3><p>先整体翻转一次，然后每个单词再单独翻转一次。</p>
<h3 id="2-43-左旋转字符串（abcdef和数字2，输出cdefab）"><a href="#2-43-左旋转字符串（abcdef和数字2，输出cdefab）" class="headerlink" title="2.43. 左旋转字符串（abcdef和数字2，输出cdefab）"></a>2.43. 左旋转字符串（abcdef和数字2，输出cdefab）</h3><p>把字符串按照数字分成两部分，先每个部分翻转，然后整体翻转。跟上面的那道题很像的。</p>
<h3 id="2-44-n个骰子的点数（每种点数的概率）"><a href="#2-44-n个骰子的点数（每种点数的概率）" class="headerlink" title="2.44. n个骰子的点数（每种点数的概率）"></a>2.44. n个骰子的点数（每种点数的概率）</h3><p>数组存放n到6n。下标表示筛子数，对应的值表示出现的次数。一个骰子一个骰子的往上添加，第一个筛子都是1，第二个骰子的和为n的出现次数，是上一次骰子里面的n-1,n-2,n-3,n-4,n-5,n-6的和。</p>
<h3 id="2-45-扑克牌的顺子（取五张牌，判断是不是顺子）"><a href="#2-45-扑克牌的顺子（取五张牌，判断是不是顺子）" class="headerlink" title="2.45. 扑克牌的顺子（取五张牌，判断是不是顺子）"></a>2.45. 扑克牌的顺子（取五张牌，判断是不是顺子）</h3><p>先排序，然后看差几张，如果0能补上就没问题。</p>
<h3 id="2-46-圆圈中剩下的数字"><a href="#2-46-圆圈中剩下的数字" class="headerlink" title="2.46. 圆圈中剩下的数字"></a>2.46. 圆圈中剩下的数字</h3><p>关键在于通过映射，转换成新环，去发现规律，然后成为动态规划问题。（递归也可以）</p>
<h3 id="2-47-不用加减乘除做加法"><a href="#2-47-不用加减乘除做加法" class="headerlink" title="2.47. 不用加减乘除做加法"></a>2.47. 不用加减乘除做加法</h3><p>发散思维，使用二进制加法，先异或得到不进位的位。然后两个数求与再左移一位，得到进位的值。（第一个得到的数替换原数值1，第二个得到的数替换原数值2）。循环直到没有进位。</p>
<h3 id="2-48-两个面试案例"><a href="#2-48-两个面试案例" class="headerlink" title="2.48. 两个面试案例"></a>2.48. 两个面试案例</h3><ul>
<li>把字符串转换成整数：不要想当然一位多简单，要考虑多种边界条件</li>
<li>两个树节点的最低公共祖先  <ul>
<li>排序二叉树的话直接找第一个使得两个树节点分别小于和大于当前节点值就可以了-最简单</li>
<li>普通的树如果存在指向父节点的指针，就转换成了链表找第一个公共点</li>
<li>最普通树的话，解决方法就是深度（或者广度）优先找两条路径，然后记录下来进行对比。</li>
</ul>
</li>
</ul>
<h3 id="2-49-数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）"><a href="#2-49-数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）" class="headerlink" title="2.49. 数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）"></a>2.49. 数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）</h3><ul>
<li>最基本的方法是排序，然后找到重复的数字</li>
<li>第二种方法是观察数组的规律：由于数字都在0到n-1之间，所以正常情况下数字的下标应该和数字本身相等。因此我们遍历数组，从第一个开始，查看值与下标是否相等，如果不相等的话就把该数值a与下标为a的值进行比较，如果相等，则找到重复的数字，如果不相等就交换数值，也就是数值a归位了。如此循环直到遍历完成。由于每个数值最多两次操作就可以归位，因此时间复杂度O(1)</li>
</ul>
<h3 id="2-50-构建乘积数组（不能使用除法）"><a href="#2-50-构建乘积数组（不能使用除法）" class="headerlink" title="2.50. 构建乘积数组（不能使用除法）"></a>2.50. 构建乘积数组（不能使用除法）</h3><p>建立一个矩阵，然后使用两个辅助数组。</p>
<h3 id="2-51-字符串正则表达式匹配"><a href="#2-51-字符串正则表达式匹配" class="headerlink" title="2.51. 字符串正则表达式匹配"></a>2.51. 字符串正则表达式匹配</h3><p>使用递归的思想，两个指针，一个指向字符，一个指向模式。匹配后把后面的部分递归处理。主要问题是处理<code>*</code>的情况，指向字符的指针可以移动1次或两次或者不移动。</p>
<h3 id="2-52-链表中环的入口结点"><a href="#2-52-链表中环的入口结点" class="headerlink" title="2.52. 链表中环的入口结点"></a>2.52. 链表中环的入口结点</h3><p>分两步走，第一步确定环的数量，第二步两个指针，第一个指针先走n步(n就是环内结点数量)，然后两个指针齐头并进，相遇的时候就是入口结点。第一步确定环的数量，同样设定两个指针，第一个每次走一步，第二个每次走两步，相遇的时候就是在节点内（其实相遇的时候第一个节点走了几步就是有几个节点了）。然后可以循环一次算出节点数。</p>
<h3 id="2-53-删除链表中重复的节点"><a href="#2-53-删除链表中重复的节点" class="headerlink" title="2.53. 删除链表中重复的节点"></a>2.53. 删除链表中重复的节点</h3><p>常规思路</p>
<h3 id="2-54-二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）"><a href="#2-54-二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）" class="headerlink" title="2.54. 二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）"></a>2.54. 二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）</h3><p>其实很简单，一步一步考虑算法就可以了。如果这个节点存在右节点，那么肯定就是右节点中序遍历的第一个值，如果这个节点不存在右节点，但是他是某个节点的左节点，那下一个节点就是他的父节点，如果他是父节点的右节点，就要向上去找父节点，直到找到一个父节点是它父节点的左子节点，那就是这个父节点了。</p>
<h3 id="2-55-对称的二叉树"><a href="#2-55-对称的二叉树" class="headerlink" title="2.55. 对称的二叉树"></a>2.55. 对称的二叉树</h3><p>把NULL节点的值也输出，这样如果后序遍历和从右开始的后序遍历输出结果一样的话就是对称的。</p>
<h3 id="2-56-二叉树打印成多行"><a href="#2-56-二叉树打印成多行" class="headerlink" title="2.56. 二叉树打印成多行"></a>2.56. 二叉树打印成多行</h3><p>如果每行都是从左到右或者从右到左的话，那就是典型的队列的问题。如果按照之字形打印，就使用两个栈。第一个栈存放偶数行的遍历结果，第二个栈存放奇数行的遍历结果，第一个栈都是先左节点后右节点，第二个栈反过来。</p>
<h3 id="2-57-序列化二叉树"><a href="#2-57-序列化二叉树" class="headerlink" title="2.57. 序列化二叉树"></a>2.57. 序列化二叉树</h3><p>进行带空指针输出的前向遍历。可以反推回来。</p>
<h3 id="2-58-二叉搜索树的第k个节点（第k大的节点）"><a href="#2-58-二叉搜索树的第k个节点（第k大的节点）" class="headerlink" title="2.58. 二叉搜索树的第k个节点（第k大的节点）"></a>2.58. 二叉搜索树的第k个节点（第k大的节点）</h3><p>中序遍历，一边遍历，一遍查找。</p>
<h3 id="2-59-数据流的中位数"><a href="#2-59-数据流的中位数" class="headerlink" title="2.59. 数据流的中位数"></a>2.59. 数据流的中位数</h3><p>使用两个堆，最大堆在左边，最小堆在右边，保证最大堆的每个值都小于最小堆的每个值。发生冲突就往该放的堆里放，然后从这个堆里挑出最大值或者最小值放到另外一个堆里。</p>
<h3 id="2-60-滑动窗口的最大值"><a href="#2-60-滑动窗口的最大值" class="headerlink" title="2.60. 滑动窗口的最大值"></a>2.60. 滑动窗口的最大值</h3><p>为了保证是O(n)复杂度，滑动窗口是用双向队列表示，里面只存储是最大值或者可能是下一个最大值的值。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/ml_ai_ann/机器学习中距离和相似性度量方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/ml_ai_ann/机器学习中距离和相似性度量方法/" itemprop="url">机器学习中距离和相似性度量方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机器学习中距离和相似性度量方法"><a href="#机器学习中距离和相似性度量方法" class="headerlink" title="机器学习中距离和相似性度量方法"></a>机器学习中距离和相似性度量方法</h1><p>声明：本文主要参考文章 <a href="http://dataunion.org/11710.html" target="_blank" rel="noopener">机器学习中距离和相似性度量方法</a></p>
<p>在机器学习和数据挖掘中，我们经常需要知道个体间差异的大小，进而评价个体的相似性和类别。最常见的是数据分析中的相关分析，数据挖掘中的分类和聚类算法，如 K 最近邻（KNN）和 K 均值（K-Means）等等。根据数据特性的不同，可以采用不同的度量方法。一般而言，定义一个距离函数 d(x,y), 需要满足下面几个准则：<br>1) d(x,x) = 0                    // 到自己的距离为0<br>2) d(x,y) &gt;= 0                  // 距离非负<br>3) d(x,y) = d(y,x)             // 对称性: 如果 A 到 B 距离是 a，那么 B 到 A 的距离也应该是 a<br>4) d(x,k)+ d(k,y) &gt;= d(x,y)    // 三角形法则: (两边之和大于第三边)</p>
<p>这篇博客主要介绍机器学习和数据挖掘中一些常见的距离公式，包括：<br><strong>闵可夫斯基距离、欧几里得距离、曼哈顿距离、切比雪夫距离、马氏距离、余弦相似度、皮尔逊相关系数、汉明距离、杰卡德相似系数、编辑距离、DTW距离、KL散度</strong></p>
<p>有时间再整理</p>
<h2 id="闵可夫斯基距离"><a href="#闵可夫斯基距离" class="headerlink" title="闵可夫斯基距离"></a>闵可夫斯基距离</h2><p>闵可夫斯基距离（Minkowski distance）是衡量数值点之间距离的一种非常常见的方法，假设数值点 P 和 Q 坐标如下：</p>
<div align="center"><img src="http://dataunion.org/wp-content/uploads/2015/03/07220422-b6c5a38eccb74824b92ba1b40c9dd92f.png" alt="figure1"></div>

<p>那么，闵可夫斯基距离定义为：</p>
<p><img src="http://dataunion.org/wp-content/uploads/2015/03/07220504-12655edb08dc45ae8a036d8028743042.png" alt="figure2"></p>
<p>该距离最常用的 p 是 2 和 1, 前者是欧几里得距离（Euclidean distance），后者是曼哈顿距离（Manhattan distance）。假设在曼哈顿街区乘坐出租车从 P 点到 Q 点，白色表示高楼大厦，灰色表示街道：</p>
<p>绿色的斜线表示欧几里得距离，在现实中是不可能的。其他三条折线表示了曼哈顿距离，这三条折线的长度是相等的。<br>当 p 趋近于无穷大时，闵可夫斯基距离转化成切比雪夫距离（Chebyshev distance）：</p>
<p>我们知道平面上到原点欧几里得距离（p = 2）为 1 的点所组成的形状是一个圆，当 p 取其他数值的时候呢？</p>
<p>注意，当 p &lt; 1 时，闵可夫斯基距离不再符合三角形法则，举个例子：当 p &lt; 1, (0,0) 到 (1,1) 的距离等于 (1+1)^{1/p} &gt; 2, 而 (0,1) 到这两个点的距离都是 1。<br>闵可夫斯基距离比较直观，但是它与数据的分布无关，具有一定的局限性，如果 x 方向的幅值远远大于 y 方向的值，这个距离公式就会过度放大 x 维度的作用。所以，在计算距离之前，我们可能还需要对数据进行 z-transform 处理，即减去均值，除以标准差：</p>
<p> : 该维度上的均值<br> : 该维度上的标准差<br>可以看到，上述处理开始体现数据的统计特性了。这种方法在假设数据各个维度不相关的情况下利用数据分布的特性计算出不同的距离。如果维度相互之间数据相关（例如：身高较高的信息很有可能会带来体重较重的信息，因为两者是有关联的），这时候就要用到马氏距离（Mahalanobis distance）了。</p>
<ol start="2">
<li>马氏距离<br>考虑下面这张图，椭圆表示等高线，从欧几里得的距离来算，绿黑距离大于红黑距离，但是从马氏距离，结果恰好相反：</li>
</ol>
<p>马氏距离实际上是利用 Cholesky transformation 来消除不同维度之间的相关性和尺度不同的性质。假设样本点（列向量）之间的协方差对称矩阵是  ， 通过 Cholesky Decomposition（实际上是对称矩阵 LU 分解的一种特殊形式，可参考之前的博客）可以转化为下三角矩阵和上三角矩阵的乘积：  。消除不同维度之间的相关性和尺度不同，只需要对样本点 x 做如下处理： 。处理之后的欧几里得距离就是原样本的马氏距离：为了书写方便，这里求马氏距离的平方）：</p>
<p>下图蓝色表示原样本点的分布，两颗红星坐标分别是（3, 3），（2, -2）:</p>
<p>由于 x， y 方向的尺度不同，不能单纯用欧几里得的方法测量它们到原点的距离。并且，由于 x 和 y 是相关的（大致可以看出斜向右上），也不能简单地在 x 和 y 方向上分别减去均值，除以标准差。最恰当的方法是对原始数据进行 Cholesky 变换，即求马氏距离（可以看到，右边的红星离原点较近）：</p>
<p>将上面两个图的绘制代码和求马氏距离的代码贴在这里，以备以后查阅：<br> View Code</p>
<p>马氏距离的变换和 PCA 分解的白化处理颇有异曲同工之妙，不同之处在于：就二维来看，PCA 是将数据主成分旋转到 x 轴（正交矩阵的酉变换），再在尺度上缩放（对角矩阵），实现尺度相同。而马氏距离的 L逆矩阵是一个下三角，先在 x 和 y 方向进行缩放，再在 y 方向进行错切（想象矩形变平行四边形），总体来说是一个没有旋转的仿射变换。</p>
<ol start="3">
<li>向量内积<br>向量内积是线性代数里最为常见的计算，实际上它还是一种有效并且直观的相似性测量手段。向量内积的定义如下：</li>
</ol>
<p>直观的解释是：如果 x 高的地方 y 也比较高， x 低的地方 y 也比较低，那么整体的内积是偏大的，也就是说 x 和 y 是相似的。举个例子，在一段长的序列信号 A 中寻找哪一段与短序列信号 a 最匹配，只需要将 a 从 A 信号开头逐个向后平移，每次平移做一次内积，内积最大的相似度最大。信号处理中 DFT 和 DCT 也是基于这种内积运算计算出不同频域内的信号组分（DFT 和 DCT 是正交标准基，也可以看做投影）。向量和信号都是离散值，如果是连续的函数值，比如求区间[-1, 1] 两个函数之间的相似度，同样也可以得到（系数）组分，这种方法可以应用于多项式逼近连续函数，也可以用到连续函数逼近离散样本点（最小二乘问题，OLS coefficients）中，扯得有点远了- -!。<br>向量内积的结果是没有界限的，一种解决办法是除以长度之后再求内积，这就是应用十分广泛的余弦相似度（Cosine similarity）：</p>
<p>余弦相似度与向量的幅值无关，只与向量的方向相关，在文档相似度（TF-IDF）和图片相似性（histogram）计算上都有它的身影。需要注意一点的是，余弦相似度受到向量的平移影响，上式如果将 x 平移到 x+1, 余弦值就会改变。怎样才能实现平移不变性？这就是下面要说的皮尔逊相关系数（Pearson correlation），有时候也直接叫相关系数:</p>
<p>皮尔逊相关系数具有平移不变性和尺度不变性，计算出了两个向量（维度）的相关性。不过，一般我们在谈论相关系数的时候，将 x 与 y 对应位置的两个数值看作一个样本点，皮尔逊系数用来表示这些样本点分布的相关性。</p>
<p>由于皮尔逊系数具有的良好性质，在各个领域都应用广泛，例如，在推荐系统根据为某一用户查找喜好相似的用户,进而提供推荐，优点是可以不受每个用户评分标准不同和观看影片数量不一样的影响。</p>
<ol start="4">
<li>分类数据点间的距离<br>汉明距离（Hamming distance）是指，两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。举个维基百科上的例子：</li>
</ol>
<p>还可以用简单的匹配系数来表示两点之间的相似度——匹配字符数/总字符数。<br>在一些情况下，某些特定的值相等并不能代表什么。举个例子，用 1 表示用户看过该电影，用 0 表示用户没有看过，那么用户看电影的的信息就可用 0,1 表示成一个序列。考虑到电影基数非常庞大，用户看过的电影只占其中非常小的一部分，如果两个用户都没有看过某一部电影（两个都是 0），并不能说明两者相似。反而言之，如果两个用户都看过某一部电影（序列中都是 1），则说明用户有很大的相似度。在这个例子中，序列中等于 1 所占的权重应该远远大于 0 的权重，这就引出下面要说的杰卡德相似系数（Jaccard similarity）。<br>在上面的例子中，用 M11 表示两个用户都看过的电影数目，M10 表示用户 A 看过，用户 B 没看过的电影数目，M01 表示用户 A 没看过，用户 B 看过的电影数目，M00 表示两个用户都没有看过的电影数目。Jaccard 相似性系数可以表示为：</p>
<p>Jaccard similarity 还可以用集合的公式来表达，这里就不多说了。<br>如果分类数值点是用树形结构来表示的，它们的相似性可以用相同路径的长度来表示，比如，“/product/spot/ballgame/basketball” 离“product/spot/ballgame/soccer/shoes” 的距离小于到 “/product/luxury/handbags” 的距离，以为前者相同父节点路径更长。</p>
<ol start="5">
<li>序列之间的距离<br>上一小节我们知道，汉明距离可以度量两个长度相同的字符串之间的相似度，如果要比较两个不同长度的字符串，不仅要进行替换，而且要进行插入与删除的运算，在这种场合下，通常使用更加复杂的编辑距离（Edit distance, Levenshtein distance）等算法。编辑距离是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。编辑距离求的是最少编辑次数，这是一个动态规划的问题，有兴趣的同学可以自己研究研究。<br>时间序列是序列之间距离的另外一个例子。DTW 距离（Dynamic Time Warp）是序列信号在时间或者速度上不匹配的时候一种衡量相似度的方法。神马意思？举个例子，两份原本一样声音样本A、B都说了“你好”，A在时间上发生了扭曲，“你”这个音延长了几秒。最后A:“你~~~好”，B：“你好”。DTW正是这样一种可以用来匹配A、B之间的最短距离的算法。<br>DTW 距离在保持信号先后顺序的限制下对时间信号进行“膨胀”或者“收缩”，找到最优的匹配，与编辑距离相似，这其实也是一个动态规划的问题:</li>
</ol>
<p>实现代码（转自 McKelvin’s Blog ）:<br> View Code</p>
<ol start="6">
<li>概率分布之间的距离<br>前面我们谈论的都是两个数值点之间的距离，实际上两个概率分布之间的距离是可以测量的。在统计学里面经常需要测量两组样本分布之间的距离，进而判断出它们是否出自同一个 population，常见的方法有卡方检验（Chi-Square）和 KL 散度（ KL-Divergence），下面说一说 KL 散度吧。<br>先从信息熵说起，假设一篇文章的标题叫做“黑洞到底吃什么”，包含词语分别是 {黑洞, 到底, 吃什么}, 我们现在要根据一个词语推测这篇文章的类别。哪个词语给予我们的信息最多？很容易就知道是“黑洞”，因为“黑洞”这个词语在所有的文档中出现的概率太低啦，一旦出现，就表明这篇文章很可能是在讲科普知识。而其他两个词语“到底”和“吃什么”出现的概率很高，给予我们的信息反而越少。如何用一个函数 h(x) 表示词语给予的信息量呢？第一，肯定是与 p(x) 相关，并且是负相关。第二，假设 x 和 y 是独立的（黑洞和宇宙不相互独立，谈到黑洞必然会说宇宙）,即 p(x,y) = p(x)p(y), 那么获得的信息也是叠加的，即 h(x, y) = h(x) + h(y)。满足这两个条件的函数肯定是负对数形式：</li>
</ol>
<p>对假设一个发送者要将随机变量 X 产生的一长串随机值传送给接收者， 接受者获得的平均信息量就是求它的数学期望：</p>
<p>这就是熵的概念。另外一个重要特点是，熵的大小与字符平均最短编码长度是一样的（shannon）。设有一个未知的分布 p(x), 而 q(x) 是我们所获得的一个对 p(x) 的近似，按照 q(x) 对该随机变量的各个值进行编码，平均长度比按照真实分布的 p(x) 进行编码要额外长一些，多出来的长度这就是 KL 散度（之所以不说距离，是因为不满足对称性和三角形法则），即：</p>
<p>KL 散度又叫相对熵（relative entropy）。了解机器学习的童鞋应该都知道，在 Softmax 回归（或者 Logistic 回归），最后的输出节点上的值表示这个样本分到该类的概率，这就是一个概率分布。对于一个带有标签的样本，我们期望的概率分布是：分到标签类的概率是 1， 其他类概率是 0。但是理想很丰满，现实很骨感，我们不可能得到完美的概率输出，能做的就是尽量减小总样本的 KL 散度之和（目标函数）。这就是 Softmax 回归或者 Logistic 回归中 Cost function 的优化过程啦。（PS：因为概率和为 1，一般的 logistic 二分类的图只画了一个输出节点，隐藏了另外一个）</p>
<p>待补充的方法：<br>卡方检验 Chi-Square<br>衡量 categorical attributes 相关性的 mutual information<br>Spearman’s rank coefficient<br>Earth Mover’s Distance<br>SimRank 迭代算法等。</p>
<p>参考资料：<br>距离和相似性度量<br>Machine Learning: Measuring Similarity and Distance<br>What is Mahalanobis distance?<br>Cosine similarity, Pearson correlation, and OLS coefficients<br>机器学习中的相似性度量<br>动态时间归整 | DTW | Dynamic Time Warping</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/linux和操作系统/关于ssh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/linux和操作系统/关于ssh/" itemprop="url">关于ssh的知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ssh/" itemprop="url" rel="index">
                    <span itemprop="name">ssh</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="关于ssh的知识"><a href="#关于ssh的知识" class="headerlink" title="关于ssh的知识"></a>关于ssh的知识</h1><h2 id="配置ssh免秘钥登录"><a href="#配置ssh免秘钥登录" class="headerlink" title="配置ssh免秘钥登录"></a>配置ssh免秘钥登录</h2><ul>
<li>ssh -vvv ip-address<br>-vvv的意思是给出debug信息，信息会比较全。如果配置过程中出错了，可以看一下debug信息，看下具体哪里有问题。</li>
<li>ssh7之后默认不支持dsa加密<br>最好使用rsa加密。但是同样可以手动支持dsa，参见<a href="https://centrify.force.com/support/Article/KB-7050-How-to-Re-enable-DSA-keys-when-using-OpenSSH-7-0-and-above" target="_blank" rel="noopener">How to Re-enable DSA keys when using OpenSSH 7.0 and above</a>，在/etc/ssh/sshd_config和/etc/ssh/ssh_config文件中添加<code>PubkeyAcceptedKeyTypes=+ssh-dss</code>。实际测试发现:使用ssh7的服务端可以通过设置以上内容使得客户端可以免密码登录，但是服务端无法免密码登录客户端（即便客户端有服务端的dsa公钥）</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/linux和操作系统/softwareinstall/something/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/linux和操作系统/softwareinstall/something/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ubuntu14-04-中安装一些常用软件"><a href="#ubuntu14-04-中安装一些常用软件" class="headerlink" title="ubuntu14.04 中安装一些常用软件"></a>ubuntu14.04 中安装一些常用软件</h1><h2 id="安装vscode"><a href="#安装vscode" class="headerlink" title="安装vscode"></a>安装vscode</h2><p>参考：<a href="https://linux.cn/article-5423-1.html" target="_blank" rel="noopener">在Ubuntu中安装Visual Studio Code</a></p>
<p>主要命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装ubuntu-make</span></span><br><span class="line"><span class="comment"># 更新源</span></span><br><span class="line">sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ubuntu-make</span><br><span class="line"><span class="comment"># 安装vscode</span></span><br><span class="line">umake web visual-studio-code</span><br><span class="line"><span class="comment"># 卸载vscode</span></span><br><span class="line">umake web visual-studio-code --remove</span><br></pre></td></tr></table></figure></p>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>使用<code>sudo apt-get install git</code>安装的是系统的默认版本，我自己安装的时候默认是1.9.1，有点老。网上有个更新的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line"><span class="comment"># git version 1.9.1</span></span><br><span class="line"><span class="comment"># 可以使用下面命令升级git（如果不是root用户，需在命令前加sudo）：</span></span><br><span class="line">sudo add-apt-repository ppa:git-core/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sduo apt-get install git</span><br><span class="line"><span class="comment"># 安装完成后，再查看git版本：</span></span><br><span class="line">git --version</span><br><span class="line"><span class="comment"># git version 2.10.1</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/linux和操作系统/shellcmd/shellcommand随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/linux和操作系统/shellcmd/shellcommand随笔/" itemprop="url">shellcommand 随笔</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux系统/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux系统/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="shellcommand-随笔"><a href="#shellcommand-随笔" class="headerlink" title="shellcommand 随笔"></a>shellcommand 随笔</h1><ul>
<li>命令行中打开ubuntu的文件浏览器：<code>nautilus [path]</code></li>
<li>在多个文件中查找包含某关键字的行（显示文件名和行号）：<code>grep -rHn &quot;keyword&quot; files</code></li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/timg.jpg"
                alt="Kaiheng CHEN" />
            
              <p class="site-author-name" itemprop="name">Kaiheng CHEN</p>
              <p class="site-description motion-element" itemprop="description">道莅天下，其鬼不神</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chen-kh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhongfajean@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kaiheng CHEN</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>


  <span class="post-meta-divider">|</span>

<div class="powered-by">
<i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_pv">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
</div>

  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
