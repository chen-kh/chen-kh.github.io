<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="Java, Python, C, Go language">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="其鬼不神" type="application/atom+xml" />






<meta name="description" content="道莅天下，其鬼不神">
<meta name="keywords" content="分布式系统，数据结构与算法，操作系统与网络，编程语言与设计模式">
<meta property="og:type" content="website">
<meta property="og:title" content="其鬼不神">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="其鬼不神">
<meta property="og:description" content="道莅天下，其鬼不神">
<meta property="og:locale" content="Java, Python, C, Go language">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="其鬼不神">
<meta name="twitter:description" content="道莅天下，其鬼不神">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>其鬼不神</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="Java, Python, C, Go language">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">其鬼不神</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">ACT北航愣头青的博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/notebook/OSMandPostGISandMapMatcher/postgresql和postgis拓展/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/notebook/OSMandPostGISandMapMatcher/postgresql和postgis拓展/" itemprop="url">PostGIS 学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-12T14:40:38+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/postgres/" itemprop="url" rel="index">
                    <span itemprop="name">postgres</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="postgresql和postgis拓展"><a href="#postgresql和postgis拓展" class="headerlink" title="postgresql和postgis拓展"></a>postgresql和postgis拓展</h1><!-- TOC -->
<ul>
<li><a href="#1-postgresql安装">1. postgresql安装</a></li>
<li><a href="#2-postgresql使用">2. postgresql使用</a></li>
<li><a href="#3-postgis扩展安装">3. postgis扩展安装</a><ul>
<li><a href="#31-ubuntu-安装">3.1. ubuntu 安装</a></li>
<li><a href="#32-centos-7-安装">3.2. centos 7 安装</a></li>
<li><a href="#33-创建扩展">3.3. 创建扩展</a></li>
</ul>
</li>
<li><a href="#4-什么是-postgis">4. 什么是 PostGIS</a></li>
<li><a href="#5-如何安装-postgis">5. 如何安装 PostGIS</a></li>
<li><a href="#6-如何使用-postgis">6. 如何使用 PostGIS</a><ul>
<li><a href="#61-简单示例">6.1. 简单示例</a></li>
<li><a href="#62-postgis的geometry数据类型">6.2. PostGIS的Geometry数据类型</a></li>
<li><a href="#63-postgis函数的分类">6.3. PostGIS函数的分类</a><ul>
<li><a href="#631-字段处理函数">6.3.1. 字段处理函数</a></li>
<li><a href="#632-几何关系函数">6.3.2. 几何关系函数</a></li>
<li><a href="#633-几何分析函数">6.3.3. 几何分析函数</a></li>
<li><a href="#634-读写函数">6.3.4. 读写函数</a></li>
</ul>
</li>
<li><a href="#64-使用postgis扩展函数">6.4. 使用PostGIS扩展函数</a><ul>
<li><a href="#641-管理类函数">6.4.1. 管理类函数</a></li>
<li><a href="#642-数据类型的输入输出函数">6.4.2. 数据类型的输入输出函数</a></li>
<li><a href="#643-量算函数">6.4.3. 量算函数</a></li>
<li><a href="#644-几何操作函数">6.4.4. 几何操作函数</a></li>
<li><a href="#645-postgis函数使用示例">6.4.5. PostGIS函数使用示例</a></li>
</ul>
</li>
<li><a href="#65-建立postgis索引">6.5. 建立PostGIS索引</a></li>
</ul>
</li>
<li><a href="#7-参考资料">7. 参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-postgresql安装"><a href="#1-postgresql安装" class="headerlink" title="1. postgresql安装"></a>1. postgresql安装</h2><p>安装过程参见<a href="http://www.cnblogs.com/z-sm/archive/2016/07/05/5644165.html" target="_blank" rel="noopener">博客</a>,其中涉及到的主要问题： </p>
<ul>
<li>postgresql的版本选择问题</li>
<li>postgresql安装之后修改配置、添加用户、添加用户权限更改等等问题</li>
</ul>
<h2 id="2-postgresql使用"><a href="#2-postgresql使用" class="headerlink" title="2. postgresql使用"></a>2. postgresql使用</h2><h2 id="3-postgis扩展安装"><a href="#3-postgis扩展安装" class="headerlink" title="3. postgis扩展安装"></a>3. postgis扩展安装</h2><h3 id="3-1-ubuntu-安装"><a href="#3-1-ubuntu-安装" class="headerlink" title="3.1. ubuntu 安装"></a>3.1. ubuntu 安装</h3><p>参考：<a href="https://www.howtoing.com/how-to-install-and-configure-postgis-on-ubuntu-14-04" target="_blank" rel="noopener">博客</a>  </p>
<p><strong>注意</strong>：很多博客中的安装过程只需要 <code>apt-get install postgis</code>，实际测试发现 <code>apt-get install postgis*</code> 最好。第一种安装方式可能没有postgis-scripts，导致在数据库中<code>create extension</code>执行时出现<em>[ERROR: could not open extension control file “/usr/share/postgresql/9.3/extension/ postgis.control”: No such file or directory]</em>的错误。  </p>
<h3 id="3-2-centos-7-安装"><a href="#3-2-centos-7-安装" class="headerlink" title="3.2. centos 7 安装"></a>3.2. centos 7 安装</h3><p>参考博客：<a href="https://my.oschina.net/freegis/blog/781657" target="_blank" rel="noopener">CentOS 7 源码安装PostGIS</a>：文章写得算是很不错了，只是需要注意一下postgres这个目录，有的时候指的是你自己的postgres的安装目录。</p>
<h3 id="3-3-创建扩展"><a href="#3-3-创建扩展" class="headerlink" title="3.3. 创建扩展"></a>3.3. 创建扩展</h3><p>创建扩展：postgis安装后在使用时，需要在使用的数据库中添加拓展，在相应数据库执行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> extension postgis</span><br></pre></td></tr></table></figure></p>
<p>出现<code>CREAT EXTENSION</code>表示安装成功，可使用一下命令查看版本。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> PostGIS_version()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>具体使用见<a href="https://www.howtoing.com/how-to-install-and-configure-postgis-on-ubuntu-14-04" target="_blank" rel="noopener">博客</a></li>
</ul>
<h2 id="4-什么是-PostGIS"><a href="#4-什么是-PostGIS" class="headerlink" title="4. 什么是 PostGIS"></a>4. 什么是 PostGIS</h2><p>参考：<a href="https://postgis.net/" target="_blank" rel="noopener">PostGIS官网</a><br><strong>Wiki定义</strong>：<br>PostGIS 是一个开源程序，它为对象－关系型数据库PostgreSQL提供了存储空间地理数据的支持，使PostgreSQL成为了一个空间数据库，能够进行空间数据管理、数量测量与几何拓扑分析。PostGIS 实现了Open Geospatial Consortium所提出的基本要素类（点、线、面、多点、多线、多面等）的SQL实现参考。</p>
<h2 id="5-如何安装-PostGIS"><a href="#5-如何安装-PostGIS" class="headerlink" title="5. 如何安装 PostGIS"></a>5. 如何安装 PostGIS</h2><p>安装针对Ubuntu系统，参见文档 <a href="postgresql安装和postgis拓展安装.md">Postgresql安装和postgis拓展安装</a></p>
<h2 id="6-如何使用-PostGIS"><a href="#6-如何使用-PostGIS" class="headerlink" title="6. 如何使用 PostGIS"></a>6. 如何使用 PostGIS</h2><h3 id="6-1-简单示例"><a href="#6-1-简单示例" class="headerlink" title="6.1. 简单示例"></a>6.1. 简单示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> demo <span class="keyword">TEMPLATE</span>=template_postgis;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities ( <span class="keyword">id</span> int4, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>) );</span><br><span class="line"><span class="keyword">select</span> AddGeometryColumn(<span class="string">'cities'</span>,<span class="string">'the_geom'</span>,<span class="number">-1</span>,<span class="string">'GEOMETRY'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* SELECT * from cities; */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (<span class="keyword">id</span>, the_geom, <span class="keyword">name</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>,ST_GeomFromText(<span class="string">'POINT(-0.1257 51.508)'</span>,<span class="number">4326</span>),<span class="string">'London, England'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (<span class="keyword">id</span>, the_geom, <span class="keyword">name</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>,ST_GeomFromText(<span class="string">'POINT(-81.233 42.983)'</span>,<span class="number">4326</span>),<span class="string">'London, Ontario'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (<span class="keyword">id</span>, the_geom, <span class="keyword">name</span>) <span class="keyword">VALUES</span> (<span class="number">3</span>,ST_GeomFromText(<span class="string">'POINT(27.91162491 -33.01529)'</span>,<span class="number">4326</span>),<span class="string">'East London,SA'</span>);</span><br><span class="line"><span class="comment">/* 简单查询 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cities;</span><br></pre></td></tr></table></figure>
<p>结果显示为下表:</p>
<pre><code>id |      name       |                      the_geom
----+-----------------+----------------------------------------------------
1 | London, England | 0101000020E6100000BBB88D06F016C0BF1B2FDD2406C14940
2 | London, Ontario | 0101000020E6100000F4FDD478E94E54C0E7FBA9F1D27D4540
3 | East London,SA  | 0101000020E610000040AB064060E93B4059FAD005F58140C0
(3 rows)
</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, ST_AsText(the_geom), ST_AsEwkt(the_geom), ST_X(the_geom), ST_Y(the_geom) <span class="keyword">FROM</span> cities;</span><br></pre></td></tr></table></figure>
<p>结果显示为下表:</p>
<pre><code>id |          st_astext           |               st_asewkt                |    st_x     |   st_y
----+------------------------------+----------------------------------------+-------------+-----------
1 | POINT(-0.1257 51.508)        | SRID=4326;POINT(-0.1257 51.508)        |     -0.1257 |    51.508
2 | POINT(-81.233 42.983)        | SRID=4326;POINT(-81.233 42.983)        |     -81.233 |    42.983
3 | POINT(27.91162491 -33.01529) | SRID=4326;POINT(27.91162491 -33.01529) | 27.91162491 | -33.01529
</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*空间查询*/</span></span><br><span class="line"><span class="keyword">SELECT</span> p1.name,p2.name,ST_Distance_Sphere(p1.the_geom,p2.the_geom) <span class="keyword">FROM</span> cities <span class="keyword">AS</span> p1, cities <span class="keyword">AS</span> p2 <span class="keyword">WHERE</span> p1.id &gt; p2.id;</span><br></pre></td></tr></table></figure>
<pre><code>    name       |      name       | st_distance_sphere
-----------------+-----------------+--------------------
London, Ontario | London, England |   5875766.85191657
East London,SA  | London, England |   9789646.96784908
East London,SA  | London, Ontario |   13892160.9525778
(3 rows)
</code></pre><h3 id="6-2-PostGIS的Geometry数据类型"><a href="#6-2-PostGIS的Geometry数据类型" class="headerlink" title="6.2. PostGIS的Geometry数据类型"></a>6.2. PostGIS的Geometry数据类型</h3><p>Geometry可以说是PostGIS最重要的一个概念，是“几何体”的意思，由于PostGIS很好地遵守OGC的”Simple Feature for Specification for SQL”规范，目前支持的几何体类型包含其实例有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POINT(1 1)</span><br><span class="line">MULTIPOINT(1 1, 3 4, -1 3)</span><br><span class="line">LINESTRING(1 1, 2 2, 3 4)</span><br><span class="line">POLYGON((0 0, 0 1, 1 1, 1 0, 0 0))</span><br><span class="line">MULTIPOLYGON((0 0, 0 1, 1 1, 1 0, 0 0), (5 5, 5 6, 6 6, 6 5, 5 5))</span><br><span class="line">MULTILINESTRING((1 1, 2 2, 3 4),(2 2, 3 3, 4 5))</span><br></pre></td></tr></table></figure></p>
<p>而geometry具体表现又有两种形式，一种叫做WKT(Well Known Text)形式，如上面的例子。或者使用如下SQL语句浏览：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> AsText(pt) <span class="keyword">from</span> test1;</span><br><span class="line"><span class="keyword">select</span> AddGeometryColumn(<span class="string">'test1'</span>,<span class="string">'pt'</span>,<span class="number">-1</span>,<span class="string">'GEOMETRY'</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>另一种叫做“Canonical Form”形式，看上去是一串古怪的数字，其实是一种增强的十六进制编码，使用如下SQL语句就可以浏览了：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pt <span class="keyword">from</span> test1;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-3-PostGIS函数的分类"><a href="#6-3-PostGIS函数的分类" class="headerlink" title="6.3. PostGIS函数的分类"></a>6.3. PostGIS函数的分类</h3><p>PostGIS函数大致可以分为以下四类:</p>
<h4 id="6-3-1-字段处理函数"><a href="#6-3-1-字段处理函数" class="headerlink" title="6.3.1. 字段处理函数"></a>6.3.1. 字段处理函数</h4><p>这类函数当前一共有3个，分别是：</p>
<ul>
<li><p><code>AddGeometryColumn(var1,var2,var3,var4,var5,var6)</code>：<br>为已有的数据表增加一个地理几何数据字段。Var1代表数据表的模式(schema)的名字，一般是public，也可以省略，则使用当前的缺省模式；var2是已有的数据表的名字；var3是新的地理数据字段的名字；var4是SRID值，不确定的话就取-1吧；var5是地理数据的类型，可以是POINT等；var6是指该几何数据是二维还是三维数据。<br>前面的SQL语句<code>create table test1 (myID int4, pt geometry, myName varchar)</code>更规范的写法为：</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1 (myID int4, myName <span class="built_in">varchar</span> );</span><br><span class="line"><span class="keyword">select</span> AddGeometryColumn(<span class="string">'test1'</span>,<span class="string">'pt'</span>,<span class="number">-1</span>,<span class="string">'GEOMETRY'</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DropGeometryColumn</code> 函数：<br>显然是删除一个地理数据字段的；</p>
</li>
<li><code>SetSRID</code> 函数：<br>显然是设置SRID值的。<h4 id="6-3-2-几何关系函数"><a href="#6-3-2-几何关系函数" class="headerlink" title="6.3.2. 几何关系函数"></a>6.3.2. 几何关系函数</h4>这类函数目前共有10个，分别是：<br><code>Distance Equals Disjoint Intersects Touches Crosses Within Overlaps Contains Relate</code><h4 id="6-3-3-几何分析函数"><a href="#6-3-3-几何分析函数" class="headerlink" title="6.3.3. 几何分析函数"></a>6.3.3. 几何分析函数</h4>这类函数目前共有12个，分别是：<br><code>Centroid Area Lenth PointOnSurface Boundary Buffer ConvexHull Intersection SymDifference Difference GeomUnion MemGeomUnion</code><h4 id="6-3-4-读写函数"><a href="#6-3-4-读写函数" class="headerlink" title="6.3.4. 读写函数"></a>6.3.4. 读写函数</h4>这类函数很多，主要是用于在各种数据类型之间的转换，尤其是在于Geometry数据类型与其他如字符型等数据类型之间的转换，函数名如<code>AsText、GeomFromText</code>等，其作用是显然的。<h3 id="6-4-使用PostGIS扩展函数"><a href="#6-4-使用PostGIS扩展函数" class="headerlink" title="6.4. 使用PostGIS扩展函数"></a>6.4. 使用PostGIS扩展函数</h3>除了上述遵循OpenGIS的函数之外，PostGIS还自行扩展了一些当前OpenGIS规范之外的函数，主要包括以下几类：<h4 id="6-4-1-管理类函数"><a href="#6-4-1-管理类函数" class="headerlink" title="6.4.1. 管理类函数"></a>6.4.1. 管理类函数</h4>扩展的管理类函数主要包括一些软件版本查询函数，如postgis_version()、postgis_geos_version()、postgis_proj_version()函数等，分别查询当前的PostGIS的版本及其使用的Geos和Proj库的版本。<h4 id="6-4-2-数据类型的输入输出函数"><a href="#6-4-2-数据类型的输入输出函数" class="headerlink" title="6.4.2. 数据类型的输入输出函数"></a>6.4.2. 数据类型的输入输出函数</h4>除了OpenGIS定义的地理数据类型之外，PostGIS还对数据类型进行了扩展，这种扩展主要是两方面的扩展，一是把二维的数据向三维和四维扩展；二就是在WKT和WKB数据类型基础上扩展出EWKT和EWKB数据类型。PostGIS提供了在这些地理数据类型和常用数据类型如字符型、浮点型数据之间进行转换的函数。<h4 id="6-4-3-量算函数"><a href="#6-4-3-量算函数" class="headerlink" title="6.4.3. 量算函数"></a>6.4.3. 量算函数</h4>如length3d函数是对length2d函数的扩展。<h4 id="6-4-4-几何操作函数"><a href="#6-4-4-几何操作函数" class="headerlink" title="6.4.4. 几何操作函数"></a>6.4.4. 几何操作函数</h4>如addBBox(geometry)函数给所给的几何体加上一个边框。如simplify(geometry,tolerance)函数可以对折线和多边形利用Douglas-Peuker算法进行一些节点进行删除，从而使表现的图形更简单而清晰，在网络传输数据时具有更高的效率。<h4 id="6-4-5-PostGIS函数使用示例"><a href="#6-4-5-PostGIS函数使用示例" class="headerlink" title="6.4.5. PostGIS函数使用示例"></a>6.4.5. PostGIS函数使用示例</h4></li>
<li><p>integer ST_NPoints(geometry g1); 返回geometry中包含多少个point</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ST_NPoints(ST_GeomFromText(<span class="string">'LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)'</span>));</span><br><span class="line"><span class="comment">--result: 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>geometry ST_PointN(geometry a_linestring, integer n); 返回linestring中的第n个point</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ST_AsText(ST_PointN(ST_GeomFromText(<span class="string">'CIRCULARSTRING(1 2, 3 2, 1 2)'</span>),<span class="number">2</span>));</span><br><span class="line"><span class="comment">--result:POINT(3 2)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-5-建立PostGIS索引"><a href="#6-5-建立PostGIS索引" class="headerlink" title="6.5. 建立PostGIS索引"></a>6.5. 建立PostGIS索引</h3><p>当数据库的记录增大的时候，如果没有建立索引的话，操作的效率就显著下降。POstGIS建议当记录数超过几千的时候就应该建立索引，而GIS数据库一般都是海量数据，所以对PostGIS而言，索引就非常重要。 </p>
<h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><p>[1] <a href="https://zh.wikipedia.org/wiki/PostGIS" target="_blank" rel="noopener">PostGIS维基百科介绍</a><br>[2] <a href="https://live.osgeo.org/zh/quickstart/postgis_quickstart.html" target="_blank" rel="noopener">PostGIS快速入门</a><br>[3] <a href="http://blog.csdn.net/shixiaoguo90/article/details/30034429" target="_blank" rel="noopener">PostGIS简介</a><br>[4] <a href="http://www.cnblogs.com/LCGIS/archive/2013/03/08/2949119.html" target="_blank" rel="noopener">PostGIS管理函数</a></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/notebook/OSMandPostGISandMapMatcher/OSM 介绍与使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/notebook/OSMandPostGISandMapMatcher/OSM 介绍与使用/" itemprop="url">OSM 介绍与使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-12T14:33:09+08:00">
                2018-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/OSM/" itemprop="url" rel="index">
                    <span itemprop="name">OSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="OSM-介绍与使用"><a href="#OSM-介绍与使用" class="headerlink" title="OSM 介绍与使用"></a>OSM 介绍与使用</h1><!-- TOC -->
<ul>
<li><a href="#什么是osm">什么是OSM?</a></li>
<li><a href="#获取地图数据">获取地图数据</a></li>
<li><a href="#osm数据导入">osm数据导入</a><ul>
<li><a href="#centos-7-osm2pgsql安装">centos 7: osm2pgsql安装</a></li>
<li><a href="#ubuntu-osm2pgsql安装">ubuntu: osm2pgsql安装</a></li>
<li><a href="#导入地图数据">导入地图数据</a></li>
</ul>
</li>
<li><a href="#基于osm的开源导航服务">基于OSM的开源导航服务</a><ul>
<li><a href="#osrm安装">OSRM安装</a></li>
<li><a href="#导航api重要参数记录">导航API重要参数记录</a></li>
</ul>
</li>
<li><a href="#参考资料">参考资料</a></li>
</ul>
<!-- /TOC -->
<h2 id="什么是OSM"><a href="#什么是OSM" class="headerlink" title="什么是OSM?"></a>什么是OSM?</h2><p>开放街道地图（OpenStreetMap，简称OSM）是一个网上地图协作计划，目标是创造一个内容自由且能让所有人编辑的世界地图[wiki：<a href="http://wiki.openstreetmap.org/wiki/Main_Page].尤其值得称道的是，osm数据开源，可以自由下载使用。" target="_blank" rel="noopener">http://wiki.openstreetmap.org/wiki/Main_Page].尤其值得称道的是，osm数据开源，可以自由下载使用。</a></p>
<h2 id="获取地图数据"><a href="#获取地图数据" class="headerlink" title="获取地图数据"></a>获取地图数据</h2><p>获取地图数据主要分两种情况，获取大范围数据还是小范围数据。</p>
<p><strong>小范围数据的获取</strong>比较简单，基本<code>进入官网-&gt;点击导出-&gt;手动选择不同的区域-&gt;在地图选定导出范围-&gt;点击导出</code>就出来了。其实就是做了一个url请求，也可以根据在url中直接填写经纬度。</p>
<p><img src="export_osm_smallrange.png" alt="export osm data for small range"></p>
<p><strong>大范围数据的获取</strong> 有多种方式，主要参考上图中的篮框中的内容，这里不多记录，如果在地图中框选范围太大，导出失败，可以直接点击Overpass API的连接，就能够导出数据来了，数据格式可以定义为xml文件。另外，知乎上有个介绍写的很好，参考<a href="https://zhuanlan.zhihu.com/p/25889246" target="_blank" rel="noopener">获取OpenStreetMap（OSM）数据方法知多少？</a>，主要参考其中的第一种方法。</p>
<h2 id="osm数据导入"><a href="#osm数据导入" class="headerlink" title="osm数据导入"></a>osm数据导入</h2><h3 id="centos-7-osm2pgsql安装"><a href="#centos-7-osm2pgsql安装" class="headerlink" title="centos 7: osm2pgsql安装"></a>centos 7: osm2pgsql安装</h3><p>这个简直太神奇了，参照博客：<a href="http://www.cnblogs.com/think8848/p/6011073.html" target="_blank" rel="noopener">centos 7 osm2pgsql安装</a>。基本内容/过程没有问题，只是我安装过程中出现了这么几个问题。</p>
<ul>
<li>boost-devel版本太低</li>
<li>gcc版本太低</li>
<li>gcc多个版本存在选择最低的版本</li>
<li><code>make install</code>成功后运行<code>osm2pgsql -version</code>出现GLIBCXX问题</li>
</ul>
<p><strong>解决办法</strong>  </p>
<ol>
<li><p>升级boost-devel： </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要是由于更新源的问题，有些源跟踪不到</span></span><br><span class="line"><span class="comment"># 大部分网址的推荐方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我这里可以用的方法</span></span><br><span class="line">sudo wget https://bintray.com/vicendominguez/CentOS6/rpm -O etc/yum.repos.d/bintray-vicendominguez-CentOS6.repo</span><br><span class="line">sudo yum install boost-devel</span><br></pre></td></tr></table></figure>
</li>
<li><p>gcc升级版本（4.4.7 -&gt; 4.8.1）<br>centos 7最烦我的就是安装什么东西都需要源码安装，好烦的说。安装过程如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取源码</span></span><br><span class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-4.8.1/gcc-4.8.1.tar.gz</span><br><span class="line">tar -xvzf gcc-4.8.1.tar.gz -C /opt/gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载prerequisites时，如果连接不上服务地址</span></span><br><span class="line"><span class="comment"># 就去看一下这个文件的内容（下载，解压，建立连接，删除）</span></span><br><span class="line"><span class="comment"># 用别的方式下载一下。然后更改这个文件的内容。</span></span><br><span class="line"><span class="built_in">cd</span> /opt/gcc/gcc-4.8.1 </span><br><span class="line">./contrib/download_prerequisites  </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..  </span><br><span class="line">mkdir build_gcc_4.8.1 </span><br><span class="line"><span class="built_in">cd</span> build_gcc_4.8.1  </span><br><span class="line">../gcc-4.8.1/configure --<span class="built_in">enable</span>-checking=release --<span class="built_in">enable</span>-languages=c,c++ --<span class="built_in">disable</span>-multilib    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译时间很长</span></span><br><span class="line">make -j4  </span><br><span class="line">make install  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级版本</span></span><br><span class="line">/usr/sbin/update-alternatives --install  /usr/bin/gcc gcc /usr/<span class="built_in">local</span>/bin/x86_64-unknown-linux-gnu-gcc-4.8.1 40    </span><br><span class="line">/usr/sbin/update-alternatives --install /usr/bin/g++ g++ /usr/<span class="built_in">local</span>/bin/g++ 40</span><br></pre></td></tr></table></figure>
</li>
<li><p>改掉旧版本的链接文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为系统默认使用低版本的gcc，如果同时存在多个版本也会出问题，所以进行下面操作。</span></span><br><span class="line">mv /usr/bin/gcc /usr/bin/gcc4.4.7</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/gcc /usr/bin/gcc</span><br><span class="line">mv /usr/bin/g++ /usr/bin/g++4.4.7</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/g++ /usr/bin/g++</span><br><span class="line">mv /usr/bin/cc /usr/bin/cc4.4.7</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/cc /usr/bin/cc</span><br><span class="line">mv /usr/bin/c++ /usr/bin/c++4.4.7</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/c++ /usr/bin/c++</span><br></pre></td></tr></table></figure>
</li>
<li><p>对文件进行补充</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /usr/lib64/libstdc++.so.6|grep GLIBCXX</span><br></pre></td></tr></table></figure>
<pre><code>GLIBCXX_3.4
GLIBCXX_3.4.1
GLIBCXX_3.4.2
GLIBCXX_3.4.3
GLIBCXX_3.4.4
GLIBCXX_3.4.5
GLIBCXX_3.4.6  
GLIBCXX_3.4.7
GLIBCXX_3.4.8
GLIBCXX_3.4.9
GLIBCXX_3.4.10
GLIBCXX_3.4.11
GLIBCXX_3.4.12
GLIBCXX_3.4.13
GLIBCXX_FORCE_NEW
GLIBCXX_DEBUG_MESSAGE_LENGTH
</code></pre></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 到编译时的目录下面找到文件：libstdc++.so.6.0.18</span></span><br><span class="line"><span class="comment"># 我编译的时候，建立build_gcc_4.8.1文件夹，具体方法参见：centos升级gcc到4.8.1</span></span><br><span class="line"><span class="comment"># 注意，进入目录是，.libs是隐藏的：</span></span><br><span class="line"><span class="comment"># /home/build_gcc_4.8.1/x86_64-unknown-linux-gnu/libstdc++-v3/src/.libs</span></span><br><span class="line"><span class="comment"># 用下面的命令查看：</span></span><br><span class="line">strings libstdc++.so.6.0.18|grep GLIBCXX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般来讲，里面就有满足需要的GLIBCXX版本了。</span></span><br><span class="line"><span class="comment"># 然后，把该文件拷贝到了/usr/lib64下.</span></span><br><span class="line"><span class="comment"># 然后将libstdc++.so.6指向libstdc++.so.6.0.18:</span></span><br><span class="line">rm -r libstdc++.so.6</span><br><span class="line">ln -s libstdc++.so.6.0.18 libstdc++.so.6</span><br></pre></td></tr></table></figure>
<p>参考资料：</p>
<ul>
<li><a href="https://github.com/qiwsir/ITArticles/blob/master/Linux/How_to_solve_GLIBCXX_3.4.19.md" target="_blank" rel="noopener">How_to_solve_GLIBCXX_3.4.19</a></li>
<li><a href="https://blog.csdn.net/clirus/article/details/62424517" target="_blank" rel="noopener">CentOS gcc升级4.8步骤</a></li>
<li><a href="https://www.bbsmax.com/A/GBJrlMBd0e/" target="_blank" rel="noopener">CentOS7部署osm2pgsql</a></li>
</ul>
<h3 id="ubuntu-osm2pgsql安装"><a href="#ubuntu-osm2pgsql安装" class="headerlink" title="ubuntu: osm2pgsql安装"></a>ubuntu: osm2pgsql安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu版本安装就很简单了，一条命令</span></span><br><span class="line">apt-get intall osm2pgsql</span><br></pre></td></tr></table></figure>
<h3 id="导入地图数据"><a href="#导入地图数据" class="headerlink" title="导入地图数据"></a>导入地图数据</h3><p>地图数据导入pg数据库，使用osm2pgsql导入，命令类似于<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果出现ident authentication <span class="keyword">for</span> user postgres问题的话，su - postgres切换用户</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是需要注意postgres读取文件权限问题，把owner和group都改成postgres就好了。</span></span><br><span class="line">osm2pgsql -s -U postgres -d osm /tmp/map.xml -H 192.168.6.133 -W</span><br></pre></td></tr></table></figure></p>
<p><strong>注</strong>：osm2pgsql导入数据有两种模式， normal and slim mode。</p>
<ul>
<li><p>normal mode会在内存中产生如下三张中间表，并在导入结束后丢弃，因此速度较快。<br>planet_osm_nodes<br>planet_osm_ways<br>planet_osm_rels</p>
</li>
<li><p>而slim mode则将中间结果完全放置到数据库中。slim模式的好处是方便更新。</p>
</li>
</ul>
<p>两者使用的区别在于是否加“-s”，加了表示slim mode，本文使用slim mode。<br>使用slim mode导入数据后在数据库中会产生如下表。</p>
<p><img src="osm_table_imported.png" alt="osm数据导入后的表"></p>
<ul>
<li><p>三张临时表：planet_osm_nodes, planet_osm_ways, planet_osm_rels<br>需要注意的是nodes表中的lat和lon是bigint类型的数据，它们并不是经纬度的多少倍或是什么样子，而是一种表示方式（你可以认为是一种编码方式）。从bigint类型转换到经纬度编码的过程，在进行osm2pgsql的时候其实已经做了，只不过数据改存到了point表里面的way值中，这是一种geometry数据类型，更方便使用。这也是这张临时表没什么用的原因。</p>
</li>
<li><p>planet_osm_point<br>将原始geometry数据展示成4326（也就是wgs84标准）格式的经纬度的代码类似于：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ST_AsText(ST_Transform(way, <span class="number">4326</span>)) <span class="keyword">from</span> planet_osm_point <span class="keyword">where</span> osm_id = <span class="number">1422005356</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="基于OSM的开源导航服务"><a href="#基于OSM的开源导航服务" class="headerlink" title="基于OSM的开源导航服务"></a>基于OSM的开源导航服务</h2><p>基于OSM的开源导航服务有OSRM和GraphHopper。这里重点记录OSRM，项目放在了github上，叫做<a href="https://github.com/Project-OSRM/osrm-backend" target="_blank" rel="noopener">Open Source Routing Machine</a>。</p>
<p>官网地址：<a href="http://project-osrm.org/" target="_blank" rel="noopener">http://project-osrm.org/</a><br>API文档说明地址：<a href="http://project-osrm.org/docs/v5.10.0/api/#general-options" target="_blank" rel="noopener">http://project-osrm.org/docs/v5.10.0/api/#general-options</a></p>
<h3 id="OSRM安装"><a href="#OSRM安装" class="headerlink" title="OSRM安装"></a>OSRM安装</h3><p>参见github项目的<a href="https://github.com/Project-OSRM/osrm-backend" target="_blank" rel="noopener"><strong>README</strong></a>和<a href="https://my.oschina.net/u/1266171/blog/918232" target="_blank" rel="noopener">OSRM笔记</a>（博客），都写的很详细，后者基本是前者的翻译。</p>
<p>涉及的主要过程记录在下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install docker</span></span><br><span class="line"><span class="comment"># daocloud.io 国内镜像</span></span><br><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br><span class="line"><span class="comment"># Download OpenStreetMap extracts for example from Geofabrik</span></span><br><span class="line">wget http://download.geofabrik.de/europe/germany/berlin-latest.osm.pbf</span><br><span class="line"><span class="comment"># Pre-process the extract with the car profile and start a routing engine HTTP server on port 5000</span></span><br><span class="line">docker run -t -v $(<span class="built_in">pwd</span>):/data osrm/osrm-backend osrm-extract -p /opt/car.lua /data/berlin-latest.osm.pbf</span><br><span class="line">docker run -t -v $(<span class="built_in">pwd</span>):/data osrm/osrm-backend osrm-partition /data/berlin-latest.osrm</span><br><span class="line">docker run -t -v $(<span class="built_in">pwd</span>):/data osrm/osrm-backend osrm-customize /data/berlin-latest.osrm</span><br><span class="line"></span><br><span class="line">docker run -t -i -p 5000:5000 -v $(<span class="built_in">pwd</span>):/data osrm/osrm-backend osrm-routed --algorithm mld /data/berlin-latest.osrm</span><br><span class="line"><span class="comment"># Make requests against the HTTP server</span></span><br><span class="line">curl <span class="string">"http://127.0.0.1:5000/route/v1/driving/13.388860,52.517037;13.385983,52.496891?steps=true"</span></span><br><span class="line"><span class="comment"># Optionally start a user-friendly frontend on port 9966, and open it up in your browser</span></span><br><span class="line">docker run -p 9966:9966 osrm/osrm-frontend</span><br><span class="line">xdg-open <span class="string">'http://127.0.0.1:9966'</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>几点说明</li>
</ul>
<ol>
<li><strong>customize过程</strong>比较费时，也比较占用计算资源。在10.1.1.58上运行china-latest时，这一步可以把32个cpu都用上，并且至少花费10分钟才能算完。</li>
<li><p><strong>遗留的问题</strong>：9966端口的页面可以展示，但是无法真正使用。</p>
<p> 不正常工作</p>
<p> <img src="osrm_route_exception.png" alt="route_exception"></p>
<p> 正常工作</p>
<p> <img src="osrm_route_workwell.png" alt="route_workwell"></p>
</li>
</ol>
<h3 id="导航API重要参数记录"><a href="#导航API重要参数记录" class="headerlink" title="导航API重要参数记录"></a>导航API重要参数记录</h3><p><a href="http://project-osrm.org/docs/v5.10.0/api/#general-options" target="_blank" rel="noopener">API文档</a>中的说明很详细，仔细读一遍就知道各个字段是什么意思了。</p>
<ul>
<li><p>RouteLeg对象中的annotations属性</p>
<p>  distance和duration单位分别为米和秒，speed单位米/秒，由distance/duration计算得到。nodes就是osm_node表中的id（也是osm_line表中的osm_id）</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"distance"</span>: <span class="number">30.0</span>,</span><br><span class="line">  <span class="attr">"duration"</span>: <span class="number">100.0</span>,</span><br><span class="line">  <span class="attr">"weight"</span>: <span class="number">100.0</span>,</span><br><span class="line">  <span class="attr">"steps"</span>: [],</span><br><span class="line">  <span class="attr">"annotation"</span>: &#123;</span><br><span class="line">    <span class="attr">"distance"</span>: [<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">5</span>],</span><br><span class="line">    <span class="attr">"duration"</span>: [<span class="number">15</span>,<span class="number">15</span>,<span class="number">40</span>,<span class="number">15</span>,<span class="number">15</span>],</span><br><span class="line">    <span class="attr">"datasources"</span>: [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    <span class="attr">"nodes"</span>: [<span class="number">49772551</span>,<span class="number">49772552</span>,<span class="number">49786799</span>,<span class="number">49786800</span>,<span class="number">49786801</span>,<span class="number">49786802</span>],</span><br><span class="line">    <span class="attr">"speed"</span>: [<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://www.cnblogs.com/LBSer/p/4451471.html" target="_blank" rel="noopener">OSM入门+搭建地图服务</a>, 讲的很详细，值得参考一看</li>
<li><a href="https://gis.stackexchange.com/questions/163173/how-do-i-convert-the-coordinate-data-from-osm-into-actual-longitude-latitude-poi" target="_blank" rel="noopener">How do I convert the coordinate data from osm into actual longitude latitude points</a></li>
<li><a href="https://gis.stackexchange.com/questions/57003/what-format-is-lat-long-stored-in-osm-postgis" target="_blank" rel="noopener">What format is lat/long stored in OSM PostGIS?</a></li>
<li><a href="http://www.cnblogs.com/Micang/p/6346446.html" target="_blank" rel="noopener">OpenStreetMap、googleMap等经纬度和行列号之间相互转化</a></li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/07/notebook/offer/leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/07/notebook/offer/leetcode/" itemprop="url">leetcode 题目与总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-07T20:54:24+08:00">
                2018-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/offer/" itemprop="url" rel="index">
                    <span itemprop="name">offer</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/offer/leetcode/" itemprop="url" rel="index">
                    <span itemprop="name">leetcode</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="leetcode-题目与总结"><a href="#leetcode-题目与总结" class="headerlink" title="leetcode 题目与总结"></a>leetcode 题目与总结<!-- TOC --></h1><ul>
<li><a href="#1-二叉树">1. 二叉树</a><ul>
<li><a href="#11-前序遍历递归非递归">1.1. 前序遍历（递归、非递归）</a></li>
<li><a href="#12-中序遍历递归非递归">1.2. 中序遍历（递归、非递归）</a></li>
<li><a href="#13-后序遍历递归非递归">1.3. 后序遍历（递归、非递归）</a></li>
<li><a href="#14-层次遍历与层次输出">1.4. 层次遍历与层次输出</a></li>
<li><a href="#15-树的深度略">1.5. 树的深度（略）</a></li>
<li><a href="#16-对称树">1.6. 对称树</a></li>
<li><a href="#17-路径和略">1.7. 路径和（略）</a></li>
<li><a href="#18-中序遍历加后序遍历恢复原树结构">1.8. 中序遍历加后序遍历恢复原树结构</a></li>
<li><a href="#19-使用链表连接每一层">1.9. 使用链表连接每一层</a></li>
<li><a href="#110-给定一棵树和一个节点输出从根节点到这个节点的路径">1.10. 给定一棵树和一个节点，输出从根节点到这个节点的路径</a></li>
<li><a href="#111-两个节点的最小公共祖先">1.11. 两个节点的最小公共祖先</a></li>
<li><a href="#112-树的序列化和反序列化">1.12. 树的序列化和反序列化</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h2><h3 id="1-1-前序遍历（递归、非递归）"><a href="#1-1-前序遍历（递归、非递归）" class="headerlink" title="1.1. 前序遍历（递归、非递归）"></a>1.1. 前序遍历（递归、非递归）</h3><p>递归版本是最基本的了。非递归的版本需要使用stack来保存访问的路径。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        <span class="comment">// preorderTraversalIter(root,list);</span></span><br><span class="line">        <span class="comment">// method 2</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop().right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversalIter</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            preorderTraversalIter(root.left, list);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            preorderTraversalIter(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-中序遍历（递归、非递归）"><a href="#1-2-中序遍历（递归、非递归）" class="headerlink" title="1.2. 中序遍历（递归、非递归）"></a>1.2. 中序遍历（递归、非递归）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        <span class="comment">// inorderTraversalIter(root,list);</span></span><br><span class="line">        <span class="comment">// method 2</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderTraversalIter</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                inorderTraversalIter(root.left, list);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                inorderTraversalIter(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-后序遍历（递归、非递归）"><a href="#1-3-后序遍历（递归、非递归）" class="headerlink" title="1.3. 后序遍历（递归、非递归）"></a>1.3. 后序遍历（递归、非递归）</h3><p>后序遍历其实是镜像+颠倒版的前序遍历。使用右先前序遍历（先访问右节点）思想，最后倒着输出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        <span class="comment">// postorderTraversalIter(root,list);</span></span><br><span class="line">        <span class="comment">// method 2</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                list.add(<span class="number">0</span>, root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderTraversalIter</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                postorderTraversalIter(root.left, list);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                postorderTraversalIter(root.right, list);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-层次遍历与层次输出"><a href="#1-4-层次遍历与层次输出" class="headerlink" title="1.4. 层次遍历与层次输出"></a>1.4. 层次遍历与层次输出</h3><p>层次遍历很简单，使用队列辅助就行了。但是如何进行层次输出呢？这就是102号题目：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a>。思路如下。</p>
<p>思路1：递归。设置level记录层数。每进行一次子节点访问，层数加1。不同层用不同list存储。具体见代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, levelList, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> levelList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;List&lt;Integer&gt;&gt; levelList, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (levelList.size() &lt;= level) &#123;</span><br><span class="line">            levelList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        levelList.get(level).add(node.val);</span><br><span class="line">        helper(node.left, levelList, level+<span class="number">1</span>);</span><br><span class="line">        helper(node.right, levelList, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>思路2：迭代。记录上下两层的数量。使用队列进行存储，但是记录前一层和当前层分别有多少个节点被存储了。当前一层还剩下0个节点的时候，存储成新的list。详见代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> preCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curCount=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            preCount++;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                preCount--;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    curCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    curCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(preCount == <span class="number">0</span>)&#123;</span><br><span class="line">                    lists.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">                    list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    preCount = curCount;</span><br><span class="line">                    curCount = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>思路3：迭代。双队列，第一个队列存储已经访问过的上一层的节点值，第二个队列存储当前访问层的节点值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Queue&lt;TreeNode&gt; temp=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            queue=temp;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-5-树的深度（略）"><a href="#1-5-树的深度（略）" class="headerlink" title="1.5. 树的深度（略）"></a>1.5. 树的深度（略）</h3><h3 id="1-6-对称树"><a href="#1-6-对称树" class="headerlink" title="1.6. 对称树"></a>1.6. 对称树</h3><p>判断两棵子树是否对称是关键点，其它就是使用这个方法进行递归了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isEqual(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isEqual(left.left, right.right) &amp;&amp; isEqual(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-7-路径和（略）"><a href="#1-7-路径和（略）" class="headerlink" title="1.7. 路径和（略）"></a>1.7. 路径和（略）</h3><h3 id="1-8-中序遍历加后序遍历恢复原树结构"><a href="#1-8-中序遍历加后序遍历恢复原树结构" class="headerlink" title="1.8. 中序遍历加后序遍历恢复原树结构"></a>1.8. 中序遍历加后序遍历恢复原树结构</h3><p>需要对中后序遍历的关系搞得非常清楚才能写出这样的代码。真的很神奇。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_inorder, p_postorder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        p_inorder = inorder.length - <span class="number">1</span>;</span><br><span class="line">        p_postorder = postorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder, postorder, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder, TreeNode end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_postorder &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[p_postorder]);</span><br><span class="line">        p_postorder--;</span><br><span class="line">        <span class="comment">// 判断是否存在右节点</span></span><br><span class="line">        <span class="keyword">if</span>(inorder[p_inorder] != root.val)</span><br><span class="line">            root.right = buildTree(inorder, postorder, root);</span><br><span class="line">        p_inorder--;</span><br><span class="line">        <span class="comment">// 判断是否存在左点， 当end==null时都是一棵左子树开始创建的时候</span></span><br><span class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span> || inorder[p_inorder] != end.val)</span><br><span class="line">            root.left = buildTree(inorder, postorder, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-9-使用链表连接每一层"><a href="#1-9-使用链表连接每一层" class="headerlink" title="1.9. 使用链表连接每一层"></a>1.9. 使用链表连接每一层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// for complete binary tree</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( root.left != <span class="keyword">null</span> )&#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( root.next != <span class="keyword">null</span> )&#123;</span><br><span class="line">                root.right.next = root.next.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        connect( root.left );</span><br><span class="line">        connect( root.right );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for normal binary tree</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( root.left != <span class="keyword">null</span> )&#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( root.next != <span class="keyword">null</span> )&#123;</span><br><span class="line">                root.right.next = root.next.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        connect( root.left );</span><br><span class="line">        connect( root.right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-10-给定一棵树和一个节点，输出从根节点到这个节点的路径"><a href="#1-10-给定一棵树和一个节点，输出从根节点到这个节点的路径" class="headerlink" title="1.10. 给定一棵树和一个节点，输出从根节点到这个节点的路径"></a>1.10. 给定一棵树和一个节点，输出从根节点到这个节点的路径</h3><p>思路就是，首先判断边界条件，如果根节点或者目标节点为空的话，就不用找了。正常情况下，使用一个列表记录路径，这个列表也相当于一个栈，使用遍历（回溯）的方法。当前节点不为空，入栈，如果栈顶节点等于目标节点，则找到了。如果不等于则需要判断是否需要出栈，情况有2，第一种，如果当前节点已经是叶节点了，出栈；第二种，如果当前节点的左右子树都没有找到这个节点，出栈。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findPath</span><span class="params">(TreeNode root, TreeNode target, List&lt;TreeNode&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || target == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    list.add(root);</span><br><span class="line">    <span class="keyword">if</span> (root == target) &#123;</span><br><span class="line">        found = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> leftFound = <span class="keyword">false</span>, rightFound = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftFound = findPath(root.left, target, list);</span><br><span class="line">            rightFound = findPath(root.right, target, list);</span><br><span class="line">            found = (leftFound || rightFound);</span><br><span class="line">            <span class="keyword">if</span> (!found)</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-11-两个节点的最小公共祖先"><a href="#1-11-两个节点的最小公共祖先" class="headerlink" title="1.11. 两个节点的最小公共祖先"></a>1.11. 两个节点的最小公共祖先</h3><blockquote>
<p>If the current (sub)tree contains both p and q, then the function result is their LCA. If only one of them is in that subtree, then the result is that one of them. If neither are in that subtree, the result is null/None/nil.</p>
</blockquote>
<p>算法的整体思路是：以当前节点为父节点（或者叫祖先节点），看它的左右两棵子树是否都包含p和q，由于p和q使用的是对象等于判断方法，所以如果两棵子树都包含的话，必定分别包含p和q，则直接返回当前节点。如果都不包含，那就是没有。如果一个包含一个不包含，返回包含的那个节点。</p>
<p>但是注意：这种编程方法只适合于两个节点都存在于树中的情况。如果有一个不存在的话输出的结果是有问题的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-12-树的序列化和反序列化"><a href="#1-12-树的序列化和反序列化" class="headerlink" title="1.12. 树的序列化和反序列化"></a>1.12. 树的序列化和反序列化</h3><p>思路是将叶节点的子节点（null)也记录在案，这样无论是哪种遍历顺序（前中后，层次）都方便恢复。这里选择前序遍历进行序列化，反序列化就是前序遍历结果的反推。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"N,"</span>;</span><br><span class="line">    String res = root.val + <span class="string">","</span>;</span><br><span class="line">    res += serialize(root.left);</span><br><span class="line">    res += serialize(root.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.length() &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// method 1</span></span><br><span class="line">    <span class="comment">// String[] vals = data.split(",");</span></span><br><span class="line">    <span class="comment">// return deserializeCore(vals);</span></span><br><span class="line">    <span class="comment">// method 2</span></span><br><span class="line">    <span class="keyword">return</span> deserializeCore2(<span class="keyword">new</span> StringBuilder(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserializeCore</span><span class="params">(String[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MyCounter.count &gt;= data.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String valStr = data[MyCounter.count];</span><br><span class="line">    MyCounter.count++;</span><br><span class="line">    <span class="keyword">if</span> (valStr.equals(<span class="string">"N"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(valStr));</span><br><span class="line">    node.left = deserializeCore(data);</span><br><span class="line">    node.right = deserializeCore(data);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserializeCore2</span><span class="params">(StringBuilder data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.length() &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = data.indexOf(<span class="string">","</span>);</span><br><span class="line">    String valStr = data.substring(<span class="number">0</span>, idx);</span><br><span class="line">    data.delete(<span class="number">0</span>, idx + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (valStr.equals(<span class="string">"N"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(valStr));</span><br><span class="line">    node.left = deserializeCore2(data);</span><br><span class="line">    <span class="comment">// data.delete(0, data.indexOf(",") + 1);</span></span><br><span class="line">    node.right = deserializeCore2(data);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCounter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/linux和操作系统/os/随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/linux和操作系统/os/随笔/" itemprop="url">操作系统随笔</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T17:13:51+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="操作系统随笔"><a href="#操作系统随笔" class="headerlink" title="操作系统随笔"></a>操作系统随笔</h1><!-- TOC -->
<ul>
<li><a href="#1-锁的概念以及死锁的概念">1. 锁的概念以及死锁的概念</a></li>
<li><a href="#2-计算机ip保留地址">2. 计算机IP保留地址</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-锁的概念以及死锁的概念"><a href="#1-锁的概念以及死锁的概念" class="headerlink" title="1. 锁的概念以及死锁的概念"></a>1. 锁的概念以及死锁的概念</h2><ul>
<li><p>牛客网参考答案：<a href="https://www.nowcoder.com/ta/review-java/review?page=16" target="_blank" rel="noopener">JAVA面试常考知识点：page16</a></p>
<blockquote>
<p>所谓死锁是指多个进 程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：</p>
<ul>
<li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。</li>
</ul>
</blockquote>
</li>
<li><p>如何解决死锁问题</p>
</li>
</ul>
<p>目标就是破坏产生死锁的四个条件，一般最后一个条件比较容易破坏，也就是所有锁的需求都是按照一定顺序来的。可参考：<a href="https://www.jianshu.com/p/44125bb12ebf" target="_blank" rel="noopener">死锁是什么？如何避免死锁？</a></p>
<h2 id="2-计算机IP保留地址"><a href="#2-计算机IP保留地址" class="headerlink" title="2. 计算机IP保留地址"></a>2. 计算机IP保留地址</h2><p>参考文章：<a href="http://www.cnblogs.com/ZJoy/archive/2011/03/24/1994308.html" target="_blank" rel="noopener">IP地址中的保留地址</a><br>根据用途和安全性级别的不同，IP地址还可以大致分为两类：公共地址和私有地址。</p>
<ul>
<li>公用地址在Internet中使用，可以在Internet中随意访问。</li>
<li>私有地址只能在内部网络中使用，只有通过代理服务器才能与Internet通信。</li>
</ul>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/data_struc_algo/sortsummary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/data_struc_algo/sortsummary/" itemprop="url">各种排序方法的简单总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T17:13:51+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="各种排序方法的简单总结"><a href="#各种排序方法的简单总结" class="headerlink" title="各种排序方法的简单总结"></a>各种排序方法的简单总结</h1><p>排序算法算是计算机的经典算法，解决很多问题的时候排序算法的思想都值得参考。<br><!-- TOC --></p>
<ul>
<li><a href="#1-快速排序的思想">1. 快速排序的思想</a></li>
<li><a href="#2-归并排序的思想">2. 归并排序的思想</a></li>
<li><a href="#3-堆排序的思路">3. 堆排序的思路</a></li>
</ul>
<!-- /TOC -->
<h2 id="1-快速排序的思想"><a href="#1-快速排序的思想" class="headerlink" title="1. 快速排序的思想"></a>1. 快速排序的思想</h2><p>学习容易记住的快排算法过程（Partition函数式最重要的，有两种写法，一种高效，另一种普通，参考<a href="http://selfboot.cn/2016/09/01/lost_partition/" target="_blank" rel="noopener">这里</a>）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main sort function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(start == end)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> index = partition(arr, len, start, end);</span><br><span class="line">	print_arr(arr, len);</span><br><span class="line">	<span class="keyword">if</span>(index &gt; start)</span><br><span class="line">		qsort(arr, len, start, index - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(index &lt; end)</span><br><span class="line">		qsort(arr, len, index + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition function 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span> || start &lt; <span class="number">0</span> || end &lt; <span class="number">0</span> || end &gt;= len || end &lt; start)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"partition input invalid\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[end];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = start; i &lt; end; i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i] &lt; pivot)&#123;</span><br><span class="line">			small++;</span><br><span class="line">			<span class="keyword">if</span>(i != small)</span><br><span class="line">				swap(&amp;arr[small], &amp;arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	small++;</span><br><span class="line">	swap(&amp;arr[small], &amp;arr[end]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition function which is more efficient</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(arr == <span class="literal">NULL</span> || start &lt; <span class="number">0</span> || end &lt; <span class="number">0</span> || end &gt;= len || end &lt; start)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"partition input invalid\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> pivot = arr[end];</span><br><span class="line">	start--;</span><br><span class="line">	<span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end &amp;&amp; arr[++start] &lt;= pivot);</span><br><span class="line">		arr[end] = arr[start];</span><br><span class="line">		<span class="keyword">while</span>(start &lt; end &amp;&amp; arr[--end] &gt;= pivot);</span><br><span class="line">		arr[start] = arr[end];</span><br><span class="line">	&#125;</span><br><span class="line">	arr[start] = pivot;</span><br><span class="line">	<span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-归并排序的思想"><a href="#2-归并排序的思想" class="headerlink" title="2. 归并排序的思想"></a>2. 归并排序的思想</h2><p>归并排序就是将数组分成两个部分，然后分别对两个部分进行排序，然后再融合起来。可以递归实现，算法时间复杂度时O(nlogn)，空间复杂度O(n)，也就是需要辅助空间。</p>
<h2 id="3-堆排序的思路"><a href="#3-堆排序的思路" class="headerlink" title="3. 堆排序的思路"></a>3. 堆排序的思路</h2><p>参考：<a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法 - 堆排序 (Heap Sort)</a></p>
<p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p>
<ul>
<li>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li>
<li>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</li>
<li>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li>
</ul>
<p>最大堆调整（MAX‐HEAPIFY）的作用是保持最大堆的性质，是创建最大堆的核心子程序。下面是Java版本的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/* 堆排序的思路：</span></span><br><span class="line"><span class="comment"> * 1. 首先明确堆是一种数据结构，利用堆这种数据结构的特性可以很高效地做排序算法。</span></span><br><span class="line"><span class="comment"> * 2. 第一步：堆化。将原本不是堆结构的数组转换成堆，方法时从第一个不是叶节点的节点开始，到根节点，进行堆化操作。堆化操作就是数字的上浮和下沉，要注意的是下沉要彻底，也就是需要递归或者迭代处理下沉的点。</span></span><br><span class="line"><span class="comment"> * 3. 第二步：排序。以最大堆为例，堆顶（也就是树结构的根节点，也就是数组第一个元素）存的是最大值，堆顶元素与最末尾叶节点交换，交换后堆就不是最大堆了，需要重新调整，但是调整的时候就不管最后一个元素了，所以堆的长度减少1。循环此过程直到堆内只剩下一个元素。排序完成。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSortWiki</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">HeapSortWiki</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.arr = arr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 堆排序的主要入口方法，共两步。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 第一步：将数组堆化 beginIndex = 第一个非叶子节点。 从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment">		 * 叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">int</span> beginIndex = (len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = beginIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			maxHeapify(i, len);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 第二步：对堆化数据排序 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span></span><br><span class="line"><span class="comment">		 * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。 直至未排序的堆长度为 0。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">			swap(<span class="number">0</span>, i);</span><br><span class="line">			maxHeapify(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 调整索引为 index 处的数据，使其符合堆的特性。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">	 *            需要堆化处理的数据的索引</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">	 *            未排序的堆（数组）的长度</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> li = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line">		<span class="keyword">int</span> ri = li + <span class="number">1</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line">		<span class="keyword">int</span> cMax = li; <span class="comment">// 子节点值最大索引，默认左子节点。</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (li &gt; len)</span><br><span class="line">			<span class="keyword">return</span>; <span class="comment">// 左子节点索引超出计算范围，直接返回。</span></span><br><span class="line">		<span class="keyword">if</span> (ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) <span class="comment">// 先判断左右子节点，哪个较大。</span></span><br><span class="line">			cMax = ri;</span><br><span class="line">		<span class="keyword">if</span> (arr[cMax] &gt; arr[index]) &#123;</span><br><span class="line">			swap(cMax, index); <span class="comment">// 如果父节点被子节点调换，</span></span><br><span class="line">			maxHeapify(cMax, len); <span class="comment">// 则需要继续判断换下后的父节点是否符合堆的特性。</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 测试用例</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * 输出： [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7,</span></span><br><span class="line"><span class="comment">	 * 7, 8, 8, 8, 9, 9, 9]</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line">				<span class="number">6</span> &#125;;</span><br><span class="line">		<span class="keyword">new</span> HeapSortWiki(arr).sort();</span><br><span class="line">		System.out.println(Arrays.toString(arr));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/data_struc_algo/data structure/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/data_struc_algo/data structure/" itemprop="url">数据结构与算法随笔</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T17:13:51+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Data-Struture-Note"><a href="#Data-Struture-Note" class="headerlink" title="Data Struture Note"></a>Data Struture Note</h1><!-- TOC -->
<ul>
<li><a href="#1-如何解决hash冲突有哪几种方案">1. 如何解决<code>hash</code>冲突，有哪几种方案</a><ul>
<li><a href="#11-开放定址法">1.1. 开放定址法</a></li>
<li><a href="#12-链地址法拉链法">1.2. 链地址法（拉链法）</a></li>
<li><a href="#13-再哈希法">1.3. 再哈希法</a></li>
<li><a href="#14-建立公共溢出区">1.4. 建立公共溢出区</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-如何解决hash冲突，有哪几种方案"><a href="#1-如何解决hash冲突，有哪几种方案" class="headerlink" title="1. 如何解决hash冲突，有哪几种方案"></a>1. 如何解决<code>hash</code>冲突，有哪几种方案</h2><p>参考：<a href="https://www.jianshu.com/p/4d3cb99d7580" target="_blank" rel="noopener">解决哈希冲突的常用方法分析</a></p>
<h3 id="1-1-开放定址法"><a href="#1-1-开放定址法" class="headerlink" title="1.1. 开放定址法"></a>1.1. 开放定址法</h3><ul>
<li>线性探查法：找到下一个有空的位置放进去，查找的时候遍历（其实也可以有一个辅助的数组专门记录移动的位置），这个方法容易出现“聚集”的现象</li>
<li>平方探查法：二次探测法的地址增量序列为 di = 12， -12， 22， -22，… ， q2, -q2 (q &lt;= m/2)。二次探测能有效避免“聚集”现象，但是不能够探测到哈希表上所有的存储单元，但是至少能够探测到一半。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</li>
<li>双散列函数探查法： hp (key)若h(key)出现冲突，则再使用hp (key)求取散列地址。探查序列为：<code>h(k), h(k)+ hp(k),…, h((k)+ i*hp(k))</code>。</li>
</ul>
<h3 id="1-2-链地址法（拉链法）"><a href="#1-2-链地址法（拉链法）" class="headerlink" title="1.2. 链地址法（拉链法）"></a>1.2. 链地址法（拉链法）</h3><p><code>Java</code>中<code>HashMap</code>的经典实现算法。</p>
<h3 id="1-3-再哈希法"><a href="#1-3-再哈希法" class="headerlink" title="1.3. 再哈希法"></a>1.3. 再哈希法</h3><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。</p>
<h3 id="1-4-建立公共溢出区"><a href="#1-4-建立公共溢出区" class="headerlink" title="1.4. 建立公共溢出区"></a>1.4. 建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/offer/面试随笔/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/offer/面试随笔/" itemprop="url">面试随笔</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/随笔/" itemprop="url" rel="index">
                    <span itemprop="name">随笔</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="面试随笔"><a href="#面试随笔" class="headerlink" title="面试随笔"></a>面试随笔</h1><p>记录一些在面试过程中遇到的问题</p>
<!-- TOC -->
<ul>
<li><a href="#1-程序lang掉无响应">1. 程序lang掉（无响应）</a></li>
<li><a href="#3-网易的两道题">3. 网易的两道题</a><ul>
<li><a href="#31-符合nk的数对有多少种">3.1. 符合n，k的数对有多少种</a></li>
<li><a href="#32-有多少种装法">3.2. 有多少种装法</a></li>
</ul>
</li>
<li><a href="#腾讯面试题">腾讯面试题</a><ul>
<li><a href="#带符号大数加减">带符号大数加减</a></li>
</ul>
</li>
<li><a href="#阿里电话面试">阿里电话面试</a><ul>
<li><a href="#jstorm流程-和-jstorm-slot">JStorm流程 和 JStorm Slot</a></li>
<li><a href="#b树为什么适合数据库为什么快">B+树为什么适合数据库，为什么快</a></li>
<li><a href="#红黑树的五个特点">红黑树的五个特点</a></li>
<li><a href="#java-nio">java nio</a><ul>
<li><a href="#什么是javanio">什么是java.nio?</a></li>
<li><a href="#与io的主要区别">与io的主要区别</a></li>
</ul>
</li>
<li><a href="#hbase流程">HBase流程</a></li>
<li><a href="#kafka数据压缩">kafka数据压缩</a></li>
<li><a href="#java-线程池">java 线程池</a></li>
<li><a href="#tcp三次握手和四次挥手详细过程及状态变化">tcp三次握手和四次挥手详细过程及状态变化</a></li>
<li><a href="#java读取文件有哪几种方法区别是什么">java读取文件有哪几种方法，区别是什么</a></li>
<li><a href="#java线程的生命周期">Java线程的生命周期</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-程序lang掉（无响应）"><a href="#1-程序lang掉（无响应）" class="headerlink" title="1. 程序lang掉（无响应）"></a>1. 程序lang掉（无响应）</h2><h2 id="3-网易的两道题"><a href="#3-网易的两道题" class="headerlink" title="3. 网易的两道题"></a>3. 网易的两道题</h2><h3 id="3-1-符合n，k的数对有多少种"><a href="#3-1-符合n，k的数对有多少种" class="headerlink" title="3.1. 符合n，k的数对有多少种"></a>3.1. 符合n，k的数对有多少种</h3><h3 id="3-2-有多少种装法"><a href="#3-2-有多少种装法" class="headerlink" title="3.2. 有多少种装法"></a>3.2. 有多少种装法</h3><h2 id="腾讯面试题"><a href="#腾讯面试题" class="headerlink" title="腾讯面试题"></a>腾讯面试题</h2><h3 id="带符号大数加减"><a href="#带符号大数加减" class="headerlink" title="带符号大数加减"></a>带符号大数加减</h3><h2 id="阿里电话面试"><a href="#阿里电话面试" class="headerlink" title="阿里电话面试"></a>阿里电话面试</h2><h3 id="JStorm流程-和-JStorm-Slot"><a href="#JStorm流程-和-JStorm-Slot" class="headerlink" title="JStorm流程 和 JStorm Slot"></a>JStorm流程 和 JStorm Slot</h3><h3 id="B-树为什么适合数据库，为什么快"><a href="#B-树为什么适合数据库，为什么快" class="headerlink" title="B+树为什么适合数据库，为什么快"></a>B+树为什么适合数据库，为什么快</h3><ul>
<li>为什么B+树索引结构是存储在磁盘上的？</li>
<li>为什么比B树更好？<h3 id="红黑树的五个特点"><a href="#红黑树的五个特点" class="headerlink" title="红黑树的五个特点"></a>红黑树的五个特点</h3><h3 id="java-nio"><a href="#java-nio" class="headerlink" title="java nio"></a>java nio</h3>参考：</li>
<li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java nio浅析</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">NIO 入门</a></li>
<li><a href="http://ifeve.com/java-nio-all/" target="_blank" rel="noopener">Java NIO 系列教程</a></li>
<li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">Java NIO Tutorials</a><h4 id="什么是java-nio"><a href="#什么是java-nio" class="headerlink" title="什么是java.nio?"></a>什么是java.nio?</h4>NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</li>
</ul>
<h4 id="与io的主要区别"><a href="#与io的主要区别" class="headerlink" title="与io的主要区别"></a>与io的主要区别</h4><table>
<thead>
<tr>
<th style="text-align:left">IO</th>
<th style="text-align:left">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">面向流</td>
<td style="text-align:left">面向缓冲</td>
</tr>
<tr>
<td style="text-align:left">阻塞IO</td>
<td style="text-align:left">非阻塞IO</td>
</tr>
<tr>
<td style="text-align:left">无</td>
<td style="text-align:left">选择器</td>
</tr>
</tbody>
</table>
<ul>
<li><p>面向流与面向缓冲<br>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
</li>
<li><p>阻塞与非阻塞IO<br>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
</li>
<li><p>选择器（Selectors）<br>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p>
</li>
</ul>
<h3 id="HBase流程"><a href="#HBase流程" class="headerlink" title="HBase流程"></a>HBase流程</h3><h3 id="kafka数据压缩"><a href="#kafka数据压缩" class="headerlink" title="kafka数据压缩"></a>kafka数据压缩</h3><h3 id="java-线程池"><a href="#java-线程池" class="headerlink" title="java 线程池"></a>java 线程池</h3><h3 id="tcp三次握手和四次挥手详细过程及状态变化"><a href="#tcp三次握手和四次挥手详细过程及状态变化" class="headerlink" title="tcp三次握手和四次挥手详细过程及状态变化"></a>tcp三次握手和四次挥手详细过程及状态变化</h3><p><img src="tcp34.png" alt="tcp34"><br><img src="tcp3handshake.png" alt="tcp3handshake"><br><img src="tcp4handwave.png" alt="tcp4handwave"></p>
<p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.<br>其中，对于我们日常的分析有用的就是前面的五个字段。</p>
<p>它们的含义是：</p>
<ul>
<li>SYN表示建立连接，</li>
<li>FIN表示关闭连接，</li>
<li>ACK表示响应，</li>
<li>PSH表示有 DATA数据传输，</li>
<li>RST表示连接重置。</li>
</ul>
<p>其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接请求之后的响应，如果只是单个的一个SYN，它表示的只是建立连接。TCP的几次握手就是通过这样的ACK表现出来的。但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。</p>
<h3 id="java读取文件有哪几种方法，区别是什么"><a href="#java读取文件有哪几种方法，区别是什么" class="headerlink" title="java读取文件有哪几种方法，区别是什么"></a>java读取文件有哪几种方法，区别是什么</h3><p>参考：</p>
<ul>
<li><a href="http://www.cnblogs.com/lovebread/archive/2009/11/23/1609122.html" target="_blank" rel="noopener">Java文件读取方式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28757397" target="_blank" rel="noopener">Java IO流学习总结</a></li>
</ul>
<p><img src="IOStream.png" alt="IO Stream"><br><img src="java_io_byte.png" alt="java_io_byte"><br><img src="javaio.png" alt="javaio"></p>
<ol>
<li>按字节读取文件内容：常用于读二进制文件，如图片、声音、影像等文件。</li>
<li>按字符读取文件内容：以字符为单位读取文件，常用于读文本，数字等类型的文件</li>
<li>按行读取文件内容：以行为单位读取文件，常用于读面向行的格式化文件</li>
<li>随机读取文件内容 </li>
</ol>
<ul>
<li>关于一次性读取文件内容：<br>一次性读取文件比按行读取效率要高很多，因为每次调用readLine()方法都需要转换编码，而一次性读取只需要转换一次。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readToString</span><span class="params">(String fileName)</span> </span>&#123;  </span><br><span class="line">        String encoding = <span class="string">"ISO-8859-1"</span>;  </span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);  </span><br><span class="line">        Long filelength = file.length();  </span><br><span class="line">        <span class="keyword">byte</span>[] filecontent = <span class="keyword">new</span> <span class="keyword">byte</span>[filelength.intValue()];  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line">            in.read(filecontent);  </span><br><span class="line">            in.close();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(filecontent, encoding);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;  </span><br><span class="line">            System.err.println(<span class="string">"The OS does not support "</span> + encoding);  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Java线程的生命周期"><a href="#Java线程的生命周期" class="headerlink" title="Java线程的生命周期"></a>Java线程的生命周期</h3><p>参考：<a href="https://www.cnblogs.com/sunddenly/p/4106562.html" target="_blank" rel="noopener">线程的生命周期</a></p>
<ul>
<li>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态</li>
</ul>
<ol>
<li>新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值</li>
<li>就绪状态，当线程对象调用了<code>start()</code>方法之后，该线程处于就绪状态。<strong>Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行</strong></li>
<li>运行状态，如果处于就绪状态的线程获得了CPU，开始执行<code>run()</code>方法的线程执行体，则该线程处于运行状态</li>
<li>阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态</li>
<li>在线程的生命周期当中，线程的各种状态的转换过程</li>
</ol>
<p><img src="线程状态转换图.png" alt="线程状态转换图"></p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/offer/找实习笔记整理与记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/offer/找实习笔记整理与记录/" itemprop="url">Untitled</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="需要准备的考点"><a href="#需要准备的考点" class="headerlink" title="需要准备的考点"></a>需要准备的考点</h1><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h2 id="网络（TCP，UDP）等"><a href="#网络（TCP，UDP）等" class="headerlink" title="网络（TCP，UDP）等"></a>网络（TCP，UDP）等</h2><h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h2><h2 id="Python语言"><a href="#Python语言" class="headerlink" title="Python语言"></a>Python语言</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="分布式系统构建"><a href="#分布式系统构建" class="headerlink" title="分布式系统构建"></a>分布式系统构建</h2><ul>
<li>Kafka</li>
<li>JStorm</li>
<li>Memcached</li>
<li>Hadoop</li>
<li>Spark</li>
<li>HBase<h2 id="关于项目的几个问题"><a href="#关于项目的几个问题" class="headerlink" title="关于项目的几个问题"></a>关于项目的几个问题</h2></li>
</ul>
<ol>
<li>项目为什么使用Postgresql开发？</li>
<li>你在项目中主要负责做什么？</li>
</ol>
<ul>
<li>数据入关系数据库pg</li>
<li>数据入分布式内存数据库memcached</li>
<li>系统分布式架构的运行与维护</li>
</ul>
<ol start="2">
<li>项目的不足是什么？</li>
</ol>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/offer/剑指offer阅读笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/offer/剑指offer阅读笔记/" itemprop="url">剑指offer阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/" itemprop="url" rel="index">
                    <span itemprop="name">面试</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/面试/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="剑指offer阅读笔记"><a href="#剑指offer阅读笔记" class="headerlink" title="剑指offer阅读笔记"></a>剑指offer阅读笔记</h1><!-- TOC -->
<ul>
<li><a href="#1-面试需要注意的内容">1. 面试需要注意的内容</a></li>
<li><a href="#2-编程题">2. 编程题</a><ul>
<li><a href="#21-从链表中查找倒数第k个值">2.1. 从链表中查找倒数第k个值</a></li>
<li><a href="#22-从矩阵从左到右从上到下依次增大中查找某值">2.2. 从矩阵（从左到右，从上到下依次增大）中查找某值</a></li>
<li><a href="#23-字符串替换">2.3. 字符串替换</a></li>
<li><a href="#24-链表在不改变结构的情况下倒着输出">2.4. 链表在不改变结构的情况下倒着输出</a></li>
<li><a href="#25-根据前序遍历和中序遍历的结果重建一棵树">2.5. 根据前序遍历和中序遍历的结果重建一棵树</a></li>
<li><a href="#26-用两个栈实现队列">2.6. 用两个栈实现队列</a></li>
<li><a href="#27-旋转数组的最小数字">2.7. 旋转数组的最小数字</a></li>
<li><a href="#28-二进制中1的个数">2.8. 二进制中1的个数</a></li>
<li><a href="#29-数值的整数次方">2.9. 数值的整数次方</a></li>
<li><a href="#210-打印1到最大的n位数">2.10. 打印1到最大的n位数</a></li>
<li><a href="#211-在o1时间删除链表节点">2.11. 在O(1)时间删除链表节点</a></li>
<li><a href="#212-调整数组顺序使得奇数位于偶数前面">2.12. 调整数组顺序使得奇数位于偶数前面</a></li>
<li><a href="#213-反转链表">2.13. 反转链表</a></li>
<li><a href="#214-合并两个排序的链表">2.14. 合并两个排序的链表</a></li>
<li><a href="#215-树的子结构">2.15. 树的子结构</a></li>
<li><a href="#216-二叉树的镜像">2.16. 二叉树的镜像</a></li>
<li><a href="#217-顺时针打印矩阵">2.17. 顺时针打印矩阵</a></li>
<li><a href="#218-包含min函数的栈">2.18. 包含min函数的栈</a></li>
<li><a href="#219-栈的压入和弹出顺序匹配">2.19. 栈的压入和弹出顺序匹配</a></li>
<li><a href="#220-从上往下打印二叉树">2.20. 从上往下打印二叉树</a></li>
<li><a href="#221-二叉搜索树的后序遍历序列判断给定数组是不是一颗二叉搜索树的后序遍历序列">2.21. 二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）</a></li>
<li><a href="#222-二叉树中和为某值的路径直到叶节点">2.22. 二叉树中和为某值的路径（直到叶节点）</a></li>
<li><a href="#223-复杂链表的复制">2.23. 复杂链表的复制</a></li>
<li><a href="#224-二叉搜索树改为双向链表只调整树中节点指针的指向">2.24. 二叉搜索树改为双向链表（只调整树中节点指针的指向）</a></li>
<li><a href="#225-字符串的排列">2.25. 字符串的排列</a></li>
<li><a href="#226-数组中出现次数超过一半的数字">2.26. 数组中出现次数超过一半的数字</a></li>
<li><a href="#227-最小的k个数">2.27. 最小的k个数</a></li>
<li><a href="#228-连续子数组最大和">2.28. 连续子数组最大和</a></li>
<li><a href="#229-从1到n中1出现的次数">2.29. 从1到n中1出现的次数</a></li>
<li><a href="#230-数组排成最小的数">2.30. 数组排成最小的数</a></li>
<li><a href="#231-丑数列举">2.31. 丑数列举</a></li>
<li><a href="#232-第一个只出现一次的字符abcdacd输出b">2.32. 第一个只出现一次的字符（abcdacd输出b）</a></li>
<li><a href="#233-数组中的逆序对">2.33. 数组中的逆序对</a></li>
<li><a href="#234-遍历两个有公共节点的链表找到这个连接点">2.34. 遍历两个有公共节点的链表，找到这个连接点</a></li>
<li><a href="#235-数字在排序数组中出现的次数给定数组和数字输出数字在数组中出现的次数">2.35. 数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）</a></li>
<li><a href="#236-二叉树的深度">2.36. 二叉树的深度</a></li>
<li><a href="#237-判断是不是平衡二叉树任意左右子树深度相差不超过1">2.37. 判断是不是平衡二叉树（任意左右子树深度相差不超过1）</a></li>
<li><a href="#238-数组中只出现一次的一个数字">2.38. 数组中只出现一次的一个数字</a></li>
<li><a href="#239-数组中只出现一次的两个数字">2.39. 数组中只出现一次的两个数字</a></li>
<li><a href="#240-从数组中找到和为s的两个数字">2.40. 从数组中找到和为s的两个数字</a></li>
<li><a href="#241-输出所有和为s的连续正数序列">2.41. 输出所有和为S的连续正数序列</a></li>
<li><a href="#242-翻转单词顺序">2.42. 翻转单词顺序</a></li>
<li><a href="#243-左旋转字符串abcdef和数字2输出cdefab">2.43. 左旋转字符串（abcdef和数字2，输出cdefab）</a></li>
<li><a href="#244-n个骰子的点数每种点数的概率">2.44. n个骰子的点数（每种点数的概率）</a></li>
<li><a href="#245-扑克牌的顺子取五张牌判断是不是顺子">2.45. 扑克牌的顺子（取五张牌，判断是不是顺子）</a></li>
<li><a href="#246-圆圈中剩下的数字">2.46. 圆圈中剩下的数字</a></li>
<li><a href="#247-不用加减乘除做加法">2.47. 不用加减乘除做加法</a></li>
<li><a href="#248-两个面试案例">2.48. 两个面试案例</a></li>
<li><a href="#249-数组中重复的数字长度为n的数组并且数字都在0到n-1之间">2.49. 数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）</a></li>
<li><a href="#250-构建乘积数组不能使用除法">2.50. 构建乘积数组（不能使用除法）</a></li>
<li><a href="#251-字符串正则表达式匹配">2.51. 字符串正则表达式匹配</a></li>
<li><a href="#252-链表中环的入口结点">2.52. 链表中环的入口结点</a></li>
<li><a href="#253-删除链表中重复的节点">2.53. 删除链表中重复的节点</a></li>
<li><a href="#254-二叉树的下一个节点数中存在指向父节点的指针找到中序遍历的下一个节点">2.54. 二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）</a></li>
<li><a href="#255-对称的二叉树">2.55. 对称的二叉树</a></li>
<li><a href="#256-二叉树打印成多行">2.56. 二叉树打印成多行</a></li>
<li><a href="#257-序列化二叉树">2.57. 序列化二叉树</a></li>
<li><a href="#258-二叉搜索树的第k个节点第k大的节点">2.58. 二叉搜索树的第k个节点（第k大的节点）</a></li>
<li><a href="#259-数据流的中位数">2.59. 数据流的中位数</a></li>
<li><a href="#260-滑动窗口的最大值">2.60. 滑动窗口的最大值</a></li>
</ul>
</li>
</ul>
<!-- /TOC -->
<h2 id="1-面试需要注意的内容"><a href="#1-面试需要注意的内容" class="headerlink" title="1. 面试需要注意的内容"></a>1. 面试需要注意的内容</h2><ul>
<li>准备几个问题问面试官（根据公司、职位等等）</li>
<li>介绍自己做过的项目：简短的项目背景、完成的任务、未完成任务自己做了哪些方面的工作（以及怎么做的）、总结自己的贡献与收获</li>
<li>扎实的基础知识与高质量的代码：命名与缩进习惯，<strong>边界条件（boundary condition）的考虑</strong>，优化效率的能力，<strong>不合规范的输入的处理</strong>等等。</li>
</ul>
<h2 id="2-编程题"><a href="#2-编程题" class="headerlink" title="2. 编程题"></a>2. 编程题</h2><h3 id="2-1-从链表中查找倒数第k个值"><a href="#2-1-从链表中查找倒数第k个值" class="headerlink" title="2.1. 从链表中查找倒数第k个值"></a>2.1. 从链表中查找倒数第k个值</h3><p>两个指针，但是注意边界条件。</p>
<h3 id="2-2-从矩阵（从左到右，从上到下依次增大）中查找某值"><a href="#2-2-从矩阵（从左到右，从上到下依次增大）中查找某值" class="headerlink" title="2.2. 从矩阵（从左到右，从上到下依次增大）中查找某值"></a>2.2. 从矩阵（从左到右，从上到下依次增大）中查找某值</h3><p>从右往左入手选定列，在从上往下入手选定行。</p>
<h3 id="2-3-字符串替换"><a href="#2-3-字符串替换" class="headerlink" title="2.3. 字符串替换"></a>2.3. 字符串替换</h3><p>将原本一个字符换成多个字符时，注意从右往左（减少移动次数），同样类型的还有归并排序(两个排好序的数组，并且第二个数组后面有足够的空间方数据)，从后往前排。</p>
<h3 id="2-4-链表在不改变结构的情况下倒着输出"><a href="#2-4-链表在不改变结构的情况下倒着输出" class="headerlink" title="2.4. 链表在不改变结构的情况下倒着输出"></a>2.4. 链表在不改变结构的情况下倒着输出</h3><p>使用栈或者用递归的方法</p>
<h3 id="2-5-根据前序遍历和中序遍历的结果重建一棵树"><a href="#2-5-根据前序遍历和中序遍历的结果重建一棵树" class="headerlink" title="2.5. 根据前序遍历和中序遍历的结果重建一棵树"></a>2.5. 根据前序遍历和中序遍历的结果重建一棵树</h3><p>前序遍历第一个都是根节点，中序遍历中间的也是根节点；思路为：取前序第一个，已知为根节点，然后在中序遍历中找到这个值，这个值左边的部分是根节点的左子树（数量为n）的中序遍历结果，右边的部分是根节点的右子树（数量为m）的中序遍历结果，相对应于前序遍历（去掉第一个）结果，前n个为左子树的前序遍历结果，后m个为右子树的前序遍历结果。递归。</p>
<h3 id="2-6-用两个栈实现队列"><a href="#2-6-用两个栈实现队列" class="headerlink" title="2.6. 用两个栈实现队列"></a>2.6. 用两个栈实现队列</h3><p>根据栈和队列的不同（栈先进后出，队列先进先出）。栈1用来实际入栈，栈2用来实际出栈，实现方式：为当需要进栈的时候，数据进入栈1，当需要出栈的时候，查看栈2是否为空，如果为空，则从栈1将所有数据出栈并入到栈2。</p>
<h3 id="2-7-旋转数组的最小数字"><a href="#2-7-旋转数组的最小数字" class="headerlink" title="2.7. 旋转数组的最小数字"></a>2.7. 旋转数组的最小数字</h3><p>使用二分查找的思想。设定两个指针p1和p2，若p1与p2相邻则取p2。若<code>p1&lt;p2</code>，取中间指针p3，若p3大于p1，则最小数字在p3到p2间，否则在p1到p3间。</p>
<h3 id="2-8-二进制中1的个数"><a href="#2-8-二进制中1的个数" class="headerlink" title="2.8. 二进制中1的个数"></a>2.8. 二进制中1的个数</h3><p>注意负数在二进制中最高位是1，如果使用<code>&gt;&gt;</code>进行移位操作，为了保证还是负数，不会改变最高位。两种方法，使用数字1进行二进制与操作，然后把1左移一位<code>&lt;&lt; 1</code>，继续与，直到结果为0。第二种方法，注意到整数a，与a-1进行与操作可以逐步消去最右端的1。</p>
<h3 id="2-9-数值的整数次方"><a href="#2-9-数值的整数次方" class="headerlink" title="2.9. 数值的整数次方"></a>2.9. 数值的整数次方</h3><p>注意整数次方，这里的整数还包含0和负数。还要注意对输入值的是否和法判断，判断两个double类型的数据是否相等不能直接使用<code>==</code>，而应该用差很小来表示。同时考虑整数次方，一次一次的相乘不够快，可以除以二然后相乘，也就是递归了。</p>
<h3 id="2-10-打印1到最大的n位数"><a href="#2-10-打印1到最大的n位数" class="headerlink" title="2.10. 打印1到最大的n位数"></a>2.10. 打印1到最大的n位数</h3><p>注意这里的n位数是否会是大数问题。可以打印全排列，使用递归思想，另外打印的时候注意前面是0的话就不要打印了。</p>
<h3 id="2-11-在O-1-时间删除链表节点"><a href="#2-11-在O-1-时间删除链表节点" class="headerlink" title="2.11. 在O(1)时间删除链表节点"></a>2.11. 在O(1)时间删除链表节点</h3><p>假设这个节点是node2delete，可以把node2delete.nextNode的值赋值给node2.delete，然后让node2delete指向下下个节点。</p>
<h3 id="2-12-调整数组顺序使得奇数位于偶数前面"><a href="#2-12-调整数组顺序使得奇数位于偶数前面" class="headerlink" title="2.12. 调整数组顺序使得奇数位于偶数前面"></a>2.12. 调整数组顺序使得奇数位于偶数前面</h3><p>主要思想是快排里面的Partition思想，只不过是左边找偶数，右边找奇数。通过拓展条件（使用函数），这一思想适用于更多场景。</p>
<h3 id="2-13-反转链表"><a href="#2-13-反转链表" class="headerlink" title="2.13. 反转链表"></a>2.13. 反转链表</h3><p>记录3个指针，分别代表<code>pNodeCurrent, pNodePrev, pReversedHead</code>。注意考虑输入为NULL以及链表的断裂情况</p>
<h3 id="2-14-合并两个排序的链表"><a href="#2-14-合并两个排序的链表" class="headerlink" title="2.14. 合并两个排序的链表"></a>2.14. 合并两个排序的链表</h3><p>基本同上</p>
<h3 id="2-15-树的子结构"><a href="#2-15-树的子结构" class="headerlink" title="2.15. 树的子结构"></a>2.15. 树的子结构</h3><p>递归查找匹配</p>
<h3 id="2-16-二叉树的镜像"><a href="#2-16-二叉树的镜像" class="headerlink" title="2.16. 二叉树的镜像"></a>2.16. 二叉树的镜像</h3><p>递归交换左右子树</p>
<h3 id="2-17-顺时针打印矩阵"><a href="#2-17-顺时针打印矩阵" class="headerlink" title="2.17. 顺时针打印矩阵"></a>2.17. 顺时针打印矩阵</h3><p>打印每一圈都分四步。主要是注意最后一圈可能退化成只有一行或者只有一列。这样打印最后一圈可能只需要3,2,1步。</p>
<h3 id="2-18-包含min函数的栈"><a href="#2-18-包含min函数的栈" class="headerlink" title="2.18. 包含min函数的栈"></a>2.18. 包含min函数的栈</h3><p>使用辅助栈记录每一个数据进栈之后更新的最小值</p>
<h3 id="2-19-栈的压入和弹出顺序匹配"><a href="#2-19-栈的压入和弹出顺序匹配" class="headerlink" title="2.19. 栈的压入和弹出顺序匹配"></a>2.19. 栈的压入和弹出顺序匹配</h3><p>栈的经典题目</p>
<h3 id="2-20-从上往下打印二叉树"><a href="#2-20-从上往下打印二叉树" class="headerlink" title="2.20. 从上往下打印二叉树"></a>2.20. 从上往下打印二叉树</h3><p>使用队列，每从队列中出一个节点，同时把节点的左右节点的值入队列。</p>
<h3 id="2-21-二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）"><a href="#2-21-二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）" class="headerlink" title="2.21. 二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）"></a>2.21. 二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）</h3><p>注意后序遍历的特点，根节点的值在最后面，而且是根节点的左子树遍历结果都小于根节点，右子树比那里结果都大于根节点。选定根节点，将前面的n-1个值切分为2部分，小于根节点值的是左子树，大于根节点值的是右子树。递归。</p>
<h3 id="2-22-二叉树中和为某值的路径（直到叶节点）"><a href="#2-22-二叉树中和为某值的路径（直到叶节点）" class="headerlink" title="2.22. 二叉树中和为某值的路径（直到叶节点）"></a>2.22. 二叉树中和为某值的路径（直到叶节点）</h3><p>其实是二叉树深度优先遍历的变种。每次递归完成之后都要返回父节点。</p>
<h3 id="2-23-复杂链表的复制"><a href="#2-23-复杂链表的复制" class="headerlink" title="2.23. 复杂链表的复制"></a>2.23. 复杂链表的复制</h3><p>举例子：原链表:<code>a-&gt;b-&gt;c-&gt;d</code>，先复制成<code>a-a&#39;-&gt;b-&gt;b&#39;-&gt;c-&gt;c&#39;-&gt;d-&gt;d&#39;</code>。然后挪动复杂指针一位就行。之后再分开。</p>
<h3 id="2-24-二叉搜索树改为双向链表（只调整树中节点指针的指向）"><a href="#2-24-二叉搜索树改为双向链表（只调整树中节点指针的指向）" class="headerlink" title="2.24. 二叉搜索树改为双向链表（只调整树中节点指针的指向）"></a>2.24. 二叉搜索树改为双向链表（只调整树中节点指针的指向）</h3><p>中序遍历思想。<a href="https://github.com/chen-kh/InterviewQuestions/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%9827%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8_ConvertBinarySearchTree.cpp" target="_blank" rel="noopener">戳这里查看代码详细</a></p>
<h3 id="2-25-字符串的排列"><a href="#2-25-字符串的排列" class="headerlink" title="2.25. 字符串的排列"></a>2.25. 字符串的排列</h3><p>主要思想是使用递归，然后把字符串排列看作两种情况：第一种是第一个是a，第二种是第一个不是a。第二种的得到就是把a和后面的每个字符进行互换操作得到。因此可以递归了。<a href="https://github.com/chen-kh/InterviewQuestions/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%9828%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97_StringPermutation.cpp" target="_blank" rel="noopener">戳这里查看代码详细</a></p>
<h3 id="2-26-数组中出现次数超过一半的数字"><a href="#2-26-数组中出现次数超过一半的数字" class="headerlink" title="2.26. 数组中出现次数超过一半的数字"></a>2.26. 数组中出现次数超过一半的数字</h3><p>解法一：基于快排的思想，更改partition函数，复杂度O(n)。跟找第k大的数是一样的，我们这次找第n/2个数。</p>
<p>解法二：根据数组特点完成算法，时间复杂度也是O(n)。保存两个变量<code>currentValue</code>和<code>preValue</code>，二者相同则加1，不同则减1。最有一个使得值为1的书就是超过一半的数字。</p>
<h3 id="2-27-最小的k个数"><a href="#2-27-最小的k个数" class="headerlink" title="2.27. 最小的k个数"></a>2.27. 最小的k个数</h3><p>解法一：基于快排的思想，知道随机找的数字最终落在了k位上。跟第k小数字如出一辙，复杂度O(n)</p>
<p>解法二：使用最小堆。需要堆或者红黑树来进行辅助。但是适用于大量数据的处理。复杂度O(nlogk)</p>
<h3 id="2-28-连续子数组最大和"><a href="#2-28-连续子数组最大和" class="headerlink" title="2.28. 连续子数组最大和"></a>2.28. 连续子数组最大和</h3><p>经典动态规划</p>
<h3 id="2-29-从1到n中1出现的次数"><a href="#2-29-从1到n中1出现的次数" class="headerlink" title="2.29. 从1到n中1出现的次数"></a>2.29. 从1到n中1出现的次数</h3><p>解法一：比较复杂。举例子说明。n=21345，（1-21345）转换为（1-1345）+（1346-21345），只处理第二部分，第一部分用相同的方法递归求解。第二部分分为（1346-11345）和（11346-21345），最高位出现1的次数10000次，最高位之外出现1的次数，固定一位，则其他位任意，<code>2*4*1000=8000</code>次。</p>
<p>解法二：<a href="https://blog.csdn.net/yi_afly/article/details/52012593" target="_blank" rel="noopener">详情戳这里</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（53*1+1）+（5*10+10）+（0*100+100）= 214</span><br><span class="line">530 = （53*1）+（5*10+10）+（0*100+100） = 213</span><br><span class="line">504 = （50*1+1）+（5*10）+（0*100+100） = 201</span><br><span class="line">514 = （51*1+1）+（5*10+4+1）+（0*100+100） = 207</span><br><span class="line">10 = (1*1)+(0*10+0+1) = 2</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> round = n;</span><br><span class="line">    <span class="keyword">while</span>(round&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> weight = round%<span class="number">10</span>;</span><br><span class="line">        round/=<span class="number">10</span>;</span><br><span class="line">        count += round*base;</span><br><span class="line">        <span class="keyword">if</span>(weight==<span class="number">1</span>)</span><br><span class="line">            count+=(n%base)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(weight&gt;<span class="number">1</span>)</span><br><span class="line">            count+=base;</span><br><span class="line">        base*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-30-数组排成最小的数"><a href="#2-30-数组排成最小的数" class="headerlink" title="2.30. 数组排成最小的数"></a>2.30. 数组排成最小的数</h3><p>归根结底是比较两个数谁排在前谁排在后的问题。设定规则：数a和数b，若ab&gt;ba，则a&gt;b，根据这个规则对数组进行排序。</p>
<h3 id="2-31-丑数列举"><a href="#2-31-丑数列举" class="headerlink" title="2.31. 丑数列举"></a>2.31. 丑数列举</h3><p>只有2,3,5作为因子组成的数。思想是一直保存这些整数，然后找后面紧邻的一个，紧邻的这个一定是前面的数乘以2,3,5得到，找一个最小的就行。</p>
<h3 id="2-32-第一个只出现一次的字符（abcdacd输出b）"><a href="#2-32-第一个只出现一次的字符（abcdacd输出b）" class="headerlink" title="2.32. 第一个只出现一次的字符（abcdacd输出b）"></a>2.32. 第一个只出现一次的字符（abcdacd输出b）</h3><p>使用hash表进行存储，ascii码表，256长度就够。key就是字符的ascii码值，value就是出现的次数，一次就是1，多次就是-1。</p>
<h3 id="2-33-数组中的逆序对"><a href="#2-33-数组中的逆序对" class="headerlink" title="2.33. 数组中的逆序对"></a>2.33. 数组中的逆序对</h3><p>归并排序思想</p>
<h3 id="2-34-遍历两个有公共节点的链表，找到这个连接点"><a href="#2-34-遍历两个有公共节点的链表，找到这个连接点" class="headerlink" title="2.34. 遍历两个有公共节点的链表，找到这个连接点"></a>2.34. 遍历两个有公共节点的链表，找到这个连接点</h3><p>两种思路，第一种使用两个辅助栈，入栈完毕后，同时出栈，直到最后两个相同的指针；第二种不使用辅助栈，遍历两遍两个链表，第一次确定长短，然后先在长链上走几步，之后齐头并进，直到找到相同的指针。</p>
<h3 id="2-35-数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）"><a href="#2-35-数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）" class="headerlink" title="2.35. 数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）"></a>2.35. 数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）</h3><p>基本思路是遍历，但是这并没有利用排序数组的优势。这里主要思想是使用二分查找的思想。查找两次，第一次找第一次出现的下标，第二次找最后一次出现的下标。第一次找的时候，如果中间值大于等于当前值，往左找（判断是不是第一个）。第二次找的时候反过来。</p>
<h3 id="2-36-二叉树的深度"><a href="#2-36-二叉树的深度" class="headerlink" title="2.36. 二叉树的深度"></a>2.36. 二叉树的深度</h3><p>递归思想</p>
<h3 id="2-37-判断是不是平衡二叉树（任意左右子树深度相差不超过1）"><a href="#2-37-判断是不是平衡二叉树（任意左右子树深度相差不超过1）" class="headerlink" title="2.37. 判断是不是平衡二叉树（任意左右子树深度相差不超过1）"></a>2.37. 判断是不是平衡二叉树（任意左右子树深度相差不超过1）</h3><p>不要直接递归左右子树找到深度然后比较，这样有节点多次被遍历。使用后序遍历，遍历时记录深度。</p>
<h3 id="2-38-数组中只出现一次的一个数字"><a href="#2-38-数组中只出现一次的一个数字" class="headerlink" title="2.38. 数组中只出现一次的一个数字"></a>2.38. 数组中只出现一次的一个数字</h3><p>异或一遍</p>
<h3 id="2-39-数组中只出现一次的两个数字"><a href="#2-39-数组中只出现一次的两个数字" class="headerlink" title="2.39. 数组中只出现一次的两个数字"></a>2.39. 数组中只出现一次的两个数字</h3><p>异或一遍，从结果中找到第一位不是0（是1）的位，假设为第n位。继续异或一遍，分成两个数组，第一个数组第n位都是1，第二个数组都是0。两个数组分别异或就找出来了。</p>
<h3 id="2-40-从数组中找到和为s的两个数字"><a href="#2-40-从数组中找到和为s的两个数字" class="headerlink" title="2.40. 从数组中找到和为s的两个数字"></a>2.40. 从数组中找到和为s的两个数字</h3><p>如果数组是递增的，那么两个指针，一个最前一个最后，如果两个指针的和小于s，那么第一个加一，若大于s，第二个减一。</p>
<h3 id="2-41-输出所有和为S的连续正数序列"><a href="#2-41-输出所有和为S的连续正数序列" class="headerlink" title="2.41. 输出所有和为S的连续正数序列"></a>2.41. 输出所有和为S的连续正数序列</h3><p>跟上面类似，两个指针，一个small，一个big，如果和大于sum，则small++，sum-=small,否则big++,sum+=big</p>
<h3 id="2-42-翻转单词顺序"><a href="#2-42-翻转单词顺序" class="headerlink" title="2.42. 翻转单词顺序"></a>2.42. 翻转单词顺序</h3><p>先整体翻转一次，然后每个单词再单独翻转一次。</p>
<h3 id="2-43-左旋转字符串（abcdef和数字2，输出cdefab）"><a href="#2-43-左旋转字符串（abcdef和数字2，输出cdefab）" class="headerlink" title="2.43. 左旋转字符串（abcdef和数字2，输出cdefab）"></a>2.43. 左旋转字符串（abcdef和数字2，输出cdefab）</h3><p>把字符串按照数字分成两部分，先每个部分翻转，然后整体翻转。跟上面的那道题很像的。</p>
<h3 id="2-44-n个骰子的点数（每种点数的概率）"><a href="#2-44-n个骰子的点数（每种点数的概率）" class="headerlink" title="2.44. n个骰子的点数（每种点数的概率）"></a>2.44. n个骰子的点数（每种点数的概率）</h3><p>数组存放n到6n。下标表示筛子数，对应的值表示出现的次数。一个骰子一个骰子的往上添加，第一个筛子都是1，第二个骰子的和为n的出现次数，是上一次骰子里面的n-1,n-2,n-3,n-4,n-5,n-6的和。</p>
<h3 id="2-45-扑克牌的顺子（取五张牌，判断是不是顺子）"><a href="#2-45-扑克牌的顺子（取五张牌，判断是不是顺子）" class="headerlink" title="2.45. 扑克牌的顺子（取五张牌，判断是不是顺子）"></a>2.45. 扑克牌的顺子（取五张牌，判断是不是顺子）</h3><p>先排序，然后看差几张，如果0能补上就没问题。</p>
<h3 id="2-46-圆圈中剩下的数字"><a href="#2-46-圆圈中剩下的数字" class="headerlink" title="2.46. 圆圈中剩下的数字"></a>2.46. 圆圈中剩下的数字</h3><p>关键在于通过映射，转换成新环，去发现规律，然后成为动态规划问题。（递归也可以）</p>
<h3 id="2-47-不用加减乘除做加法"><a href="#2-47-不用加减乘除做加法" class="headerlink" title="2.47. 不用加减乘除做加法"></a>2.47. 不用加减乘除做加法</h3><p>发散思维，使用二进制加法，先异或得到不进位的位。然后两个数求与再左移一位，得到进位的值。（第一个得到的数替换原数值1，第二个得到的数替换原数值2）。循环直到没有进位。</p>
<h3 id="2-48-两个面试案例"><a href="#2-48-两个面试案例" class="headerlink" title="2.48. 两个面试案例"></a>2.48. 两个面试案例</h3><ul>
<li>把字符串转换成整数：不要想当然一位多简单，要考虑多种边界条件</li>
<li>两个树节点的最低公共祖先  <ul>
<li>排序二叉树的话直接找第一个使得两个树节点分别小于和大于当前节点值就可以了-最简单</li>
<li>普通的树如果存在指向父节点的指针，就转换成了链表找第一个公共点</li>
<li>最普通树的话，解决方法就是深度（或者广度）优先找两条路径，然后记录下来进行对比。</li>
</ul>
</li>
</ul>
<h3 id="2-49-数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）"><a href="#2-49-数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）" class="headerlink" title="2.49. 数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）"></a>2.49. 数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）</h3><ul>
<li>最基本的方法是排序，然后找到重复的数字</li>
<li>第二种方法是观察数组的规律：由于数字都在0到n-1之间，所以正常情况下数字的下标应该和数字本身相等。因此我们遍历数组，从第一个开始，查看值与下标是否相等，如果不相等的话就把该数值a与下标为a的值进行比较，如果相等，则找到重复的数字，如果不相等就交换数值，也就是数值a归位了。如此循环直到遍历完成。由于每个数值最多两次操作就可以归位，因此时间复杂度O(1)</li>
</ul>
<h3 id="2-50-构建乘积数组（不能使用除法）"><a href="#2-50-构建乘积数组（不能使用除法）" class="headerlink" title="2.50. 构建乘积数组（不能使用除法）"></a>2.50. 构建乘积数组（不能使用除法）</h3><p>建立一个矩阵，然后使用两个辅助数组。</p>
<h3 id="2-51-字符串正则表达式匹配"><a href="#2-51-字符串正则表达式匹配" class="headerlink" title="2.51. 字符串正则表达式匹配"></a>2.51. 字符串正则表达式匹配</h3><p>使用递归的思想，两个指针，一个指向字符，一个指向模式。匹配后把后面的部分递归处理。主要问题是处理<code>*</code>的情况，指向字符的指针可以移动1次或两次或者不移动。</p>
<h3 id="2-52-链表中环的入口结点"><a href="#2-52-链表中环的入口结点" class="headerlink" title="2.52. 链表中环的入口结点"></a>2.52. 链表中环的入口结点</h3><p>分两步走，第一步确定环的数量，第二步两个指针，第一个指针先走n步(n就是环内结点数量)，然后两个指针齐头并进，相遇的时候就是入口结点。第一步确定环的数量，同样设定两个指针，第一个每次走一步，第二个每次走两步，相遇的时候就是在节点内。然后可以循环一次算出节点数。</p>
<h3 id="2-53-删除链表中重复的节点"><a href="#2-53-删除链表中重复的节点" class="headerlink" title="2.53. 删除链表中重复的节点"></a>2.53. 删除链表中重复的节点</h3><p>常规思路</p>
<h3 id="2-54-二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）"><a href="#2-54-二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）" class="headerlink" title="2.54. 二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）"></a>2.54. 二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）</h3><p>其实很简单，一步一步考虑算法就可以了。如果这个节点存在右节点，那么肯定就是右节点中序遍历的第一个值，如果这个节点不存在右节点，但是他是某个节点的左节点，那下一个节点就是他的父节点，如果他是父节点的右节点，就要向上去找父节点，直到找到一个父节点是它父节点的左子节点，那就是这个父节点了。</p>
<h3 id="2-55-对称的二叉树"><a href="#2-55-对称的二叉树" class="headerlink" title="2.55. 对称的二叉树"></a>2.55. 对称的二叉树</h3><p>把NULL节点的值也输出，这样如果后序遍历和从右开始的后序遍历输出结果一样的话就是对称的。</p>
<h3 id="2-56-二叉树打印成多行"><a href="#2-56-二叉树打印成多行" class="headerlink" title="2.56. 二叉树打印成多行"></a>2.56. 二叉树打印成多行</h3><p>如果每行都是从左到右或者从右到左的话，那就是典型的队列的问题。如果按照之字形打印，就使用两个栈。第一个栈存放偶数行的遍历结果，第二个栈存放奇数行的遍历结果，第一个栈都是先左节点后右节点，第二个栈反过来。</p>
<h3 id="2-57-序列化二叉树"><a href="#2-57-序列化二叉树" class="headerlink" title="2.57. 序列化二叉树"></a>2.57. 序列化二叉树</h3><p>进行带空指针输出的前向遍历。可以反推回来。</p>
<h3 id="2-58-二叉搜索树的第k个节点（第k大的节点）"><a href="#2-58-二叉搜索树的第k个节点（第k大的节点）" class="headerlink" title="2.58. 二叉搜索树的第k个节点（第k大的节点）"></a>2.58. 二叉搜索树的第k个节点（第k大的节点）</h3><p>中序遍历，一边遍历，一遍查找。</p>
<h3 id="2-59-数据流的中位数"><a href="#2-59-数据流的中位数" class="headerlink" title="2.59. 数据流的中位数"></a>2.59. 数据流的中位数</h3><p>使用两个堆，最大堆在左边，最小堆在右边，保证最大堆的每个值都小于最小堆的每个值。发生冲突就往该放的堆里放，然后从这个堆里挑出最大值或者最小值放到另外一个堆里。</p>
<h3 id="2-60-滑动窗口的最大值"><a href="#2-60-滑动窗口的最大值" class="headerlink" title="2.60. 滑动窗口的最大值"></a>2.60. 滑动窗口的最大值</h3><p>为了保证是O(n)复杂度，滑动窗口是用双向队列表示，里面只存储是最大值或者可能是下一个最大值的值。</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/02/notebook/ml_ai_ann/机器学习中距离和相似性度量方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiheng CHEN">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/timg.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="其鬼不神">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/02/notebook/ml_ai_ann/机器学习中距离和相似性度量方法/" itemprop="url">机器学习中距离和相似性度量方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-02T16:39:28+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/机器学习/" itemprop="url" rel="index">
                    <span itemprop="name">机器学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="机器学习中距离和相似性度量方法"><a href="#机器学习中距离和相似性度量方法" class="headerlink" title="机器学习中距离和相似性度量方法"></a>机器学习中距离和相似性度量方法</h1><p>声明：本文主要参考文章 <a href="http://dataunion.org/11710.html" target="_blank" rel="noopener">机器学习中距离和相似性度量方法</a></p>
<p>在机器学习和数据挖掘中，我们经常需要知道个体间差异的大小，进而评价个体的相似性和类别。最常见的是数据分析中的相关分析，数据挖掘中的分类和聚类算法，如 K 最近邻（KNN）和 K 均值（K-Means）等等。根据数据特性的不同，可以采用不同的度量方法。一般而言，定义一个距离函数 d(x,y), 需要满足下面几个准则：<br>1) d(x,x) = 0                    // 到自己的距离为0<br>2) d(x,y) &gt;= 0                  // 距离非负<br>3) d(x,y) = d(y,x)             // 对称性: 如果 A 到 B 距离是 a，那么 B 到 A 的距离也应该是 a<br>4) d(x,k)+ d(k,y) &gt;= d(x,y)    // 三角形法则: (两边之和大于第三边)</p>
<p>这篇博客主要介绍机器学习和数据挖掘中一些常见的距离公式，包括：<br><strong>闵可夫斯基距离、欧几里得距离、曼哈顿距离、切比雪夫距离、马氏距离、余弦相似度、皮尔逊相关系数、汉明距离、杰卡德相似系数、编辑距离、DTW距离、KL散度</strong></p>
<p>有时间再整理</p>
<h2 id="闵可夫斯基距离"><a href="#闵可夫斯基距离" class="headerlink" title="闵可夫斯基距离"></a>闵可夫斯基距离</h2><p>闵可夫斯基距离（Minkowski distance）是衡量数值点之间距离的一种非常常见的方法，假设数值点 P 和 Q 坐标如下：</p>
<div align="center"><img src="http://dataunion.org/wp-content/uploads/2015/03/07220422-b6c5a38eccb74824b92ba1b40c9dd92f.png" alt="figure1"></div>

<p>那么，闵可夫斯基距离定义为：</p>
<p><img src="http://dataunion.org/wp-content/uploads/2015/03/07220504-12655edb08dc45ae8a036d8028743042.png" alt="figure2"></p>
<p>该距离最常用的 p 是 2 和 1, 前者是欧几里得距离（Euclidean distance），后者是曼哈顿距离（Manhattan distance）。假设在曼哈顿街区乘坐出租车从 P 点到 Q 点，白色表示高楼大厦，灰色表示街道：</p>
<p>绿色的斜线表示欧几里得距离，在现实中是不可能的。其他三条折线表示了曼哈顿距离，这三条折线的长度是相等的。<br>当 p 趋近于无穷大时，闵可夫斯基距离转化成切比雪夫距离（Chebyshev distance）：</p>
<p>我们知道平面上到原点欧几里得距离（p = 2）为 1 的点所组成的形状是一个圆，当 p 取其他数值的时候呢？</p>
<p>注意，当 p &lt; 1 时，闵可夫斯基距离不再符合三角形法则，举个例子：当 p &lt; 1, (0,0) 到 (1,1) 的距离等于 (1+1)^{1/p} &gt; 2, 而 (0,1) 到这两个点的距离都是 1。<br>闵可夫斯基距离比较直观，但是它与数据的分布无关，具有一定的局限性，如果 x 方向的幅值远远大于 y 方向的值，这个距离公式就会过度放大 x 维度的作用。所以，在计算距离之前，我们可能还需要对数据进行 z-transform 处理，即减去均值，除以标准差：</p>
<p> : 该维度上的均值<br> : 该维度上的标准差<br>可以看到，上述处理开始体现数据的统计特性了。这种方法在假设数据各个维度不相关的情况下利用数据分布的特性计算出不同的距离。如果维度相互之间数据相关（例如：身高较高的信息很有可能会带来体重较重的信息，因为两者是有关联的），这时候就要用到马氏距离（Mahalanobis distance）了。</p>
<ol start="2">
<li>马氏距离<br>考虑下面这张图，椭圆表示等高线，从欧几里得的距离来算，绿黑距离大于红黑距离，但是从马氏距离，结果恰好相反：</li>
</ol>
<p>马氏距离实际上是利用 Cholesky transformation 来消除不同维度之间的相关性和尺度不同的性质。假设样本点（列向量）之间的协方差对称矩阵是  ， 通过 Cholesky Decomposition（实际上是对称矩阵 LU 分解的一种特殊形式，可参考之前的博客）可以转化为下三角矩阵和上三角矩阵的乘积：  。消除不同维度之间的相关性和尺度不同，只需要对样本点 x 做如下处理： 。处理之后的欧几里得距离就是原样本的马氏距离：为了书写方便，这里求马氏距离的平方）：</p>
<p>下图蓝色表示原样本点的分布，两颗红星坐标分别是（3, 3），（2, -2）:</p>
<p>由于 x， y 方向的尺度不同，不能单纯用欧几里得的方法测量它们到原点的距离。并且，由于 x 和 y 是相关的（大致可以看出斜向右上），也不能简单地在 x 和 y 方向上分别减去均值，除以标准差。最恰当的方法是对原始数据进行 Cholesky 变换，即求马氏距离（可以看到，右边的红星离原点较近）：</p>
<p>将上面两个图的绘制代码和求马氏距离的代码贴在这里，以备以后查阅：<br> View Code</p>
<p>马氏距离的变换和 PCA 分解的白化处理颇有异曲同工之妙，不同之处在于：就二维来看，PCA 是将数据主成分旋转到 x 轴（正交矩阵的酉变换），再在尺度上缩放（对角矩阵），实现尺度相同。而马氏距离的 L逆矩阵是一个下三角，先在 x 和 y 方向进行缩放，再在 y 方向进行错切（想象矩形变平行四边形），总体来说是一个没有旋转的仿射变换。</p>
<ol start="3">
<li>向量内积<br>向量内积是线性代数里最为常见的计算，实际上它还是一种有效并且直观的相似性测量手段。向量内积的定义如下：</li>
</ol>
<p>直观的解释是：如果 x 高的地方 y 也比较高， x 低的地方 y 也比较低，那么整体的内积是偏大的，也就是说 x 和 y 是相似的。举个例子，在一段长的序列信号 A 中寻找哪一段与短序列信号 a 最匹配，只需要将 a 从 A 信号开头逐个向后平移，每次平移做一次内积，内积最大的相似度最大。信号处理中 DFT 和 DCT 也是基于这种内积运算计算出不同频域内的信号组分（DFT 和 DCT 是正交标准基，也可以看做投影）。向量和信号都是离散值，如果是连续的函数值，比如求区间[-1, 1] 两个函数之间的相似度，同样也可以得到（系数）组分，这种方法可以应用于多项式逼近连续函数，也可以用到连续函数逼近离散样本点（最小二乘问题，OLS coefficients）中，扯得有点远了- -!。<br>向量内积的结果是没有界限的，一种解决办法是除以长度之后再求内积，这就是应用十分广泛的余弦相似度（Cosine similarity）：</p>
<p>余弦相似度与向量的幅值无关，只与向量的方向相关，在文档相似度（TF-IDF）和图片相似性（histogram）计算上都有它的身影。需要注意一点的是，余弦相似度受到向量的平移影响，上式如果将 x 平移到 x+1, 余弦值就会改变。怎样才能实现平移不变性？这就是下面要说的皮尔逊相关系数（Pearson correlation），有时候也直接叫相关系数:</p>
<p>皮尔逊相关系数具有平移不变性和尺度不变性，计算出了两个向量（维度）的相关性。不过，一般我们在谈论相关系数的时候，将 x 与 y 对应位置的两个数值看作一个样本点，皮尔逊系数用来表示这些样本点分布的相关性。</p>
<p>由于皮尔逊系数具有的良好性质，在各个领域都应用广泛，例如，在推荐系统根据为某一用户查找喜好相似的用户,进而提供推荐，优点是可以不受每个用户评分标准不同和观看影片数量不一样的影响。</p>
<ol start="4">
<li>分类数据点间的距离<br>汉明距离（Hamming distance）是指，两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。举个维基百科上的例子：</li>
</ol>
<p>还可以用简单的匹配系数来表示两点之间的相似度——匹配字符数/总字符数。<br>在一些情况下，某些特定的值相等并不能代表什么。举个例子，用 1 表示用户看过该电影，用 0 表示用户没有看过，那么用户看电影的的信息就可用 0,1 表示成一个序列。考虑到电影基数非常庞大，用户看过的电影只占其中非常小的一部分，如果两个用户都没有看过某一部电影（两个都是 0），并不能说明两者相似。反而言之，如果两个用户都看过某一部电影（序列中都是 1），则说明用户有很大的相似度。在这个例子中，序列中等于 1 所占的权重应该远远大于 0 的权重，这就引出下面要说的杰卡德相似系数（Jaccard similarity）。<br>在上面的例子中，用 M11 表示两个用户都看过的电影数目，M10 表示用户 A 看过，用户 B 没看过的电影数目，M01 表示用户 A 没看过，用户 B 看过的电影数目，M00 表示两个用户都没有看过的电影数目。Jaccard 相似性系数可以表示为：</p>
<p>Jaccard similarity 还可以用集合的公式来表达，这里就不多说了。<br>如果分类数值点是用树形结构来表示的，它们的相似性可以用相同路径的长度来表示，比如，“/product/spot/ballgame/basketball” 离“product/spot/ballgame/soccer/shoes” 的距离小于到 “/product/luxury/handbags” 的距离，以为前者相同父节点路径更长。</p>
<ol start="5">
<li>序列之间的距离<br>上一小节我们知道，汉明距离可以度量两个长度相同的字符串之间的相似度，如果要比较两个不同长度的字符串，不仅要进行替换，而且要进行插入与删除的运算，在这种场合下，通常使用更加复杂的编辑距离（Edit distance, Levenshtein distance）等算法。编辑距离是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。编辑距离求的是最少编辑次数，这是一个动态规划的问题，有兴趣的同学可以自己研究研究。<br>时间序列是序列之间距离的另外一个例子。DTW 距离（Dynamic Time Warp）是序列信号在时间或者速度上不匹配的时候一种衡量相似度的方法。神马意思？举个例子，两份原本一样声音样本A、B都说了“你好”，A在时间上发生了扭曲，“你”这个音延长了几秒。最后A:“你~~~好”，B：“你好”。DTW正是这样一种可以用来匹配A、B之间的最短距离的算法。<br>DTW 距离在保持信号先后顺序的限制下对时间信号进行“膨胀”或者“收缩”，找到最优的匹配，与编辑距离相似，这其实也是一个动态规划的问题:</li>
</ol>
<p>实现代码（转自 McKelvin’s Blog ）:<br> View Code</p>
<ol start="6">
<li>概率分布之间的距离<br>前面我们谈论的都是两个数值点之间的距离，实际上两个概率分布之间的距离是可以测量的。在统计学里面经常需要测量两组样本分布之间的距离，进而判断出它们是否出自同一个 population，常见的方法有卡方检验（Chi-Square）和 KL 散度（ KL-Divergence），下面说一说 KL 散度吧。<br>先从信息熵说起，假设一篇文章的标题叫做“黑洞到底吃什么”，包含词语分别是 {黑洞, 到底, 吃什么}, 我们现在要根据一个词语推测这篇文章的类别。哪个词语给予我们的信息最多？很容易就知道是“黑洞”，因为“黑洞”这个词语在所有的文档中出现的概率太低啦，一旦出现，就表明这篇文章很可能是在讲科普知识。而其他两个词语“到底”和“吃什么”出现的概率很高，给予我们的信息反而越少。如何用一个函数 h(x) 表示词语给予的信息量呢？第一，肯定是与 p(x) 相关，并且是负相关。第二，假设 x 和 y 是独立的（黑洞和宇宙不相互独立，谈到黑洞必然会说宇宙）,即 p(x,y) = p(x)p(y), 那么获得的信息也是叠加的，即 h(x, y) = h(x) + h(y)。满足这两个条件的函数肯定是负对数形式：</li>
</ol>
<p>对假设一个发送者要将随机变量 X 产生的一长串随机值传送给接收者， 接受者获得的平均信息量就是求它的数学期望：</p>
<p>这就是熵的概念。另外一个重要特点是，熵的大小与字符平均最短编码长度是一样的（shannon）。设有一个未知的分布 p(x), 而 q(x) 是我们所获得的一个对 p(x) 的近似，按照 q(x) 对该随机变量的各个值进行编码，平均长度比按照真实分布的 p(x) 进行编码要额外长一些，多出来的长度这就是 KL 散度（之所以不说距离，是因为不满足对称性和三角形法则），即：</p>
<p>KL 散度又叫相对熵（relative entropy）。了解机器学习的童鞋应该都知道，在 Softmax 回归（或者 Logistic 回归），最后的输出节点上的值表示这个样本分到该类的概率，这就是一个概率分布。对于一个带有标签的样本，我们期望的概率分布是：分到标签类的概率是 1， 其他类概率是 0。但是理想很丰满，现实很骨感，我们不可能得到完美的概率输出，能做的就是尽量减小总样本的 KL 散度之和（目标函数）。这就是 Softmax 回归或者 Logistic 回归中 Cost function 的优化过程啦。（PS：因为概率和为 1，一般的 logistic 二分类的图只画了一个输出节点，隐藏了另外一个）</p>
<p>待补充的方法：<br>卡方检验 Chi-Square<br>衡量 categorical attributes 相关性的 mutual information<br>Spearman’s rank coefficient<br>Earth Mover’s Distance<br>SimRank 迭代算法等。</p>
<p>参考资料：<br>距离和相似性度量<br>Machine Learning: Measuring Similarity and Distance<br>What is Mahalanobis distance?<br>Cosine similarity, Pearson correlation, and OLS coefficients<br>机器学习中的相似性度量<br>动态时间归整 | DTW | Dynamic Time Warping</p>

          
        
      
    </div>
    
    
    
    <div>
      
    </div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/timg.jpg"
                alt="Kaiheng CHEN" />
            
              <p class="site-author-name" itemprop="name">Kaiheng CHEN</p>
              <p class="site-description motion-element" itemprop="description">道莅天下，其鬼不神</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/chen-kh" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhongfajean@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kaiheng CHEN</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>


  <span class="post-meta-divider">|</span>

<div class="powered-by">
<i class="fa fa-user-md"></i>
  <span id="busuanzi_container_site_uv">
    本站访客数:<span id="busuanzi_value_site_uv"></span>
  </span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_pv">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
</div>

  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
