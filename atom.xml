<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>其鬼不神</title>
  
  <subtitle>ACT北航愣头青的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-07T12:57:09.673Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kaiheng CHEN</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode 题目与总结</title>
    <link href="http://yoursite.com/2018/04/07/notebook/offer/leetcode/"/>
    <id>http://yoursite.com/2018/04/07/notebook/offer/leetcode/</id>
    <published>2018-04-07T12:54:24.014Z</published>
    <updated>2018-04-07T12:57:09.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-题目与总结"><a href="#leetcode-题目与总结" class="headerlink" title="leetcode 题目与总结"></a>leetcode 题目与总结</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="前序遍历（递归、非递归）"><a href="#前序遍历（递归、非递归）" class="headerlink" title="前序遍历（递归、非递归）"></a>前序遍历（递归、非递归）</h3><p>递归版本是最基本的了。非递归的版本需要使用stack来保存访问的路径。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        <span class="comment">// preorderTraversalIter(root,list);</span></span><br><span class="line">        <span class="comment">// method 2</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop().right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversalIter</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            preorderTraversalIter(root.left, list);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            preorderTraversalIter(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="中序遍历（递归、非递归）"><a href="#中序遍历（递归、非递归）" class="headerlink" title="中序遍历（递归、非递归）"></a>中序遍历（递归、非递归）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        <span class="comment">// inorderTraversalIter(root,list);</span></span><br><span class="line">        <span class="comment">// method 2</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderTraversalIter</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                inorderTraversalIter(root.left, list);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                inorderTraversalIter(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历（递归、非递归）"><a href="#后序遍历（递归、非递归）" class="headerlink" title="后序遍历（递归、非递归）"></a>后序遍历（递归、非递归）</h3><p>后序遍历其实是镜像+颠倒版的前序遍历。使用右先前序遍历（先访问右节点）思想，最后倒着输出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        <span class="comment">// postorderTraversalIter(root,list);</span></span><br><span class="line">        <span class="comment">// method 2</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                list.add(<span class="number">0</span>, root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderTraversalIter</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                postorderTraversalIter(root.left, list);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                postorderTraversalIter(root.right, list);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="层次遍历与层次输出"><a href="#层次遍历与层次输出" class="headerlink" title="层次遍历与层次输出"></a>层次遍历与层次输出</h3><p>层次遍历很简单，使用队列辅助就行了。但是如何进行层次输出呢？这就是102号题目：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a>。思路如下。</p><p>思路1：递归。设置level记录层数。每进行一次子节点访问，层数加1。不同层用不同list存储。具体见代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, levelList, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> levelList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;List&lt;Integer&gt;&gt; levelList, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (levelList.size() &lt;= level) &#123;</span><br><span class="line">            levelList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        levelList.get(level).add(node.val);</span><br><span class="line">        helper(node.left, levelList, level+<span class="number">1</span>);</span><br><span class="line">        helper(node.right, levelList, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路2：迭代。记录上下两层的数量。使用队列进行存储，但是记录前一层和当前层分别有多少个节点被存储了。当前一层还剩下0个节点的时候，存储成新的list。详见代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> preCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curCount=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            preCount++;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                preCount--;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    curCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    curCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(preCount == <span class="number">0</span>)&#123;</span><br><span class="line">                    lists.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">                    list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    preCount = curCount;</span><br><span class="line">                    curCount = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路3：迭代。双队列，第一个队列存储已经访问过的上一层的节点值，第二个队列存储当前访问层的节点值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Queue&lt;TreeNode&gt; temp=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            queue=temp;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;leetcode-题目与总结&quot;&gt;&lt;a href=&quot;#leetcode-题目与总结&quot; class=&quot;headerlink&quot; title=&quot;leetcode 题目与总结&quot;&gt;&lt;/a&gt;leetcode 题目与总结&lt;/h1&gt;&lt;h2 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉
      
    
    </summary>
    
      <category term="offer" scheme="http://yoursite.com/categories/offer/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/offer/leetcode/"/>
    
    
      <category term="offer" scheme="http://yoursite.com/tags/offer/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>操作系统随笔</title>
    <link href="http://yoursite.com/2018/04/02/notebook/linux%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os/%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2018/04/02/notebook/linux和操作系统/os/随笔/</id>
    <published>2018-04-02T09:13:51.992Z</published>
    <updated>2018-04-02T09:13:51.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统随笔"><a href="#操作系统随笔" class="headerlink" title="操作系统随笔"></a>操作系统随笔</h1><!-- TOC --><ul><li><a href="#1-锁的概念以及死锁的概念">1. 锁的概念以及死锁的概念</a></li><li><a href="#2-计算机ip保留地址">2. 计算机IP保留地址</a></li></ul><!-- /TOC --><h2 id="1-锁的概念以及死锁的概念"><a href="#1-锁的概念以及死锁的概念" class="headerlink" title="1. 锁的概念以及死锁的概念"></a>1. 锁的概念以及死锁的概念</h2><ul><li><p>牛客网参考答案：<a href="https://www.nowcoder.com/ta/review-java/review?page=16" target="_blank" rel="noopener">JAVA面试常考知识点：page16</a></p><blockquote><p>所谓死锁是指多个进 程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：</p><ul><li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。</li></ul></blockquote></li><li><p>如何解决死锁问题</p></li></ul><p>目标就是破坏产生死锁的四个条件，一般最后一个条件比较容易破坏，也就是所有锁的需求都是按照一定顺序来的。可参考：<a href="https://www.jianshu.com/p/44125bb12ebf" target="_blank" rel="noopener">死锁是什么？如何避免死锁？</a></p><h2 id="2-计算机IP保留地址"><a href="#2-计算机IP保留地址" class="headerlink" title="2. 计算机IP保留地址"></a>2. 计算机IP保留地址</h2><p>参考文章：<a href="http://www.cnblogs.com/ZJoy/archive/2011/03/24/1994308.html" target="_blank" rel="noopener">IP地址中的保留地址</a><br>根据用途和安全性级别的不同，IP地址还可以大致分为两类：公共地址和私有地址。</p><ul><li>公用地址在Internet中使用，可以在Internet中随意访问。</li><li>私有地址只能在内部网络中使用，只有通过代理服务器才能与Internet通信。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统随笔&quot;&gt;&lt;a href=&quot;#操作系统随笔&quot; class=&quot;headerlink&quot; title=&quot;操作系统随笔&quot;&gt;&lt;/a&gt;操作系统随笔&lt;/h1&gt;&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-锁的概念以及死锁的概念&quot;&gt;1. 锁的概念以及死
      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>各种排序方法的简单总结</title>
    <link href="http://yoursite.com/2018/04/02/notebook/data_struc_algo/sortsummary/"/>
    <id>http://yoursite.com/2018/04/02/notebook/data_struc_algo/sortsummary/</id>
    <published>2018-04-02T09:13:51.939Z</published>
    <updated>2018-04-02T09:13:51.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种排序方法的简单总结"><a href="#各种排序方法的简单总结" class="headerlink" title="各种排序方法的简单总结"></a>各种排序方法的简单总结</h1><p>排序算法算是计算机的经典算法，解决很多问题的时候排序算法的思想都值得参考。<br><!-- TOC --></p><ul><li><a href="#1-快速排序的思想">1. 快速排序的思想</a></li><li><a href="#2-归并排序的思想">2. 归并排序的思想</a></li><li><a href="#3-堆排序的思路">3. 堆排序的思路</a></li></ul><!-- /TOC --><h2 id="1-快速排序的思想"><a href="#1-快速排序的思想" class="headerlink" title="1. 快速排序的思想"></a>1. 快速排序的思想</h2><p>学习容易记住的快排算法过程（Partition函数式最重要的，有两种写法，一种高效，另一种普通，参考<a href="http://selfboot.cn/2016/09/01/lost_partition/" target="_blank" rel="noopener">这里</a>）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main sort function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start == end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> index = partition(arr, len, start, end);</span><br><span class="line">print_arr(arr, len);</span><br><span class="line"><span class="keyword">if</span>(index &gt; start)</span><br><span class="line">qsort(arr, len, start, index - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(index &lt; end)</span><br><span class="line">qsort(arr, len, index + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition function 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr == <span class="literal">NULL</span> || start &lt; <span class="number">0</span> || end &lt; <span class="number">0</span> || end &gt;= len || end &lt; start)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"partition input invalid\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[end];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = start; i &lt; end; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; pivot)&#123;</span><br><span class="line">small++;</span><br><span class="line"><span class="keyword">if</span>(i != small)</span><br><span class="line">swap(&amp;arr[small], &amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">small++;</span><br><span class="line">swap(&amp;arr[small], &amp;arr[end]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition function which is more efficient</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr == <span class="literal">NULL</span> || start &lt; <span class="number">0</span> || end &lt; <span class="number">0</span> || end &gt;= len || end &lt; start)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"partition input invalid\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[end];</span><br><span class="line">start--;</span><br><span class="line"><span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line"><span class="keyword">while</span>(start &lt; end &amp;&amp; arr[++start] &lt;= pivot);</span><br><span class="line">arr[end] = arr[start];</span><br><span class="line"><span class="keyword">while</span>(start &lt; end &amp;&amp; arr[--end] &gt;= pivot);</span><br><span class="line">arr[start] = arr[end];</span><br><span class="line">&#125;</span><br><span class="line">arr[start] = pivot;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-归并排序的思想"><a href="#2-归并排序的思想" class="headerlink" title="2. 归并排序的思想"></a>2. 归并排序的思想</h2><p>归并排序就是将数组分成两个部分，然后分别对两个部分进行排序，然后再融合起来。可以递归实现，算法时间复杂度时O(nlogn)，空间复杂度O(n)，也就是需要辅助空间。</p><h2 id="3-堆排序的思路"><a href="#3-堆排序的思路" class="headerlink" title="3. 堆排序的思路"></a>3. 堆排序的思路</h2><p>参考：<a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法 - 堆排序 (Heap Sort)</a></p><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p><ul><li>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</li><li>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>最大堆调整（MAX‐HEAPIFY）的作用是保持最大堆的性质，是创建最大堆的核心子程序。下面是Java版本的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/* 堆排序的思路：</span></span><br><span class="line"><span class="comment"> * 1. 首先明确堆是一种数据结构，利用堆这种数据结构的特性可以很高效地做排序算法。</span></span><br><span class="line"><span class="comment"> * 2. 第一步：堆化。将原本不是堆结构的数组转换成堆，方法时从第一个不是叶节点的节点开始，到根节点，进行堆化操作。堆化操作就是数字的上浮和下沉，要注意的是下沉要彻底，也就是需要递归或者迭代处理下沉的点。</span></span><br><span class="line"><span class="comment"> * 3. 第二步：排序。以最大堆为例，堆顶（也就是树结构的根节点，也就是数组第一个元素）存的是最大值，堆顶元素与最末尾叶节点交换，交换后堆就不是最大堆了，需要重新调整，但是调整的时候就不管最后一个元素了，所以堆的长度减少1。循环此过程直到堆内只剩下一个元素。排序完成。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSortWiki</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeapSortWiki</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.arr = arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序的主要入口方法，共两步。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第一步：将数组堆化 beginIndex = 第一个非叶子节点。 从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment"> * 叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> beginIndex = (len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = beginIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">maxHeapify(i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第二步：对堆化数据排序 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span></span><br><span class="line"><span class="comment"> * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。 直至未排序的堆长度为 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">swap(<span class="number">0</span>, i);</span><br><span class="line">maxHeapify(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整索引为 index 处的数据，使其符合堆的特性。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> *            需要堆化处理的数据的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment"> *            未排序的堆（数组）的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> li = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line"><span class="keyword">int</span> ri = li + <span class="number">1</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line"><span class="keyword">int</span> cMax = li; <span class="comment">// 子节点值最大索引，默认左子节点。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (li &gt; len)</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 左子节点索引超出计算范围，直接返回。</span></span><br><span class="line"><span class="keyword">if</span> (ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) <span class="comment">// 先判断左右子节点，哪个较大。</span></span><br><span class="line">cMax = ri;</span><br><span class="line"><span class="keyword">if</span> (arr[cMax] &gt; arr[index]) &#123;</span><br><span class="line">swap(cMax, index); <span class="comment">// 如果父节点被子节点调换，</span></span><br><span class="line">maxHeapify(cMax, len); <span class="comment">// 则需要继续判断换下后的父节点是否符合堆的特性。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试用例</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输出： [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7,</span></span><br><span class="line"><span class="comment"> * 7, 8, 8, 8, 9, 9, 9]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">new</span> HeapSortWiki(arr).sort();</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;各种排序方法的简单总结&quot;&gt;&lt;a href=&quot;#各种排序方法的简单总结&quot; class=&quot;headerlink&quot; title=&quot;各种排序方法的简单总结&quot;&gt;&lt;/a&gt;各种排序方法的简单总结&lt;/h1&gt;&lt;p&gt;排序算法算是计算机的经典算法，解决很多问题的时候排序算法的思想都值得
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法随笔</title>
    <link href="http://yoursite.com/2018/04/02/notebook/data_struc_algo/data%20structure/"/>
    <id>http://yoursite.com/2018/04/02/notebook/data_struc_algo/data structure/</id>
    <published>2018-04-02T09:13:51.937Z</published>
    <updated>2018-04-02T09:13:51.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Struture-Note"><a href="#Data-Struture-Note" class="headerlink" title="Data Struture Note"></a>Data Struture Note</h1><!-- TOC --><ul><li><a href="#1-如何解决hash冲突有哪几种方案">1. 如何解决<code>hash</code>冲突，有哪几种方案</a><ul><li><a href="#11-开放定址法">1.1. 开放定址法</a></li><li><a href="#12-链地址法拉链法">1.2. 链地址法（拉链法）</a></li><li><a href="#13-再哈希法">1.3. 再哈希法</a></li><li><a href="#14-建立公共溢出区">1.4. 建立公共溢出区</a></li></ul></li></ul><!-- /TOC --><h2 id="1-如何解决hash冲突，有哪几种方案"><a href="#1-如何解决hash冲突，有哪几种方案" class="headerlink" title="1. 如何解决hash冲突，有哪几种方案"></a>1. 如何解决<code>hash</code>冲突，有哪几种方案</h2><p>参考：<a href="https://www.jianshu.com/p/4d3cb99d7580" target="_blank" rel="noopener">解决哈希冲突的常用方法分析</a></p><h3 id="1-1-开放定址法"><a href="#1-1-开放定址法" class="headerlink" title="1.1. 开放定址法"></a>1.1. 开放定址法</h3><ul><li>线性探查法：找到下一个有空的位置放进去，查找的时候遍历（其实也可以有一个辅助的数组专门记录移动的位置），这个方法容易出现“聚集”的现象</li><li>平方探查法：二次探测法的地址增量序列为 di = 12， -12， 22， -22，… ， q2, -q2 (q &lt;= m/2)。二次探测能有效避免“聚集”现象，但是不能够探测到哈希表上所有的存储单元，但是至少能够探测到一半。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</li><li>双散列函数探查法： hp (key)若h(key)出现冲突，则再使用hp (key)求取散列地址。探查序列为：<code>h(k), h(k)+ hp(k),…, h((k)+ i*hp(k))</code>。</li></ul><h3 id="1-2-链地址法（拉链法）"><a href="#1-2-链地址法（拉链法）" class="headerlink" title="1.2. 链地址法（拉链法）"></a>1.2. 链地址法（拉链法）</h3><p><code>Java</code>中<code>HashMap</code>的经典实现算法。</p><h3 id="1-3-再哈希法"><a href="#1-3-再哈希法" class="headerlink" title="1.3. 再哈希法"></a>1.3. 再哈希法</h3><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。</p><h3 id="1-4-建立公共溢出区"><a href="#1-4-建立公共溢出区" class="headerlink" title="1.4. 建立公共溢出区"></a>1.4. 建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Data-Struture-Note&quot;&gt;&lt;a href=&quot;#Data-Struture-Note&quot; class=&quot;headerlink&quot; title=&quot;Data Struture Note&quot;&gt;&lt;/a&gt;Data Struture Note&lt;/h1&gt;&lt;!-- TOC 
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>面试随笔</title>
    <link href="http://yoursite.com/2018/04/02/notebook/offer/%E9%9D%A2%E8%AF%95%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2018/04/02/notebook/offer/面试随笔/</id>
    <published>2018-04-02T08:39:28.014Z</published>
    <updated>2018-04-02T09:13:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试随笔"><a href="#面试随笔" class="headerlink" title="面试随笔"></a>面试随笔</h1><p>记录一些在面试过程中遇到的问题</p><!-- TOC --><ul><li><a href="#1-程序lang掉无响应">1. 程序lang掉（无响应）</a></li><li><a href="#3-网易的两道题">3. 网易的两道题</a><ul><li><a href="#31-符合nk的数对有多少种">3.1. 符合n，k的数对有多少种</a></li><li><a href="#32-有多少种装法">3.2. 有多少种装法</a></li></ul></li><li><a href="#腾讯面试题">腾讯面试题</a><ul><li><a href="#带符号大数加减">带符号大数加减</a></li></ul></li></ul><!-- /TOC --><h2 id="1-程序lang掉（无响应）"><a href="#1-程序lang掉（无响应）" class="headerlink" title="1. 程序lang掉（无响应）"></a>1. 程序lang掉（无响应）</h2><h2 id="3-网易的两道题"><a href="#3-网易的两道题" class="headerlink" title="3. 网易的两道题"></a>3. 网易的两道题</h2><h3 id="3-1-符合n，k的数对有多少种"><a href="#3-1-符合n，k的数对有多少种" class="headerlink" title="3.1. 符合n，k的数对有多少种"></a>3.1. 符合n，k的数对有多少种</h3><h3 id="3-2-有多少种装法"><a href="#3-2-有多少种装法" class="headerlink" title="3.2. 有多少种装法"></a>3.2. 有多少种装法</h3><h2 id="腾讯面试题"><a href="#腾讯面试题" class="headerlink" title="腾讯面试题"></a>腾讯面试题</h2><h3 id="带符号大数加减"><a href="#带符号大数加减" class="headerlink" title="带符号大数加减"></a>带符号大数加减</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试随笔&quot;&gt;&lt;a href=&quot;#面试随笔&quot; class=&quot;headerlink&quot; title=&quot;面试随笔&quot;&gt;&lt;/a&gt;面试随笔&lt;/h1&gt;&lt;p&gt;记录一些在面试过程中遇到的问题&lt;/p&gt;
&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-程序lang掉无
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/04/02/notebook/offer/%E6%89%BE%E5%AE%9E%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%E4%B8%8E%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/04/02/notebook/offer/找实习笔记整理与记录/</id>
    <published>2018-04-02T08:39:28.013Z</published>
    <updated>2018-04-02T08:39:28.014Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需要准备的考点"><a href="#需要准备的考点" class="headerlink" title="需要准备的考点"></a>需要准备的考点</h1><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h2 id="网络（TCP，UDP）等"><a href="#网络（TCP，UDP）等" class="headerlink" title="网络（TCP，UDP）等"></a>网络（TCP，UDP）等</h2><h2 id="Java语言"><a href="#Java语言" class="headerlink" title="Java语言"></a>Java语言</h2><h2 id="Python语言"><a href="#Python语言" class="headerlink" title="Python语言"></a>Python语言</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h2 id="分布式系统构建"><a href="#分布式系统构建" class="headerlink" title="分布式系统构建"></a>分布式系统构建</h2><ul><li>Kafka</li><li>JStorm</li><li>Memcached</li><li>Hadoop</li><li>Spark</li><li>HBase<h2 id="关于项目的几个问题"><a href="#关于项目的几个问题" class="headerlink" title="关于项目的几个问题"></a>关于项目的几个问题</h2></li></ul><ol><li>项目为什么使用Postgresql开发？</li><li>你在项目中主要负责做什么？</li></ol><ul><li>数据入关系数据库pg</li><li>数据入分布式内存数据库memcached</li><li>系统分布式架构的运行与维护</li></ul><ol start="2"><li>项目的不足是什么？</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;需要准备的考点&quot;&gt;&lt;a href=&quot;#需要准备的考点&quot; class=&quot;headerlink&quot; title=&quot;需要准备的考点&quot;&gt;&lt;/a&gt;需要准备的考点&lt;/h1&gt;&lt;h2 id=&quot;数据结构与算法&quot;&gt;&lt;a href=&quot;#数据结构与算法&quot; class=&quot;headerlink
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>剑指offer阅读笔记</title>
    <link href="http://yoursite.com/2018/04/02/notebook/offer/%E5%89%91%E6%8C%87offer%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/02/notebook/offer/剑指offer阅读笔记/</id>
    <published>2018-04-02T08:39:28.012Z</published>
    <updated>2018-04-07T12:54:24.016Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指offer阅读笔记"><a href="#剑指offer阅读笔记" class="headerlink" title="剑指offer阅读笔记"></a>剑指offer阅读笔记</h1><!-- TOC --><ul><li><a href="#1-面试需要注意的内容">1. 面试需要注意的内容</a></li><li><a href="#2-编程题">2. 编程题</a><ul><li><a href="#21-从链表中查找倒数第k个值">2.1. 从链表中查找倒数第k个值</a></li><li><a href="#22-从矩阵从左到右从上到下依次增大中查找某值">2.2. 从矩阵（从左到右，从上到下依次增大）中查找某值</a></li><li><a href="#23-字符串替换">2.3. 字符串替换</a></li><li><a href="#24-链表在不改变结构的情况下倒着输出">2.4. 链表在不改变结构的情况下倒着输出</a></li><li><a href="#25-根据前序遍历和中序遍历的结果重建一棵树">2.5. 根据前序遍历和中序遍历的结果重建一棵树</a></li><li><a href="#26-用两个栈实现队列">2.6. 用两个栈实现队列</a></li><li><a href="#27-旋转数组的最小数字">2.7. 旋转数组的最小数字</a></li><li><a href="#28-二进制中1的个数">2.8. 二进制中1的个数</a></li><li><a href="#29-数值的整数次方">2.9. 数值的整数次方</a></li><li><a href="#210-打印1到最大的n位数">2.10. 打印1到最大的n位数</a></li><li><a href="#211-在o1时间删除链表节点">2.11. 在O(1)时间删除链表节点</a></li><li><a href="#212-调整数组顺序使得奇数位于偶数前面">2.12. 调整数组顺序使得奇数位于偶数前面</a></li><li><a href="#213-反转链表">2.13. 反转链表</a></li><li><a href="#214-合并两个排序的链表">2.14. 合并两个排序的链表</a></li><li><a href="#215-树的子结构">2.15. 树的子结构</a></li><li><a href="#216-二叉树的镜像">2.16. 二叉树的镜像</a></li><li><a href="#217-顺时针打印矩阵">2.17. 顺时针打印矩阵</a></li><li><a href="#218-包含min函数的栈">2.18. 包含min函数的栈</a></li><li><a href="#219-栈的压入和弹出顺序匹配">2.19. 栈的压入和弹出顺序匹配</a></li><li><a href="#220-从上往下打印二叉树">2.20. 从上往下打印二叉树</a></li><li><a href="#221-二叉搜索树的后序遍历序列判断给定数组是不是一颗二叉搜索树的后序遍历序列">2.21. 二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）</a></li><li><a href="#222-二叉树中和为某值的路径直到叶节点">2.22. 二叉树中和为某值的路径（直到叶节点）</a></li><li><a href="#223-复杂链表的复制">2.23. 复杂链表的复制</a></li><li><a href="#224-二叉搜索树改为双向链表只调整树中节点指针的指向">2.24. 二叉搜索树改为双向链表（只调整树中节点指针的指向）</a></li><li><a href="#225-字符串的排列">2.25. 字符串的排列</a></li><li><a href="#226-数组中出现次数超过一半的数字">2.26. 数组中出现次数超过一半的数字</a></li><li><a href="#227-最小的k个数">2.27. 最小的k个数</a></li><li><a href="#228-连续子数组最大和">2.28. 连续子数组最大和</a></li><li><a href="#229-从1到n中1出现的次数">2.29. 从1到n中1出现的次数</a></li><li><a href="#230-数组排成最小的数">2.30. 数组排成最小的数</a></li><li><a href="#231-丑数列举">2.31. 丑数列举</a></li><li><a href="#232-第一个只出现一次的字符abcdacd输出b">2.32. 第一个只出现一次的字符（abcdacd输出b）</a></li><li><a href="#233-数组中的逆序对">2.33. 数组中的逆序对</a></li><li><a href="#234-遍历两个有公共节点的链表找到这个连接点">2.34. 遍历两个有公共节点的链表，找到这个连接点</a></li><li><a href="#235-数字在排序数组中出现的次数给定数组和数字输出数字在数组中出现的次数">2.35. 数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）</a></li><li><a href="#236-二叉树的深度">2.36. 二叉树的深度</a></li><li><a href="#237-判断是不是平衡二叉树任意左右子树深度相差不超过1">2.37. 判断是不是平衡二叉树（任意左右子树深度相差不超过1）</a></li><li><a href="#238-数组中只出现一次的一个数字">2.38. 数组中只出现一次的一个数字</a></li><li><a href="#239-数组中只出现一次的两个数字">2.39. 数组中只出现一次的两个数字</a></li><li><a href="#240-从数组中找到和为s的两个数字">2.40. 从数组中找到和为s的两个数字</a></li><li><a href="#241-输出所有和为s的连续正数序列">2.41. 输出所有和为S的连续正数序列</a></li><li><a href="#242-翻转单词顺序">2.42. 翻转单词顺序</a></li><li><a href="#243-左旋转字符串abcdef和数字2输出cdefab">2.43. 左旋转字符串（abcdef和数字2，输出cdefab）</a></li><li><a href="#244-n个骰子的点数每种点数的概率">2.44. n个骰子的点数（每种点数的概率）</a></li><li><a href="#245-扑克牌的顺子取五张牌判断是不是顺子">2.45. 扑克牌的顺子（取五张牌，判断是不是顺子）</a></li><li><a href="#246-圆圈中剩下的数字">2.46. 圆圈中剩下的数字</a></li><li><a href="#247-不用加减乘除做加法">2.47. 不用加减乘除做加法</a></li><li><a href="#248-两个面试案例">2.48. 两个面试案例</a></li><li><a href="#249-数组中重复的数字长度为n的数组并且数字都在0到n-1之间">2.49. 数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）</a></li><li><a href="#250-构建乘积数组不能使用除法">2.50. 构建乘积数组（不能使用除法）</a></li><li><a href="#251-字符串正则表达式匹配">2.51. 字符串正则表达式匹配</a></li><li><a href="#252-链表中环的入口结点">2.52. 链表中环的入口结点</a></li><li><a href="#253-删除链表中重复的节点">2.53. 删除链表中重复的节点</a></li><li><a href="#254-二叉树的下一个节点数中存在指向父节点的指针找到中序遍历的下一个节点">2.54. 二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）</a></li><li><a href="#255-对称的二叉树">2.55. 对称的二叉树</a></li><li><a href="#256-二叉树打印成多行">2.56. 二叉树打印成多行</a></li><li><a href="#257-序列化二叉树">2.57. 序列化二叉树</a></li><li><a href="#258-二叉搜索树的第k个节点第k大的节点">2.58. 二叉搜索树的第k个节点（第k大的节点）</a></li><li><a href="#259-数据流的中位数">2.59. 数据流的中位数</a></li><li><a href="#260-滑动窗口的最大值">2.60. 滑动窗口的最大值</a></li></ul></li></ul><!-- /TOC --><h2 id="1-面试需要注意的内容"><a href="#1-面试需要注意的内容" class="headerlink" title="1. 面试需要注意的内容"></a>1. 面试需要注意的内容</h2><ul><li>准备几个问题问面试官（根据公司、职位等等）</li><li>介绍自己做过的项目：简短的项目背景、完成的任务、未完成任务自己做了哪些方面的工作（以及怎么做的）、总结自己的贡献与收获</li><li>扎实的基础知识与高质量的代码：命名与缩进习惯，<strong>边界条件（boundary condition）的考虑</strong>，优化效率的能力，<strong>不合规范的输入的处理</strong>等等。</li></ul><h2 id="2-编程题"><a href="#2-编程题" class="headerlink" title="2. 编程题"></a>2. 编程题</h2><h3 id="2-1-从链表中查找倒数第k个值"><a href="#2-1-从链表中查找倒数第k个值" class="headerlink" title="2.1. 从链表中查找倒数第k个值"></a>2.1. 从链表中查找倒数第k个值</h3><p>两个指针，但是注意边界条件。</p><h3 id="2-2-从矩阵（从左到右，从上到下依次增大）中查找某值"><a href="#2-2-从矩阵（从左到右，从上到下依次增大）中查找某值" class="headerlink" title="2.2. 从矩阵（从左到右，从上到下依次增大）中查找某值"></a>2.2. 从矩阵（从左到右，从上到下依次增大）中查找某值</h3><p>从右往左入手选定列，在从上往下入手选定行。</p><h3 id="2-3-字符串替换"><a href="#2-3-字符串替换" class="headerlink" title="2.3. 字符串替换"></a>2.3. 字符串替换</h3><p>将原本一个字符换成多个字符时，注意从右往左（减少移动次数），同样类型的还有归并排序(两个排好序的数组，并且第二个数组后面有足够的空间方数据)，从后往前排。</p><h3 id="2-4-链表在不改变结构的情况下倒着输出"><a href="#2-4-链表在不改变结构的情况下倒着输出" class="headerlink" title="2.4. 链表在不改变结构的情况下倒着输出"></a>2.4. 链表在不改变结构的情况下倒着输出</h3><p>使用栈或者用递归的方法</p><h3 id="2-5-根据前序遍历和中序遍历的结果重建一棵树"><a href="#2-5-根据前序遍历和中序遍历的结果重建一棵树" class="headerlink" title="2.5. 根据前序遍历和中序遍历的结果重建一棵树"></a>2.5. 根据前序遍历和中序遍历的结果重建一棵树</h3><p>前序遍历第一个都是根节点，中序遍历中间的也是根节点；思路为：取前序第一个，已知为根节点，然后在中序遍历中找到这个值，这个值左边的部分是根节点的左子树（数量为n）的中序遍历结果，右边的部分是根节点的右子树（数量为m）的中序遍历结果，相对应于前序遍历（去掉第一个）结果，前n个为左子树的前序遍历结果，后m个为右子树的前序遍历结果。递归。</p><h3 id="2-6-用两个栈实现队列"><a href="#2-6-用两个栈实现队列" class="headerlink" title="2.6. 用两个栈实现队列"></a>2.6. 用两个栈实现队列</h3><p>根据栈和队列的不同（栈先进后出，队列先进先出）。栈1用来实际入栈，栈2用来实际出栈，实现方式：为当需要进栈的时候，数据进入栈1，当需要出栈的时候，查看栈2是否为空，如果为空，则从栈1将所有数据出栈并入到栈2。</p><h3 id="2-7-旋转数组的最小数字"><a href="#2-7-旋转数组的最小数字" class="headerlink" title="2.7. 旋转数组的最小数字"></a>2.7. 旋转数组的最小数字</h3><p>使用二分查找的思想。设定两个指针p1和p2，若p1与p2相邻则取p2。若<code>p1&lt;p2</code>，取中间指针p3，若p3大于p1，则最小数字在p3到p2间，否则在p1到p3间。</p><h3 id="2-8-二进制中1的个数"><a href="#2-8-二进制中1的个数" class="headerlink" title="2.8. 二进制中1的个数"></a>2.8. 二进制中1的个数</h3><p>注意负数在二进制中最高位是1，如果使用<code>&gt;&gt;</code>进行移位操作，为了保证还是负数，不会改变最高位。两种方法，使用数字1进行二进制与操作，然后把1左移一位<code>&lt;&lt; 1</code>，继续与，直到结果为0。第二种方法，注意到整数a，与a-1进行与操作可以逐步消去最右端的1。</p><h3 id="2-9-数值的整数次方"><a href="#2-9-数值的整数次方" class="headerlink" title="2.9. 数值的整数次方"></a>2.9. 数值的整数次方</h3><p>注意整数次方，这里的整数还包含0和负数。还要注意对输入值的是否和法判断，判断两个double类型的数据是否相等不能直接使用<code>==</code>，而应该用差很小来表示。同时考虑整数次方，一次一次的相乘不够快，可以除以二然后相乘，也就是递归了。</p><h3 id="2-10-打印1到最大的n位数"><a href="#2-10-打印1到最大的n位数" class="headerlink" title="2.10. 打印1到最大的n位数"></a>2.10. 打印1到最大的n位数</h3><p>注意这里的n位数是否会是大数问题。可以打印全排列，使用递归思想，另外打印的时候注意前面是0的话就不要打印了。</p><h3 id="2-11-在O-1-时间删除链表节点"><a href="#2-11-在O-1-时间删除链表节点" class="headerlink" title="2.11. 在O(1)时间删除链表节点"></a>2.11. 在O(1)时间删除链表节点</h3><p>假设这个节点是node2delete，可以把node2delete.nextNode的值赋值给node2.delete，然后让node2delete指向下下个节点。</p><h3 id="2-12-调整数组顺序使得奇数位于偶数前面"><a href="#2-12-调整数组顺序使得奇数位于偶数前面" class="headerlink" title="2.12. 调整数组顺序使得奇数位于偶数前面"></a>2.12. 调整数组顺序使得奇数位于偶数前面</h3><p>主要思想是快排里面的Partition思想，只不过是左边找偶数，右边找奇数。通过拓展条件（使用函数），这一思想适用于更多场景。</p><h3 id="2-13-反转链表"><a href="#2-13-反转链表" class="headerlink" title="2.13. 反转链表"></a>2.13. 反转链表</h3><p>记录3个指针，分别代表<code>pNodeCurrent, pNodePrev, pReversedHead</code>。注意考虑输入为NULL以及链表的断裂情况</p><h3 id="2-14-合并两个排序的链表"><a href="#2-14-合并两个排序的链表" class="headerlink" title="2.14. 合并两个排序的链表"></a>2.14. 合并两个排序的链表</h3><p>基本同上</p><h3 id="2-15-树的子结构"><a href="#2-15-树的子结构" class="headerlink" title="2.15. 树的子结构"></a>2.15. 树的子结构</h3><p>递归查找匹配</p><h3 id="2-16-二叉树的镜像"><a href="#2-16-二叉树的镜像" class="headerlink" title="2.16. 二叉树的镜像"></a>2.16. 二叉树的镜像</h3><p>递归交换左右子树</p><h3 id="2-17-顺时针打印矩阵"><a href="#2-17-顺时针打印矩阵" class="headerlink" title="2.17. 顺时针打印矩阵"></a>2.17. 顺时针打印矩阵</h3><p>打印每一圈都分四步。主要是注意最后一圈可能退化成只有一行或者只有一列。这样打印最后一圈可能只需要3,2,1步。</p><h3 id="2-18-包含min函数的栈"><a href="#2-18-包含min函数的栈" class="headerlink" title="2.18. 包含min函数的栈"></a>2.18. 包含min函数的栈</h3><p>使用辅助栈记录每一个数据进栈之后更新的最小值</p><h3 id="2-19-栈的压入和弹出顺序匹配"><a href="#2-19-栈的压入和弹出顺序匹配" class="headerlink" title="2.19. 栈的压入和弹出顺序匹配"></a>2.19. 栈的压入和弹出顺序匹配</h3><p>栈的经典题目</p><h3 id="2-20-从上往下打印二叉树"><a href="#2-20-从上往下打印二叉树" class="headerlink" title="2.20. 从上往下打印二叉树"></a>2.20. 从上往下打印二叉树</h3><p>使用队列，每从队列中出一个节点，同时把节点的左右节点的值入队列。</p><h3 id="2-21-二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）"><a href="#2-21-二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）" class="headerlink" title="2.21. 二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）"></a>2.21. 二叉搜索树的后序遍历序列（判断给定数组是不是一颗二叉搜索树的后序遍历序列）</h3><p>注意后序遍历的特点，根节点的值在最后面，而且是根节点的左子树遍历结果都小于根节点，右子树比那里结果都大于根节点。选定根节点，将前面的n-1个值切分为2部分，小于根节点值的是左子树，大于根节点值的是右子树。递归。</p><h3 id="2-22-二叉树中和为某值的路径（直到叶节点）"><a href="#2-22-二叉树中和为某值的路径（直到叶节点）" class="headerlink" title="2.22. 二叉树中和为某值的路径（直到叶节点）"></a>2.22. 二叉树中和为某值的路径（直到叶节点）</h3><p>其实是二叉树深度优先遍历的变种。每次递归完成之后都要返回父节点。</p><h3 id="2-23-复杂链表的复制"><a href="#2-23-复杂链表的复制" class="headerlink" title="2.23. 复杂链表的复制"></a>2.23. 复杂链表的复制</h3><p>举例子：原链表:<code>a-&gt;b-&gt;c-&gt;d</code>，先复制成<code>a-a&#39;-&gt;b-&gt;b&#39;-&gt;c-&gt;c&#39;-&gt;d-&gt;d&#39;</code>。然后挪动复杂指针一位就行。之后再分开。</p><h3 id="2-24-二叉搜索树改为双向链表（只调整树中节点指针的指向）"><a href="#2-24-二叉搜索树改为双向链表（只调整树中节点指针的指向）" class="headerlink" title="2.24. 二叉搜索树改为双向链表（只调整树中节点指针的指向）"></a>2.24. 二叉搜索树改为双向链表（只调整树中节点指针的指向）</h3><p>中序遍历思想。<a href="https://github.com/chen-kh/InterviewQuestions/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%9827%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8_ConvertBinarySearchTree.cpp" target="_blank" rel="noopener">戳这里查看代码详细</a></p><h3 id="2-25-字符串的排列"><a href="#2-25-字符串的排列" class="headerlink" title="2.25. 字符串的排列"></a>2.25. 字符串的排列</h3><p>主要思想是使用递归，然后把字符串排列看作两种情况：第一种是第一个是a，第二种是第一个不是a。第二种的得到就是把a和后面的每个字符进行互换操作得到。因此可以递归了。<a href="https://github.com/chen-kh/InterviewQuestions/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%9828%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97_StringPermutation.cpp" target="_blank" rel="noopener">戳这里查看代码详细</a></p><h3 id="2-26-数组中出现次数超过一半的数字"><a href="#2-26-数组中出现次数超过一半的数字" class="headerlink" title="2.26. 数组中出现次数超过一半的数字"></a>2.26. 数组中出现次数超过一半的数字</h3><p>解法一：基于快排的思想，更改partition函数，复杂度O(n)。跟找第k大的数是一样的，我们这次找第n/2个数。</p><p>解法二：根据数组特点完成算法，时间复杂度也是O(n)。保存两个变量<code>currentValue</code>和<code>preValue</code>，二者相同则加1，不同则减1。最有一个使得值为1的书就是超过一半的数字。</p><h3 id="2-27-最小的k个数"><a href="#2-27-最小的k个数" class="headerlink" title="2.27. 最小的k个数"></a>2.27. 最小的k个数</h3><p>解法一：基于快排的思想，知道随机找的数字最终落在了k位上。跟第k小数字如出一辙，复杂度O(n)</p><p>解法二：使用最小堆。需要堆或者红黑树来进行辅助。但是适用于大量数据的处理。复杂度O(nlogk)</p><h3 id="2-28-连续子数组最大和"><a href="#2-28-连续子数组最大和" class="headerlink" title="2.28. 连续子数组最大和"></a>2.28. 连续子数组最大和</h3><p>经典动态规划</p><h3 id="2-29-从1到n中1出现的次数"><a href="#2-29-从1到n中1出现的次数" class="headerlink" title="2.29. 从1到n中1出现的次数"></a>2.29. 从1到n中1出现的次数</h3><p>解法一：比较复杂。举例子说明。n=21345，（1-21345）转换为（1-1345）+（1346-21345），只处理第二部分，第一部分用相同的方法递归求解。第二部分分为（1346-11345）和（11346-21345），最高位出现1的次数10000次，最高位之外出现1的次数，固定一位，则其他位任意，<code>2*4*1000=8000</code>次。</p><p>解法二：<a href="https://blog.csdn.net/yi_afly/article/details/52012593" target="_blank" rel="noopener">详情戳这里</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">534 = （个位1出现次数）+（十位1出现次数）+（百位1出现次数）=（53*1+1）+（5*10+10）+（0*100+100）= 214</span><br><span class="line">530 = （53*1）+（5*10+10）+（0*100+100） = 213</span><br><span class="line">504 = （50*1+1）+（5*10）+（0*100+100） = 201</span><br><span class="line">514 = （51*1+1）+（5*10+4+1）+（0*100+100） = 207</span><br><span class="line">10 = (1*1)+(0*10+0+1) = 2</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> base = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> round = n;</span><br><span class="line">    <span class="keyword">while</span>(round&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> weight = round%<span class="number">10</span>;</span><br><span class="line">        round/=<span class="number">10</span>;</span><br><span class="line">        count += round*base;</span><br><span class="line">        <span class="keyword">if</span>(weight==<span class="number">1</span>)</span><br><span class="line">            count+=(n%base)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(weight&gt;<span class="number">1</span>)</span><br><span class="line">            count+=base;</span><br><span class="line">        base*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-30-数组排成最小的数"><a href="#2-30-数组排成最小的数" class="headerlink" title="2.30. 数组排成最小的数"></a>2.30. 数组排成最小的数</h3><p>归根结底是比较两个数谁排在前谁排在后的问题。设定规则：数a和数b，若ab&gt;ba，则a&gt;b，根据这个规则对数组进行排序。</p><h3 id="2-31-丑数列举"><a href="#2-31-丑数列举" class="headerlink" title="2.31. 丑数列举"></a>2.31. 丑数列举</h3><p>只有2,3,5作为因子组成的数。思想是一直保存这些整数，然后找后面紧邻的一个，紧邻的这个一定是前面的数乘以2,3,5得到，找一个最小的就行。</p><h3 id="2-32-第一个只出现一次的字符（abcdacd输出b）"><a href="#2-32-第一个只出现一次的字符（abcdacd输出b）" class="headerlink" title="2.32. 第一个只出现一次的字符（abcdacd输出b）"></a>2.32. 第一个只出现一次的字符（abcdacd输出b）</h3><p>使用hash表进行存储，ascii码表，256长度就够。key就是字符的ascii码值，value就是出现的次数，一次就是1，多次就是-1。</p><h3 id="2-33-数组中的逆序对"><a href="#2-33-数组中的逆序对" class="headerlink" title="2.33. 数组中的逆序对"></a>2.33. 数组中的逆序对</h3><p>归并排序思想</p><h3 id="2-34-遍历两个有公共节点的链表，找到这个连接点"><a href="#2-34-遍历两个有公共节点的链表，找到这个连接点" class="headerlink" title="2.34. 遍历两个有公共节点的链表，找到这个连接点"></a>2.34. 遍历两个有公共节点的链表，找到这个连接点</h3><p>两种思路，第一种使用两个辅助栈，入栈完毕后，同时出栈，直到最后两个相同的指针；第二种不使用辅助栈，遍历两遍两个链表，第一次确定长短，然后先在长链上走几步，之后齐头并进，直到找到相同的指针。</p><h3 id="2-35-数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）"><a href="#2-35-数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）" class="headerlink" title="2.35. 数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）"></a>2.35. 数字在排序数组中出现的次数（给定数组和数字，输出数字在数组中出现的次数）</h3><p>基本思路是遍历，但是这并没有利用排序数组的优势。这里主要思想是使用二分查找的思想。查找两次，第一次找第一次出现的下标，第二次找最后一次出现的下标。第一次找的时候，如果中间值大于等于当前值，往左找（判断是不是第一个）。第二次找的时候反过来。</p><h3 id="2-36-二叉树的深度"><a href="#2-36-二叉树的深度" class="headerlink" title="2.36. 二叉树的深度"></a>2.36. 二叉树的深度</h3><p>递归思想</p><h3 id="2-37-判断是不是平衡二叉树（任意左右子树深度相差不超过1）"><a href="#2-37-判断是不是平衡二叉树（任意左右子树深度相差不超过1）" class="headerlink" title="2.37. 判断是不是平衡二叉树（任意左右子树深度相差不超过1）"></a>2.37. 判断是不是平衡二叉树（任意左右子树深度相差不超过1）</h3><p>不要直接递归左右子树找到深度然后比较，这样有节点多次被遍历。使用后序遍历，遍历时记录深度。</p><h3 id="2-38-数组中只出现一次的一个数字"><a href="#2-38-数组中只出现一次的一个数字" class="headerlink" title="2.38. 数组中只出现一次的一个数字"></a>2.38. 数组中只出现一次的一个数字</h3><p>异或一遍</p><h3 id="2-39-数组中只出现一次的两个数字"><a href="#2-39-数组中只出现一次的两个数字" class="headerlink" title="2.39. 数组中只出现一次的两个数字"></a>2.39. 数组中只出现一次的两个数字</h3><p>异或一遍，从结果中找到第一位不是0（是1）的位，假设为第n位。继续异或一遍，分成两个数组，第一个数组第n位都是1，第二个数组都是0。两个数组分别异或就找出来了。</p><h3 id="2-40-从数组中找到和为s的两个数字"><a href="#2-40-从数组中找到和为s的两个数字" class="headerlink" title="2.40. 从数组中找到和为s的两个数字"></a>2.40. 从数组中找到和为s的两个数字</h3><p>如果数组是递增的，那么两个指针，一个最前一个最后，如果两个指针的和小于s，那么第一个加一，若大于s，第二个减一。</p><h3 id="2-41-输出所有和为S的连续正数序列"><a href="#2-41-输出所有和为S的连续正数序列" class="headerlink" title="2.41. 输出所有和为S的连续正数序列"></a>2.41. 输出所有和为S的连续正数序列</h3><p>跟上面类似，两个指针，一个small，一个big，如果和大于sum，则small++，sum-=small,否则big++,sum+=big</p><h3 id="2-42-翻转单词顺序"><a href="#2-42-翻转单词顺序" class="headerlink" title="2.42. 翻转单词顺序"></a>2.42. 翻转单词顺序</h3><p>先整体翻转一次，然后每个单词再单独翻转一次。</p><h3 id="2-43-左旋转字符串（abcdef和数字2，输出cdefab）"><a href="#2-43-左旋转字符串（abcdef和数字2，输出cdefab）" class="headerlink" title="2.43. 左旋转字符串（abcdef和数字2，输出cdefab）"></a>2.43. 左旋转字符串（abcdef和数字2，输出cdefab）</h3><p>把字符串按照数字分成两部分，先每个部分翻转，然后整体翻转。跟上面的那道题很像的。</p><h3 id="2-44-n个骰子的点数（每种点数的概率）"><a href="#2-44-n个骰子的点数（每种点数的概率）" class="headerlink" title="2.44. n个骰子的点数（每种点数的概率）"></a>2.44. n个骰子的点数（每种点数的概率）</h3><p>数组存放n到6n。下标表示筛子数，对应的值表示出现的次数。一个骰子一个骰子的往上添加，第一个筛子都是1，第二个骰子的和为n的出现次数，是上一次骰子里面的n-1,n-2,n-3,n-4,n-5,n-6的和。</p><h3 id="2-45-扑克牌的顺子（取五张牌，判断是不是顺子）"><a href="#2-45-扑克牌的顺子（取五张牌，判断是不是顺子）" class="headerlink" title="2.45. 扑克牌的顺子（取五张牌，判断是不是顺子）"></a>2.45. 扑克牌的顺子（取五张牌，判断是不是顺子）</h3><p>先排序，然后看差几张，如果0能补上就没问题。</p><h3 id="2-46-圆圈中剩下的数字"><a href="#2-46-圆圈中剩下的数字" class="headerlink" title="2.46. 圆圈中剩下的数字"></a>2.46. 圆圈中剩下的数字</h3><p>关键在于通过映射，转换成新环，去发现规律，然后成为动态规划问题。（递归也可以）</p><h3 id="2-47-不用加减乘除做加法"><a href="#2-47-不用加减乘除做加法" class="headerlink" title="2.47. 不用加减乘除做加法"></a>2.47. 不用加减乘除做加法</h3><p>发散思维，使用二进制加法，先异或得到不进位的位。然后两个数求与再左移一位，得到进位的值。（第一个得到的数替换原数值1，第二个得到的数替换原数值2）。循环直到没有进位。</p><h3 id="2-48-两个面试案例"><a href="#2-48-两个面试案例" class="headerlink" title="2.48. 两个面试案例"></a>2.48. 两个面试案例</h3><ul><li>把字符串转换成整数：不要想当然一位多简单，要考虑多种边界条件</li><li>两个树节点的最低公共祖先  <ul><li>排序二叉树的话直接找第一个使得两个树节点分别小于和大于当前节点值就可以了-最简单</li><li>普通的树如果存在指向父节点的指针，就转换成了链表找第一个公共点</li><li>最普通树的话，解决方法就是深度（或者广度）优先找两条路径，然后记录下来进行对比。</li></ul></li></ul><h3 id="2-49-数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）"><a href="#2-49-数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）" class="headerlink" title="2.49. 数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）"></a>2.49. 数组中重复的数字（长度为n的数组，并且数字都在0到n-1之间）</h3><ul><li>最基本的方法是排序，然后找到重复的数字</li><li>第二种方法是观察数组的规律：由于数字都在0到n-1之间，所以正常情况下数字的下标应该和数字本身相等。因此我们遍历数组，从第一个开始，查看值与下标是否相等，如果不相等的话就把该数值a与下标为a的值进行比较，如果相等，则找到重复的数字，如果不相等就交换数值，也就是数值a归位了。如此循环直到遍历完成。由于每个数值最多两次操作就可以归位，因此时间复杂度O(1)</li></ul><h3 id="2-50-构建乘积数组（不能使用除法）"><a href="#2-50-构建乘积数组（不能使用除法）" class="headerlink" title="2.50. 构建乘积数组（不能使用除法）"></a>2.50. 构建乘积数组（不能使用除法）</h3><p>建立一个矩阵，然后使用两个辅助数组。</p><h3 id="2-51-字符串正则表达式匹配"><a href="#2-51-字符串正则表达式匹配" class="headerlink" title="2.51. 字符串正则表达式匹配"></a>2.51. 字符串正则表达式匹配</h3><p>使用递归的思想，两个指针，一个指向字符，一个指向模式。匹配后把后面的部分递归处理。主要问题是处理<code>*</code>的情况，指向字符的指针可以移动1次或两次或者不移动。</p><h3 id="2-52-链表中环的入口结点"><a href="#2-52-链表中环的入口结点" class="headerlink" title="2.52. 链表中环的入口结点"></a>2.52. 链表中环的入口结点</h3><p>分两步走，第一步确定环的数量，第二步两个指针，第一个指针先走n步(n就是环内结点数量)，然后两个指针齐头并进，相遇的时候就是入口结点。第一步确定环的数量，同样设定两个指针，第一个每次走一步，第二个每次走两步，相遇的时候就是在节点内。然后可以循环一次算出节点数。</p><h3 id="2-53-删除链表中重复的节点"><a href="#2-53-删除链表中重复的节点" class="headerlink" title="2.53. 删除链表中重复的节点"></a>2.53. 删除链表中重复的节点</h3><p>常规思路</p><h3 id="2-54-二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）"><a href="#2-54-二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）" class="headerlink" title="2.54. 二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）"></a>2.54. 二叉树的下一个节点（数中存在指向父节点的指针，找到中序遍历的下一个节点）</h3><p>其实很简单，一步一步考虑算法就可以了。如果这个节点存在右节点，那么肯定就是右节点中序遍历的第一个值，如果这个节点不存在右节点，但是他是某个节点的左节点，那下一个节点就是他的父节点，如果他是父节点的右节点，就要向上去找父节点，直到找到一个父节点是它父节点的左子节点，那就是这个父节点了。</p><h3 id="2-55-对称的二叉树"><a href="#2-55-对称的二叉树" class="headerlink" title="2.55. 对称的二叉树"></a>2.55. 对称的二叉树</h3><p>把NULL节点的值也输出，这样如果后序遍历和从右开始的后序遍历输出结果一样的话就是对称的。</p><h3 id="2-56-二叉树打印成多行"><a href="#2-56-二叉树打印成多行" class="headerlink" title="2.56. 二叉树打印成多行"></a>2.56. 二叉树打印成多行</h3><p>如果每行都是从左到右或者从右到左的话，那就是典型的队列的问题。如果按照之字形打印，就使用两个栈。第一个栈存放偶数行的遍历结果，第二个栈存放奇数行的遍历结果，第一个栈都是先左节点后右节点，第二个栈反过来。</p><h3 id="2-57-序列化二叉树"><a href="#2-57-序列化二叉树" class="headerlink" title="2.57. 序列化二叉树"></a>2.57. 序列化二叉树</h3><p>进行带空指针输出的前向遍历。可以反推回来。</p><h3 id="2-58-二叉搜索树的第k个节点（第k大的节点）"><a href="#2-58-二叉搜索树的第k个节点（第k大的节点）" class="headerlink" title="2.58. 二叉搜索树的第k个节点（第k大的节点）"></a>2.58. 二叉搜索树的第k个节点（第k大的节点）</h3><p>中序遍历，一边遍历，一遍查找。</p><h3 id="2-59-数据流的中位数"><a href="#2-59-数据流的中位数" class="headerlink" title="2.59. 数据流的中位数"></a>2.59. 数据流的中位数</h3><p>使用两个堆，最大堆在左边，最小堆在右边，保证最大堆的每个值都小于最小堆的每个值。发生冲突就往该放的堆里放，然后从这个堆里挑出最大值或者最小值放到另外一个堆里。</p><h3 id="2-60-滑动窗口的最大值"><a href="#2-60-滑动窗口的最大值" class="headerlink" title="2.60. 滑动窗口的最大值"></a>2.60. 滑动窗口的最大值</h3><p>为了保证是O(n)复杂度，滑动窗口是用双向队列表示，里面只存储是最大值或者可能是下一个最大值的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;剑指offer阅读笔记&quot;&gt;&lt;a href=&quot;#剑指offer阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;剑指offer阅读笔记&quot;&gt;&lt;/a&gt;剑指offer阅读笔记&lt;/h1&gt;&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-面试需
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="剑指offer" scheme="http://yoursite.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中距离和相似性度量方法</title>
    <link href="http://yoursite.com/2018/04/02/notebook/ml_ai_ann/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E8%B7%9D%E7%A6%BB%E5%92%8C%E7%9B%B8%E4%BC%BC%E6%80%A7%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/02/notebook/ml_ai_ann/机器学习中距离和相似性度量方法/</id>
    <published>2018-04-02T08:39:28.008Z</published>
    <updated>2018-04-02T09:13:51.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习中距离和相似性度量方法"><a href="#机器学习中距离和相似性度量方法" class="headerlink" title="机器学习中距离和相似性度量方法"></a>机器学习中距离和相似性度量方法</h1><p>声明：本文主要参考文章 <a href="http://dataunion.org/11710.html" target="_blank" rel="noopener">机器学习中距离和相似性度量方法</a></p><p>在机器学习和数据挖掘中，我们经常需要知道个体间差异的大小，进而评价个体的相似性和类别。最常见的是数据分析中的相关分析，数据挖掘中的分类和聚类算法，如 K 最近邻（KNN）和 K 均值（K-Means）等等。根据数据特性的不同，可以采用不同的度量方法。一般而言，定义一个距离函数 d(x,y), 需要满足下面几个准则：<br>1) d(x,x) = 0                    // 到自己的距离为0<br>2) d(x,y) &gt;= 0                  // 距离非负<br>3) d(x,y) = d(y,x)             // 对称性: 如果 A 到 B 距离是 a，那么 B 到 A 的距离也应该是 a<br>4) d(x,k)+ d(k,y) &gt;= d(x,y)    // 三角形法则: (两边之和大于第三边)</p><p>这篇博客主要介绍机器学习和数据挖掘中一些常见的距离公式，包括：<br><strong>闵可夫斯基距离、欧几里得距离、曼哈顿距离、切比雪夫距离、马氏距离、余弦相似度、皮尔逊相关系数、汉明距离、杰卡德相似系数、编辑距离、DTW距离、KL散度</strong></p><p>有时间再整理</p><h2 id="闵可夫斯基距离"><a href="#闵可夫斯基距离" class="headerlink" title="闵可夫斯基距离"></a>闵可夫斯基距离</h2><p>闵可夫斯基距离（Minkowski distance）是衡量数值点之间距离的一种非常常见的方法，假设数值点 P 和 Q 坐标如下：</p><div align="center"><img src="http://dataunion.org/wp-content/uploads/2015/03/07220422-b6c5a38eccb74824b92ba1b40c9dd92f.png" alt="figure1"></div><p>那么，闵可夫斯基距离定义为：</p><p><img src="http://dataunion.org/wp-content/uploads/2015/03/07220504-12655edb08dc45ae8a036d8028743042.png" alt="figure2"></p><p>该距离最常用的 p 是 2 和 1, 前者是欧几里得距离（Euclidean distance），后者是曼哈顿距离（Manhattan distance）。假设在曼哈顿街区乘坐出租车从 P 点到 Q 点，白色表示高楼大厦，灰色表示街道：</p><p>绿色的斜线表示欧几里得距离，在现实中是不可能的。其他三条折线表示了曼哈顿距离，这三条折线的长度是相等的。<br>当 p 趋近于无穷大时，闵可夫斯基距离转化成切比雪夫距离（Chebyshev distance）：</p><p>我们知道平面上到原点欧几里得距离（p = 2）为 1 的点所组成的形状是一个圆，当 p 取其他数值的时候呢？</p><p>注意，当 p &lt; 1 时，闵可夫斯基距离不再符合三角形法则，举个例子：当 p &lt; 1, (0,0) 到 (1,1) 的距离等于 (1+1)^{1/p} &gt; 2, 而 (0,1) 到这两个点的距离都是 1。<br>闵可夫斯基距离比较直观，但是它与数据的分布无关，具有一定的局限性，如果 x 方向的幅值远远大于 y 方向的值，这个距离公式就会过度放大 x 维度的作用。所以，在计算距离之前，我们可能还需要对数据进行 z-transform 处理，即减去均值，除以标准差：</p><p> : 该维度上的均值<br> : 该维度上的标准差<br>可以看到，上述处理开始体现数据的统计特性了。这种方法在假设数据各个维度不相关的情况下利用数据分布的特性计算出不同的距离。如果维度相互之间数据相关（例如：身高较高的信息很有可能会带来体重较重的信息，因为两者是有关联的），这时候就要用到马氏距离（Mahalanobis distance）了。</p><ol start="2"><li>马氏距离<br>考虑下面这张图，椭圆表示等高线，从欧几里得的距离来算，绿黑距离大于红黑距离，但是从马氏距离，结果恰好相反：</li></ol><p>马氏距离实际上是利用 Cholesky transformation 来消除不同维度之间的相关性和尺度不同的性质。假设样本点（列向量）之间的协方差对称矩阵是  ， 通过 Cholesky Decomposition（实际上是对称矩阵 LU 分解的一种特殊形式，可参考之前的博客）可以转化为下三角矩阵和上三角矩阵的乘积：  。消除不同维度之间的相关性和尺度不同，只需要对样本点 x 做如下处理： 。处理之后的欧几里得距离就是原样本的马氏距离：为了书写方便，这里求马氏距离的平方）：</p><p>下图蓝色表示原样本点的分布，两颗红星坐标分别是（3, 3），（2, -2）:</p><p>由于 x， y 方向的尺度不同，不能单纯用欧几里得的方法测量它们到原点的距离。并且，由于 x 和 y 是相关的（大致可以看出斜向右上），也不能简单地在 x 和 y 方向上分别减去均值，除以标准差。最恰当的方法是对原始数据进行 Cholesky 变换，即求马氏距离（可以看到，右边的红星离原点较近）：</p><p>将上面两个图的绘制代码和求马氏距离的代码贴在这里，以备以后查阅：<br> View Code</p><p>马氏距离的变换和 PCA 分解的白化处理颇有异曲同工之妙，不同之处在于：就二维来看，PCA 是将数据主成分旋转到 x 轴（正交矩阵的酉变换），再在尺度上缩放（对角矩阵），实现尺度相同。而马氏距离的 L逆矩阵是一个下三角，先在 x 和 y 方向进行缩放，再在 y 方向进行错切（想象矩形变平行四边形），总体来说是一个没有旋转的仿射变换。</p><ol start="3"><li>向量内积<br>向量内积是线性代数里最为常见的计算，实际上它还是一种有效并且直观的相似性测量手段。向量内积的定义如下：</li></ol><p>直观的解释是：如果 x 高的地方 y 也比较高， x 低的地方 y 也比较低，那么整体的内积是偏大的，也就是说 x 和 y 是相似的。举个例子，在一段长的序列信号 A 中寻找哪一段与短序列信号 a 最匹配，只需要将 a 从 A 信号开头逐个向后平移，每次平移做一次内积，内积最大的相似度最大。信号处理中 DFT 和 DCT 也是基于这种内积运算计算出不同频域内的信号组分（DFT 和 DCT 是正交标准基，也可以看做投影）。向量和信号都是离散值，如果是连续的函数值，比如求区间[-1, 1] 两个函数之间的相似度，同样也可以得到（系数）组分，这种方法可以应用于多项式逼近连续函数，也可以用到连续函数逼近离散样本点（最小二乘问题，OLS coefficients）中，扯得有点远了- -!。<br>向量内积的结果是没有界限的，一种解决办法是除以长度之后再求内积，这就是应用十分广泛的余弦相似度（Cosine similarity）：</p><p>余弦相似度与向量的幅值无关，只与向量的方向相关，在文档相似度（TF-IDF）和图片相似性（histogram）计算上都有它的身影。需要注意一点的是，余弦相似度受到向量的平移影响，上式如果将 x 平移到 x+1, 余弦值就会改变。怎样才能实现平移不变性？这就是下面要说的皮尔逊相关系数（Pearson correlation），有时候也直接叫相关系数:</p><p>皮尔逊相关系数具有平移不变性和尺度不变性，计算出了两个向量（维度）的相关性。不过，一般我们在谈论相关系数的时候，将 x 与 y 对应位置的两个数值看作一个样本点，皮尔逊系数用来表示这些样本点分布的相关性。</p><p>由于皮尔逊系数具有的良好性质，在各个领域都应用广泛，例如，在推荐系统根据为某一用户查找喜好相似的用户,进而提供推荐，优点是可以不受每个用户评分标准不同和观看影片数量不一样的影响。</p><ol start="4"><li>分类数据点间的距离<br>汉明距离（Hamming distance）是指，两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。举个维基百科上的例子：</li></ol><p>还可以用简单的匹配系数来表示两点之间的相似度——匹配字符数/总字符数。<br>在一些情况下，某些特定的值相等并不能代表什么。举个例子，用 1 表示用户看过该电影，用 0 表示用户没有看过，那么用户看电影的的信息就可用 0,1 表示成一个序列。考虑到电影基数非常庞大，用户看过的电影只占其中非常小的一部分，如果两个用户都没有看过某一部电影（两个都是 0），并不能说明两者相似。反而言之，如果两个用户都看过某一部电影（序列中都是 1），则说明用户有很大的相似度。在这个例子中，序列中等于 1 所占的权重应该远远大于 0 的权重，这就引出下面要说的杰卡德相似系数（Jaccard similarity）。<br>在上面的例子中，用 M11 表示两个用户都看过的电影数目，M10 表示用户 A 看过，用户 B 没看过的电影数目，M01 表示用户 A 没看过，用户 B 看过的电影数目，M00 表示两个用户都没有看过的电影数目。Jaccard 相似性系数可以表示为：</p><p>Jaccard similarity 还可以用集合的公式来表达，这里就不多说了。<br>如果分类数值点是用树形结构来表示的，它们的相似性可以用相同路径的长度来表示，比如，“/product/spot/ballgame/basketball” 离“product/spot/ballgame/soccer/shoes” 的距离小于到 “/product/luxury/handbags” 的距离，以为前者相同父节点路径更长。</p><ol start="5"><li>序列之间的距离<br>上一小节我们知道，汉明距离可以度量两个长度相同的字符串之间的相似度，如果要比较两个不同长度的字符串，不仅要进行替换，而且要进行插入与删除的运算，在这种场合下，通常使用更加复杂的编辑距离（Edit distance, Levenshtein distance）等算法。编辑距离是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。编辑距离求的是最少编辑次数，这是一个动态规划的问题，有兴趣的同学可以自己研究研究。<br>时间序列是序列之间距离的另外一个例子。DTW 距离（Dynamic Time Warp）是序列信号在时间或者速度上不匹配的时候一种衡量相似度的方法。神马意思？举个例子，两份原本一样声音样本A、B都说了“你好”，A在时间上发生了扭曲，“你”这个音延长了几秒。最后A:“你~~~好”，B：“你好”。DTW正是这样一种可以用来匹配A、B之间的最短距离的算法。<br>DTW 距离在保持信号先后顺序的限制下对时间信号进行“膨胀”或者“收缩”，找到最优的匹配，与编辑距离相似，这其实也是一个动态规划的问题:</li></ol><p>实现代码（转自 McKelvin’s Blog ）:<br> View Code</p><ol start="6"><li>概率分布之间的距离<br>前面我们谈论的都是两个数值点之间的距离，实际上两个概率分布之间的距离是可以测量的。在统计学里面经常需要测量两组样本分布之间的距离，进而判断出它们是否出自同一个 population，常见的方法有卡方检验（Chi-Square）和 KL 散度（ KL-Divergence），下面说一说 KL 散度吧。<br>先从信息熵说起，假设一篇文章的标题叫做“黑洞到底吃什么”，包含词语分别是 {黑洞, 到底, 吃什么}, 我们现在要根据一个词语推测这篇文章的类别。哪个词语给予我们的信息最多？很容易就知道是“黑洞”，因为“黑洞”这个词语在所有的文档中出现的概率太低啦，一旦出现，就表明这篇文章很可能是在讲科普知识。而其他两个词语“到底”和“吃什么”出现的概率很高，给予我们的信息反而越少。如何用一个函数 h(x) 表示词语给予的信息量呢？第一，肯定是与 p(x) 相关，并且是负相关。第二，假设 x 和 y 是独立的（黑洞和宇宙不相互独立，谈到黑洞必然会说宇宙）,即 p(x,y) = p(x)p(y), 那么获得的信息也是叠加的，即 h(x, y) = h(x) + h(y)。满足这两个条件的函数肯定是负对数形式：</li></ol><p>对假设一个发送者要将随机变量 X 产生的一长串随机值传送给接收者， 接受者获得的平均信息量就是求它的数学期望：</p><p>这就是熵的概念。另外一个重要特点是，熵的大小与字符平均最短编码长度是一样的（shannon）。设有一个未知的分布 p(x), 而 q(x) 是我们所获得的一个对 p(x) 的近似，按照 q(x) 对该随机变量的各个值进行编码，平均长度比按照真实分布的 p(x) 进行编码要额外长一些，多出来的长度这就是 KL 散度（之所以不说距离，是因为不满足对称性和三角形法则），即：</p><p>KL 散度又叫相对熵（relative entropy）。了解机器学习的童鞋应该都知道，在 Softmax 回归（或者 Logistic 回归），最后的输出节点上的值表示这个样本分到该类的概率，这就是一个概率分布。对于一个带有标签的样本，我们期望的概率分布是：分到标签类的概率是 1， 其他类概率是 0。但是理想很丰满，现实很骨感，我们不可能得到完美的概率输出，能做的就是尽量减小总样本的 KL 散度之和（目标函数）。这就是 Softmax 回归或者 Logistic 回归中 Cost function 的优化过程啦。（PS：因为概率和为 1，一般的 logistic 二分类的图只画了一个输出节点，隐藏了另外一个）</p><p>待补充的方法：<br>卡方检验 Chi-Square<br>衡量 categorical attributes 相关性的 mutual information<br>Spearman’s rank coefficient<br>Earth Mover’s Distance<br>SimRank 迭代算法等。</p><p>参考资料：<br>距离和相似性度量<br>Machine Learning: Measuring Similarity and Distance<br>What is Mahalanobis distance?<br>Cosine similarity, Pearson correlation, and OLS coefficients<br>机器学习中的相似性度量<br>动态时间归整 | DTW | Dynamic Time Warping</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习中距离和相似性度量方法&quot;&gt;&lt;a href=&quot;#机器学习中距离和相似性度量方法&quot; class=&quot;headerlink&quot; title=&quot;机器学习中距离和相似性度量方法&quot;&gt;&lt;/a&gt;机器学习中距离和相似性度量方法&lt;/h1&gt;&lt;p&gt;声明：本文主要参考文章 &lt;a hre
      
    
    </summary>
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="相似性度量" scheme="http://yoursite.com/tags/%E7%9B%B8%E4%BC%BC%E6%80%A7%E5%BA%A6%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于ssh的知识</title>
    <link href="http://yoursite.com/2018/04/02/notebook/linux%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%85%B3%E4%BA%8Essh/"/>
    <id>http://yoursite.com/2018/04/02/notebook/linux和操作系统/关于ssh/</id>
    <published>2018-04-02T08:39:28.007Z</published>
    <updated>2018-04-02T09:13:51.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于ssh的知识"><a href="#关于ssh的知识" class="headerlink" title="关于ssh的知识"></a>关于ssh的知识</h1><h2 id="配置ssh免秘钥登录"><a href="#配置ssh免秘钥登录" class="headerlink" title="配置ssh免秘钥登录"></a>配置ssh免秘钥登录</h2><ul><li>ssh -vvv ip-address<br>-vvv的意思是给出debug信息，信息会比较全。如果配置过程中出错了，可以看一下debug信息，看下具体哪里有问题。</li><li>ssh7之后默认不支持dsa加密<br>最好使用rsa加密。但是同样可以手动支持dsa，参见<a href="https://centrify.force.com/support/Article/KB-7050-How-to-Re-enable-DSA-keys-when-using-OpenSSH-7-0-and-above" target="_blank" rel="noopener">How to Re-enable DSA keys when using OpenSSH 7.0 and above</a>，在/etc/ssh/sshd_config和/etc/ssh/ssh_config文件中添加<code>PubkeyAcceptedKeyTypes=+ssh-dss</code>。实际测试发现:使用ssh7的服务端可以通过设置以上内容使得客户端可以免密码登录，但是服务端无法免密码登录客户端（即便客户端有服务端的dsa公钥）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于ssh的知识&quot;&gt;&lt;a href=&quot;#关于ssh的知识&quot; class=&quot;headerlink&quot; title=&quot;关于ssh的知识&quot;&gt;&lt;/a&gt;关于ssh的知识&lt;/h1&gt;&lt;h2 id=&quot;配置ssh免秘钥登录&quot;&gt;&lt;a href=&quot;#配置ssh免秘钥登录&quot; class=&quot;
      
    
    </summary>
    
      <category term="ssh" scheme="http://yoursite.com/categories/ssh/"/>
    
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/04/02/notebook/linux%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/softwareinstall/something/"/>
    <id>http://yoursite.com/2018/04/02/notebook/linux和操作系统/softwareinstall/something/</id>
    <published>2018-04-02T08:39:28.006Z</published>
    <updated>2018-04-02T08:39:28.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ubuntu14-04-中安装一些常用软件"><a href="#ubuntu14-04-中安装一些常用软件" class="headerlink" title="ubuntu14.04 中安装一些常用软件"></a>ubuntu14.04 中安装一些常用软件</h1><h2 id="安装vscode"><a href="#安装vscode" class="headerlink" title="安装vscode"></a>安装vscode</h2><p>参考：<a href="https://linux.cn/article-5423-1.html" target="_blank" rel="noopener">在Ubuntu中安装Visual Studio Code</a></p><p>主要命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装ubuntu-make</span></span><br><span class="line"><span class="comment"># 更新源</span></span><br><span class="line">sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-make</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install ubuntu-make</span><br><span class="line"><span class="comment"># 安装vscode</span></span><br><span class="line">umake web visual-studio-code</span><br><span class="line"><span class="comment"># 卸载vscode</span></span><br><span class="line">umake web visual-studio-code --remove</span><br></pre></td></tr></table></figure></p><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><p>使用<code>sudo apt-get install git</code>安装的是系统的默认版本，我自己安装的时候默认是1.9.1，有点老。网上有个更新的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br><span class="line"><span class="comment"># git version 1.9.1</span></span><br><span class="line"><span class="comment"># 可以使用下面命令升级git（如果不是root用户，需在命令前加sudo）：</span></span><br><span class="line">sudo add-apt-repository ppa:git-core/ppa</span><br><span class="line">sudo apt-get update</span><br><span class="line">sduo apt-get install git</span><br><span class="line"><span class="comment"># 安装完成后，再查看git版本：</span></span><br><span class="line">git --version</span><br><span class="line"><span class="comment"># git version 2.10.1</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ubuntu14-04-中安装一些常用软件&quot;&gt;&lt;a href=&quot;#ubuntu14-04-中安装一些常用软件&quot; class=&quot;headerlink&quot; title=&quot;ubuntu14.04 中安装一些常用软件&quot;&gt;&lt;/a&gt;ubuntu14.04 中安装一些常用软件&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>shellcommand 随笔</title>
    <link href="http://yoursite.com/2018/04/02/notebook/linux%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shellcmd/shellcommand%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2018/04/02/notebook/linux和操作系统/shellcmd/shellcommand随笔/</id>
    <published>2018-04-02T08:39:28.005Z</published>
    <updated>2018-04-02T09:13:51.995Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shellcommand-随笔"><a href="#shellcommand-随笔" class="headerlink" title="shellcommand 随笔"></a>shellcommand 随笔</h1><ul><li>命令行中打开ubuntu的文件浏览器：<code>nautilus [path]</code></li><li>在多个文件中查找包含某关键字的行（显示文件名和行号）：<code>grep -rHn &quot;keyword&quot; files</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shellcommand-随笔&quot;&gt;&lt;a href=&quot;#shellcommand-随笔&quot; class=&quot;headerlink&quot; title=&quot;shellcommand 随笔&quot;&gt;&lt;/a&gt;shellcommand 随笔&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;命令行中打开ubuntu
      
    
    </summary>
    
      <category term="linux系统" scheme="http://yoursite.com/categories/linux%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/linux%E7%B3%BB%E7%BB%9F/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>安装软件或者服务的方法的总结</title>
    <link href="http://yoursite.com/2018/04/02/notebook/linux%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E6%88%96%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/02/notebook/linux和操作系统/linux系统安装软件或服务的方法总结/</id>
    <published>2018-04-02T08:39:28.004Z</published>
    <updated>2018-04-02T09:13:51.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装软件或者服务的方法的总结"><a href="#安装软件或者服务的方法的总结" class="headerlink" title="安装软件或者服务的方法的总结"></a>安装软件或者服务的方法的总结</h1><p>ppa是什么啊，apt-get是什么啊等等吧，什么是build-essential，软件依赖到底是个什么情况！</p><p>##</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装软件或者服务的方法的总结&quot;&gt;&lt;a href=&quot;#安装软件或者服务的方法的总结&quot; class=&quot;headerlink&quot; title=&quot;安装软件或者服务的方法的总结&quot;&gt;&lt;/a&gt;安装软件或者服务的方法的总结&lt;/h1&gt;&lt;p&gt;ppa是什么啊，apt-get是什么啊等等吧
      
    
    </summary>
    
      <category term="linux系统" scheme="http://yoursite.com/categories/linux%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="软件安装" scheme="http://yoursite.com/categories/linux%E7%B3%BB%E7%BB%9F/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="linux系统" scheme="http://yoursite.com/tags/linux%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="软件安装" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>LINUX 知识随笔</title>
    <link href="http://yoursite.com/2018/04/02/notebook/linux%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%E7%9F%A5%E8%AF%86%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2018/04/02/notebook/linux和操作系统/linux知识随笔/</id>
    <published>2018-04-02T08:39:28.003Z</published>
    <updated>2018-04-02T09:13:51.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LINUX-知识随笔"><a href="#LINUX-知识随笔" class="headerlink" title="LINUX 知识随笔"></a>LINUX 知识随笔</h1><h2 id="如何在两台linux主机间同步目录或文件？"><a href="#如何在两台linux主机间同步目录或文件？" class="headerlink" title="如何在两台linux主机间同步目录或文件？"></a>如何在两台linux主机间同步目录或文件？</h2><p>Linux的Rsync服务（远程同步）</p><p>参考：<a href="http://roclinux.cn/?p=2643" target="_blank" rel="noopener">《rsync同步的艺术》–linux命令五分钟系列之四十二</a>、<a href="http://man.linuxde.net/rsync" target="_blank" rel="noopener">rsync命令</a></p><p>rsync命令是一个远程数据同步工具，可通过LAN/WAN（本地或者远程）快速同步多台主机间的文件。所谓的同步，并不是实时的同步，需要执行命令来保证数据的同步。</p><p>Rsync命令的一些优点和功能：</p><ul><li>有效地将文件复制到远程系统或从远程系统同步。</li><li>支持复制链接，设备，所有者，组和权限。</li><li>比SCP（安全复制）更快，因为rsync使用远程更新协议，允许转让只是<strong>两套文件之间的差异</strong>。 第一次，它从源到目标复制文件或目录的整个内容，但从下一次，它只将已更改的块和字节复制到目标。</li><li>rsync的消耗更少的带宽 ，因为它使用压缩和解压缩方法在发送和接收数据两端。</li></ul><p>rsync在使用的时候主要是熟悉使用方法和参数命令，在使用参数命令的时候需要主要考虑下面几点。</p><ul><li>rsync的quick check是否需要起作用，哪些参数在使用的使用quick check是默认开启的？</li><li>文件的modify time是否需要同步？</li><li>文件的权限是否需要同步？</li><li>是否需要保持目的端文件的属主和属组保持一致（rsync不具备这个能力，除非使用root用户权限）？</li><li>同步文件时是否需要压缩？</li><li>同步文件夹的时候，是否需要recursive？</li><li>同步中断是需要删除重新同步还是需要在中断时的基础上继续同步？</li><li>软链接和硬链接如何同步？</li><li>同步时，源端没有的文件是否在目的端删除？</li></ul><p>以上都可以在 <a href="http://roclinux.cn/?p=2643" target="_blank" rel="noopener">《rsync同步的艺术》–linux命令五分钟系列之四十二</a>中或者使用 <code>man rsync</code> 中找到解决方案。</p><h2 id="两台Linux系统主机间传输文件的方法有哪些？"><a href="#两台Linux系统主机间传输文件的方法有哪些？" class="headerlink" title="两台Linux系统主机间传输文件的方法有哪些？"></a>两台Linux系统主机间传输文件的方法有哪些？</h2><p>参考：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-filetransfer/" target="_blank" rel="noopener">Linux 上的常用文件传输方式介绍与比较</a></p><ul><li>ftp</li><li>rcp</li><li>scp</li><li>wget</li><li>curl</li><li>rsync</li></ul><p><strong>总结与比较</strong></p><ul><li>传输性能</li></ul><p>wget 通过支持后台执行及断点续传提高文件传输效率 ； rsync 则以其高效的传输及压缩算法达到快传输的目的。</p><ul><li>配置难度</li></ul><p>rcp 只需进行简单的配置，创建 .rhost 文件以及设置 /etc/hosts 文件中主机名与 IP 地址列表； wget<br>设置设置方便简单，只需在客户端指定参数执行命令即可； rsync 在使用前需要对服务端 /etc/rsyncd.conf 进行参数设定，配置内容相对复杂。</p><ul><li>安全性能</li></ul><p>ftp、rcp 不保证传输的安全性，scp、rsync 则均可基于 ssh 认证进行传输，提供了较强的安全保障。 wget 也可通过指定安全协议做到安全传输。</p><p>通过上述的对比不难发现，每种文件传输方法基于其自身的特点与优势均有其典型的适用场景：</p><ul><li>ftp 作为最常用的入门式的文件传输方法，使用简单，易于理解，并且可以实现脚本自动化；</li><li>rcp 相对于 ftp 可以保留文件属性并可递归的拷贝子目录；</li><li>scp 利用 ssh 传输数据，并使用与 ssh 相同的认证模式，相对于 rcp 提供更强的安全保障；</li><li>wget，实现递归下载，可跟踪 HTML 页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构，适合实现远程网站的镜像；</li><li>curl 则适合用来进行自动的文件传输或操作序列，是一个很好的模拟用户在网页浏览器上的行为的工具；</li><li>rsync 更适用于大数据量的每日同步，拷贝的速度很快，相对 wget 来说速度快且安全高效。</li></ul><h2 id="文件传输过程中如何限速？"><a href="#文件传输过程中如何限速？" class="headerlink" title="文件传输过程中如何限速？"></a>文件传输过程中如何限速？</h2><p>限速的原因：有些机房会限制机器的流量，为了不触及底线，在使用scp和rsync的时候都要注意。为了避免你的scp或者rsync因为无良/懒惰的OPS设置防火墙的偷懒而造成的断流现象，我们必须对自己的数据传输进行一定的限流措施，慢一点总比被掐了的好。</p><p>参考：<a href="http://www.nathanyan.com/2016/04/10/Linux-%E5%91%BD%E4%BB%A4-SCP-%E8%BF%9C%E7%A8%8B%E5%A4%8D%E5%88%B6/" target="_blank" rel="noopener">Linux 命令 SCP 远程复制</a>、<a href="http://www.54chen.com/life/%E5%A6%82%E4%BD%95%E5%AF%B9%E4%BB%98%E6%97%A0%E8%89%AF%E6%87%92%E6%83%B0ops%E7%9A%84%E5%8F%AF%E8%80%BB%E7%9A%84%E9%99%90%E6%B5%81%E6%8E%AA%E6%96%BD.html" target="_blank" rel="noopener">scp和rsync的限制流量（速度）方法</a></p><ul><li>SCP限制带宽使用</li></ul><blockquote><p>“-l”参数能限制使用带宽。如果你为了拷贝很多文件而去执行了一份自动化脚本又不希望带宽被SCP进程耗尽，那这个参数会非常管用。  </p><p>在“-l”参数后面的这个400值意思是我们给SCP进程限制了带宽为50 KB/秒。有一点要记住，带宽是以千比特/秒 (kbps)表示的，而8 比特等于1 字节。 </p><p>因为SCP是用千字节/秒 (KB/s)计算的，所以如果你想要限制SCP的最大带宽只有50 KB/s，你就需要设置成50 x 8 = 400。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -l 400 ib_logfile2 root@mysql-2:/tmp</span><br></pre></td></tr></table></figure></p></blockquote><ul><li>rsync带宽限速</li></ul><p>使用 –bwlimit 参数，例如限制为 60k Bytes/s<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -auvz --progress --delete --bwlimit=60 远程的文件  本地的文件</span><br><span class="line">rsync -auvz --progress --delete --bwlimit=60 本地的文件  远程的文件</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LINUX-知识随笔&quot;&gt;&lt;a href=&quot;#LINUX-知识随笔&quot; class=&quot;headerlink&quot; title=&quot;LINUX 知识随笔&quot;&gt;&lt;/a&gt;LINUX 知识随笔&lt;/h1&gt;&lt;h2 id=&quot;如何在两台linux主机间同步目录或文件？&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="linux系统" scheme="http://yoursite.com/categories/linux%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/linux%E7%B3%BB%E7%BB%9F/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="linux系统" scheme="http://yoursite.com/tags/linux%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>关于Linux core文件</title>
    <link href="http://yoursite.com/2018/04/02/notebook/linux%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/linux%20core%E6%96%87%E4%BB%B6%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/04/02/notebook/linux和操作系统/linux core文件介绍/</id>
    <published>2018-04-02T08:39:28.002Z</published>
    <updated>2018-04-02T09:13:51.986Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Linux-core文件"><a href="#关于Linux-core文件" class="headerlink" title="关于Linux core文件"></a>关于Linux core文件</h1><h2 id="core文件的简单介绍"><a href="#core文件的简单介绍" class="headerlink" title="core文件的简单介绍"></a>core文件的简单介绍</h2><p>在一个程序崩溃时，它一般会在指定目录下生成一个core文件。core文件仅仅是一个内存映象(同时加上调试信息)，主要是用来调试的。</p><h3 id="开启或关闭core文件的生成"><a href="#开启或关闭core文件的生成" class="headerlink" title="开启或关闭core文件的生成"></a>开启或关闭core文件的生成</h3><p>用以下命令来阻止系统生成core文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -c 0</span><br></pre></td></tr></table></figure></p><p>下面的命令可以检查生成core文件的选项是否打开:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ulimit -a</span><br></pre></td></tr></table></figure></p><p>该命令将显示所有的用户定制，其中选项-a代表“all”。</p><p>也可以修改系统文件来调整core选项<br>在/etc/profile通常会有这样一句话来禁止产生core文件，通常这种设置是合理的:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> No core files by default</span></span><br><span class="line">ulimit -S -c 0 &gt; /dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure></p><p>但是在开发过程中有时为了调试问题，还是需要在特定的用户环境下打开core文件产生的设置<br>在用户的~/.bash_profile里加上<code>ulimit -c unlimited</code>来让特定的用户可以产生core文件<br>如果<code>ulimit -c 0</code>则也是禁止产生core文件，而<code>ulimit -c 1024</code>则限制产生的core文件的大小不能超过1024kb</p><h2 id="设置Core-Dump的核心转储文件目录和命名规则"><a href="#设置Core-Dump的核心转储文件目录和命名规则" class="headerlink" title="设置Core Dump的核心转储文件目录和命名规则"></a>设置Core Dump的核心转储文件目录和命名规则</h2><p>/proc/sys/kernel/core_uses_pid可以控制产生的core文件的文件名中是否添加pid作为扩展，如果添加则文件内容为1，否则为0</p><p>/proc/sys/kernel/core_pattern可以设置格式化的core文件保存位置或文件名，比如原来文件内容是core-%e, 可以这样修改:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/corefile/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure></p><p>将会控制所产生的core文件会存放到/corefile目录下，产生的文件名为core-命令名-pid-时间戳<br>以下是参数列表:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%p - insert pid into filename 添加pid</span><br><span class="line">%u - insert current uid into filename 添加当前uid</span><br><span class="line">%g - insert current gid into filename 添加当前gid</span><br><span class="line">%s - insert signal that caused the coredump into the filename 添加导致产生core的信号</span><br><span class="line">%t - insert UNIX time that the coredump occurred into filename 添加core文件生成时的unix时间</span><br><span class="line">%h - insert hostname where the coredump happened into filename 添加主机名</span><br><span class="line">%e - insert coredumping executable name into filename 添加命令名</span><br></pre></td></tr></table></figure></p><h2 id="使用core文件"><a href="#使用core文件" class="headerlink" title="使用core文件"></a>使用core文件</h2><p>在core文件所在目录下键入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -c core</span><br></pre></td></tr></table></figure></p><p>它会启动GNU的调试器，来调试core文件，并且会显示生成此core文件的程序名，中止此程序的信号等等</p><p>如果你已经知道是由什么程序生成此core文件的，比如MyServer崩溃了生成core.12345，那么用此指令调试:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -c core MyServer</span><br></pre></td></tr></table></figure></p><p>以下怎么办就该去学习gdb的使用了</p><h2 id="一个小方法来测试产生core文件"><a href="#一个小方法来测试产生core文件" class="headerlink" title="一个小方法来测试产生core文件"></a>一个小方法来测试产生core文件</h2><p>直接输入指令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -s SIGSEGV $$</span><br></pre></td></tr></table></figure></p><h2 id="为何有时程序Down了，却没生成-Core文件。"><a href="#为何有时程序Down了，却没生成-Core文件。" class="headerlink" title="为何有时程序Down了，却没生成 Core文件。"></a>为何有时程序Down了，却没生成 Core文件。</h2><p>Linux下，有一些设置，标明了resources available to the shell and to processes。 可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#ulimit -a 来看这些设置。 (ulimit是bash built-in Command)</span><br><span class="line"></span><br><span class="line">             -a     All current limits are reported</span><br><span class="line">              -c     The maximum size of core files created</span><br><span class="line">              -d     The maximum size of a process鈥檚 data segment</span><br><span class="line">              -e     The maximum scheduling priority (&quot;nice&quot;)</span><br><span class="line">              -f     The maximum size of files written by the shell and its children</span><br><span class="line">              -i     The maximum number of pending signals</span><br><span class="line">              -l     The maximum size that may be locked into memory</span><br><span class="line">              -m     The maximum resident set size (has no effect on Linux)</span><br><span class="line">              -n     The maximum number of open file descriptors (most systems do not allow this value to be set)</span><br><span class="line">              -p     The pipe size in 512-byte blocks (this may not be set)</span><br><span class="line">              -q     The maximum number of bytes in POSIX message queues</span><br><span class="line">              -r     The maximum real-time scheduling priority</span><br><span class="line">              -s     The maximum stack size</span><br><span class="line">              -t     The maximum amount of cpu time in seconds</span><br><span class="line">              -u     The maximum number of processes available to a single user</span><br><span class="line">              -v     The maximum amount of virtual memory available to the shell</span><br><span class="line">              -x     The maximum number of file locks</span><br></pre></td></tr></table></figure></p><p>从这里可以看出，如果 -c是显示：core file size          (blocks, -c)</p><p>如果这个值为0，则无法生成core文件。所以可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#ulimit -c 1024 或者 #ulimit -c unlimited 来使能 core文件。</span><br></pre></td></tr></table></figure></p><p>如果程序出错时生成Core 文件，则会显示Segmentation fault (core dumped)。</p><h2 id="Core-Dump的核心转储文件目录和命名规则"><a href="#Core-Dump的核心转储文件目录和命名规则" class="headerlink" title="Core Dump的核心转储文件目录和命名规则:"></a>Core Dump的核心转储文件目录和命名规则:</h2><p>/proc/sys/kernel/core_uses_pid可以控制产生的core文件的文件名中是否添加pid作为扩展，如果添加则文件内容为1，否则为0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于Linux-core文件&quot;&gt;&lt;a href=&quot;#关于Linux-core文件&quot; class=&quot;headerlink&quot; title=&quot;关于Linux core文件&quot;&gt;&lt;/a&gt;关于Linux core文件&lt;/h1&gt;&lt;h2 id=&quot;core文件的简单介绍&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="linux系统" scheme="http://yoursite.com/categories/linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="linux系统" scheme="http://yoursite.com/tags/linux%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python 虚拟环境学习与使用</title>
    <link href="http://yoursite.com/2018/04/02/notebook/learn_python/python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/04/02/notebook/learn_python/python虚拟环境学习/</id>
    <published>2018-04-02T08:39:28.001Z</published>
    <updated>2018-04-02T09:13:51.983Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-虚拟环境学习与使用"><a href="#Python-虚拟环境学习与使用" class="headerlink" title="Python 虚拟环境学习与使用"></a>Python 虚拟环境学习与使用</h1><!-- TOC --><ul><li><a href="#什么是python的虚拟环境">什么是python的虚拟环境</a></li><li><a href="#如何搭建python虚拟环境">如何搭建python虚拟环境</a><ul><li><a href="#virtualenv的安装">virtualenv的安装</a></li><li><a href="#虚拟环境生命周期">虚拟环境生命周期</a></li><li><a href="#virtaulenvwrapper">Virtaulenvwrapper</a></li></ul></li><li><a href="#注意点">注意点</a></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><h2 id="什么是python的虚拟环境"><a href="#什么是python的虚拟环境" class="headerlink" title="什么是python的虚拟环境"></a>什么是python的虚拟环境</h2><p>&emsp;&emsp;Python虚拟环境指虚拟的独立运行环境。Python虚拟环境指独立的python运行环境，一般用于解决不同项目依赖不同，而又不希望互相干扰的问题。Python最长用的虚拟工具是virtualenv，它是一个第三方包。  </p><blockquote><p>在一个 Python 环境下开发时间越久、安装依赖越多，就越容易出现依赖包冲突的问题。为了解决这个问题，开发者们开发出了 virtualenv，可以搭建虚拟且独立的 Python 环境。这样就可以使每个项目环境与其他项目独立开来，保持环境的干净，解决包冲突问题。</p></blockquote><blockquote><p>动态语言中Ruby、Python都有自己的虚拟环境，通过创建虚拟环境能够使不同的项目之间的运行环境保持独立性而相互不受影响。例如项目A依赖Django1.4，而项目B依赖Django1.5，这时它就能解决此类问题。Ruby有Vagrant，Python有virtualenv，本文讨论Python虚拟环境。virtualenv可用于创建独立的Python环境，它会创建一个包含项目所必须要的执行文件。</p></blockquote><h2 id="如何搭建python虚拟环境"><a href="#如何搭建python虚拟环境" class="headerlink" title="如何搭建python虚拟环境"></a>如何搭建python虚拟环境</h2><h3 id="virtualenv的安装"><a href="#virtualenv的安装" class="headerlink" title="virtualenv的安装"></a>virtualenv的安装</h3><p>&emsp;&emsp;virtualenv实际上是一个第三方包，是管理虚拟环境的常用方法之一。Python3 中还自带了虚拟环境管理包。virtualenv的安装可以用easy_install或者pip安装。推荐使用pip安装。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenv</span><br></pre></td></tr></table></figure></p><h3 id="虚拟环境生命周期"><a href="#虚拟环境生命周期" class="headerlink" title="虚拟环境生命周期"></a>虚拟环境生命周期</h3><p><strong>创建：</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">virtualenv testvirdir  <span class="comment">#创建名称为testvirdir的虚拟目录</span></span><br><span class="line"><span class="built_in">cd</span> testvirdir</span><br><span class="line"><span class="built_in">source</span> bin/activate <span class="comment">#激活虚拟环境</span></span><br><span class="line">python -V <span class="comment">#测试python</span></span><br><span class="line"><span class="built_in">which</span> python <span class="comment">#查看python位置（应该为testvirdir下面的python）此时命令行前面会多出一个括号，括号里为虚拟环境的名称。以后easy_install或者pip安装的所有模块都会安装到该虚拟环境目录里。</span></span><br></pre></td></tr></table></figure></p><p><strong>使用：</strong>  </p><ul><li>只要在虚拟环境中执行命令就行，跟正常python一样。  </li><li>在虚拟环境安装Python packages时，Virtualenv 附带有pip安装工具，因此需要安装的packages可以直接运行pip命令  </li></ul><p><strong>退出：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure></p><p><strong>删除：</strong><br>直接删除虚拟环境目录<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf [virtual dir]</span><br></pre></td></tr></table></figure></p><p><strong>补充：</strong>  </p><ul><li>virtualenv 后加入 <em>–no-site-packages</em> 使得已经安装到系统Python环境中的所有第三方包都不会复制过来，这样就得到了一个不带任何第三方包的“干净”的Python运行环境。如果想依赖系统环境的第三方软件包，可以使用参数 <em>–system-site-packages</em>。  <h3 id="Virtaulenvwrapper"><a href="#Virtaulenvwrapper" class="headerlink" title="Virtaulenvwrapper"></a>Virtaulenvwrapper</h3>&emsp;&emsp;Virtaulenvwrapper是virtualenv的扩展包，提供了一系列命令，可以方便地<u>创建、删除、复制、切换</u>不同的虚拟环境。同时，使用该扩展后，所有虚拟环境都会被放置在同一个目录下。<br><strong>安装：</strong><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install virtualenvwrapper</span><br></pre></td></tr></table></figure></li></ul><p>&emsp;&emsp;此时还不能使用virtualenvwrapper，默认virtualenvwrapper安装在/usr/local/bin下面，实际上需要运行virtualenvwrapper.sh文件才行。<br><strong>设置环境变量：</strong><br>&emsp;&emsp;把下面两行添加到~/.bashrc（或者~/.zshrc）里。<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -f /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh ]; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs </span><br><span class="line">   <span class="built_in">source</span> /usr/<span class="built_in">local</span>/bin/virtualenvwrapper.sh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;其中，.virtualenvs 是可以自定义的虚拟环境管理目录。可以事先 <code>mkdir</code> 。然后执行：<code>source ~/.bashrc</code>，就可以使用 virtualenvwrapper 了。Windows 平台的安装过程，请参考<a href="http://virtualenvwrapper.readthedocs.io/en/latest/install.html" target="_blank" rel="noopener">官方文档</a>。<br><strong>使用:</strong><br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lsvirtualenv -b <span class="comment"># 列出虚拟环境</span></span><br><span class="line">workon [虚拟环境名称] <span class="comment"># 切换虚拟环境</span></span><br><span class="line">lssitepackages <span class="comment"># 查看环境里安装了哪些包</span></span><br><span class="line">cdvirtualenv [子目录名] <span class="comment"># 进入当前环境的目录</span></span><br><span class="line">cpvirtualenv [<span class="built_in">source</span>] [dest] <span class="comment"># 复制虚拟环境</span></span><br><span class="line">rmvirtualenv [虚拟环境名称] <span class="comment"># 删除虚拟环境</span></span><br><span class="line">deactivate <span class="comment"># 退出虚拟环境</span></span><br></pre></td></tr></table></figure></p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>待补充</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://github.com/lzjun567/note/blob/master/note/python/virtualenv.md" target="_blank" rel="noopener">Python虚拟环境</a><br>[2] <a href="http://codingpy.com/article/virtualenv-must-have-tool-for-python-development/" target="_blank" rel="noopener">Python开发必备神器之一：virtualenv</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python-虚拟环境学习与使用&quot;&gt;&lt;a href=&quot;#Python-虚拟环境学习与使用&quot; class=&quot;headerlink&quot; title=&quot;Python 虚拟环境学习与使用&quot;&gt;&lt;/a&gt;Python 虚拟环境学习与使用&lt;/h1&gt;&lt;!-- TOC --&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="虚拟环境" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>Python 编码问题</title>
    <link href="http://yoursite.com/2018/04/02/notebook/learn_python/python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/02/notebook/learn_python/python编码问题/</id>
    <published>2018-04-02T08:39:28.000Z</published>
    <updated>2018-04-02T09:13:51.982Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-编码问题"><a href="#Python-编码问题" class="headerlink" title="Python 编码问题"></a>Python 编码问题</h1><p><strong>Python encode and decode just like shit !!!!!!!!!!</strong></p><p>参考博文：<a href="http://selfboot.cn/2016/12/28/py_encode_decode/#str-%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">Python2.x 字符编码终极指南</a></p><p>总结起来就是：</p><h2 id="1-Python中的两个类型：-lt-type-39-str-39-gt-和-lt-type-39-unicode-39-gt"><a href="#1-Python中的两个类型：-lt-type-39-str-39-gt-和-lt-type-39-unicode-39-gt" class="headerlink" title="1. Python中的两个类型：&lt;type &#39;str&#39;&gt; 和 &lt;type &#39;unicode&#39;&gt;"></a>1. Python中的两个类型：<code>&lt;type &#39;str&#39;&gt;</code> 和 <code>&lt;type &#39;unicode&#39;&gt;</code></h2><p>简单来说：</p><ul><li>str：是字节串（container for bytes），由 Unicode 经过编码(encode)后的字节组成的。</li><li>unicode：真正意义上的字符串，其中的每个字符用 Unicode 中对应的 Code Point 表示。<br><img src="http://xuelangzf-github.qiniudn.com/20161228_encode_decode_3.png" alt="unicode&lt;=&gt;str"></li></ul><h2 id="2-总结"><a href="#2-总结" class="headerlink" title="2. 总结"></a>2. 总结</h2><ul><li>str可以看作是unicode字符串经过某种编码后的字节组成的数组</li><li>unicode是真正意义上的字符串</li><li>通过 encode 可以将unicode类型编码为str类型</li><li>通过 decode 可以将str类型解码为unicode类型</li><li>python 会隐式地进行编码、解码，默认采用 ascii</li><li>所有的编码、解码错误都是由于所选的编码、解码方式无法表示某些字符造成的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python-编码问题&quot;&gt;&lt;a href=&quot;#Python-编码问题&quot; class=&quot;headerlink&quot; title=&quot;Python 编码问题&quot;&gt;&lt;/a&gt;Python 编码问题&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Python encode and decode j
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>如何给Markdown文件自动加上标题编号</title>
    <link href="http://yoursite.com/2018/04/02/notebook/learn_markdown/%E7%BB%99Markdown%E5%8A%A0%E4%B8%8A%E6%A0%87%E9%A2%98%E7%BC%96%E5%8F%B7/"/>
    <id>http://yoursite.com/2018/04/02/notebook/learn_markdown/给Markdown加上标题编号/</id>
    <published>2018-04-02T08:39:27.999Z</published>
    <updated>2018-04-02T09:13:51.980Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何给Markdown文件自动加上标题编号"><a href="#如何给Markdown文件自动加上标题编号" class="headerlink" title="如何给Markdown文件自动加上标题编号"></a>如何给Markdown文件自动加上标题编号</h1><p><strong>转自参考资料[1]</strong><br><!-- TOC --></p><ul><li><a href="#问题描述markdownshowpreviewtoside">问题描述”markdown.showPreviewToSide</a></li><li><a href="#解决方法">解决方法</a></li><li><a href="#进一步优化">进一步优化</a></li><li><a href="#补充说明">补充说明</a></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><h2 id="问题描述”markdown-showPreviewToSide"><a href="#问题描述”markdown-showPreviewToSide" class="headerlink" title="问题描述”markdown.showPreviewToSide"></a>问题描述”markdown.showPreviewToSide</h2><p>我们都知道，MarkDown可以通过######等标记添加不同层次的标题，非常方便。但是问题来了：如何给标题加上编号呢？</p><p>像这样：</p><p># Title<br>## 1. sub-title<br>### 1.1 sub-sub-title<br>### 1.2 sub-sub-title<br>## 2. sub-title<br>## 3. sub-title  </p><p>为了给标题加上编号，手动加上11.11.223，很麻烦有没有？如果插入或删除章节，后面的编号都要重新修改一遍。。。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>其实，MarkDown是可以直接支持CSS的。在md文件中加入CSS代码，即可给章节自动加上编号。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;style type="text/css"&gt;</span><br><span class="line">    <span class="selector-tag">h1</span> &#123; <span class="attribute">counter-reset</span>: h2counter; &#125;</span><br><span class="line">    <span class="selector-tag">h2</span> &#123; <span class="attribute">counter-reset</span>: h3counter; &#125;</span><br><span class="line">    <span class="selector-tag">h3</span> &#123; <span class="attribute">counter-reset</span>: h4counter; &#125;</span><br><span class="line">    <span class="selector-tag">h4</span> &#123; <span class="attribute">counter-reset</span>: h5counter; &#125;</span><br><span class="line">    <span class="selector-tag">h5</span> &#123; <span class="attribute">counter-reset</span>: h6counter; &#125;</span><br><span class="line">    <span class="selector-tag">h6</span> &#123; &#125;</span><br><span class="line">    <span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">      <span class="attribute">counter-increment</span>: h2counter;</span><br><span class="line">      <span class="attribute">content</span>: <span class="built_in">counter</span>(h2counter) <span class="string">".\0000a0\0000a0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">h3</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">      <span class="attribute">counter-increment</span>: h3counter;</span><br><span class="line">      <span class="attribute">content</span>: <span class="built_in">counter</span>(h2counter) <span class="string">"."</span></span><br><span class="line">                <span class="built_in">counter</span>(h3counter) <span class="string">".\0000a0\0000a0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">h4</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">      <span class="attribute">counter-increment</span>: h4counter;</span><br><span class="line">      <span class="attribute">content</span>: <span class="built_in">counter</span>(h2counter) <span class="string">"."</span></span><br><span class="line">                <span class="built_in">counter</span>(h3counter) <span class="string">"."</span></span><br><span class="line">                <span class="built_in">counter</span>(h4counter) <span class="string">".\0000a0\0000a0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">h5</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">      <span class="attribute">counter-increment</span>: h5counter;</span><br><span class="line">      <span class="attribute">content</span>: <span class="built_in">counter</span>(h2counter) <span class="string">"."</span></span><br><span class="line">                <span class="built_in">counter</span>(h3counter) <span class="string">"."</span></span><br><span class="line">                <span class="built_in">counter</span>(h4counter) <span class="string">"."</span></span><br><span class="line">                <span class="built_in">counter</span>(h5counter) <span class="string">".\0000a0\0000a0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">h6</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">      <span class="attribute">counter-increment</span>: h6counter;</span><br><span class="line">      <span class="attribute">content</span>: <span class="built_in">counter</span>(h2counter) <span class="string">"."</span></span><br><span class="line">                <span class="built_in">counter</span>(h3counter) <span class="string">"."</span></span><br><span class="line">                <span class="built_in">counter</span>(h4counter) <span class="string">"."</span></span><br><span class="line">                <span class="built_in">counter</span>(h5counter) <span class="string">"."</span></span><br><span class="line">                <span class="built_in">counter</span>(h6counter) <span class="string">".\0000a0\0000a0"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><h2 id="进一步优化"><a href="#进一步优化" class="headerlink" title="进一步优化"></a>进一步优化</h2><p>每个MarkDown文件中都要加上上面这段CSS，还是有点麻烦。幸好，MarkDown也支持外部样式表。把上面的代码保存到一个独立的CSS文件中（去掉头尾的style标签），文件命名为 auto-number-title.css<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123; <span class="attribute">counter-reset</span>: h2counter; &#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123; <span class="attribute">counter-reset</span>: h3counter; &#125;</span><br><span class="line"><span class="selector-tag">h3</span> &#123; <span class="attribute">counter-reset</span>: h4counter; &#125;</span><br><span class="line"><span class="selector-tag">h4</span> &#123; <span class="attribute">counter-reset</span>: h5counter; &#125;</span><br><span class="line"><span class="selector-tag">h5</span> &#123; <span class="attribute">counter-reset</span>: h6counter; &#125;</span><br><span class="line"><span class="selector-tag">h6</span> &#123; &#125;</span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">counter-increment</span>: h2counter;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">counter</span>(h2counter) <span class="string">".\0000a0\0000a0"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h3</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">counter-increment</span>: h3counter;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">counter</span>(h2counter) <span class="string">"."</span></span><br><span class="line">            <span class="built_in">counter</span>(h3counter) <span class="string">".\0000a0\0000a0"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h4</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">counter-increment</span>: h4counter;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">counter</span>(h2counter) <span class="string">"."</span></span><br><span class="line">            <span class="built_in">counter</span>(h3counter) <span class="string">"."</span></span><br><span class="line">            <span class="built_in">counter</span>(h4counter) <span class="string">".\0000a0\0000a0"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h5</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">counter-increment</span>: h5counter;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">counter</span>(h2counter) <span class="string">"."</span></span><br><span class="line">            <span class="built_in">counter</span>(h3counter) <span class="string">"."</span></span><br><span class="line">            <span class="built_in">counter</span>(h4counter) <span class="string">"."</span></span><br><span class="line">            <span class="built_in">counter</span>(h5counter) <span class="string">".\0000a0\0000a0"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h6</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">counter-increment</span>: h6counter;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">counter</span>(h2counter) <span class="string">"."</span></span><br><span class="line">            <span class="built_in">counter</span>(h3counter) <span class="string">"."</span></span><br><span class="line">            <span class="built_in">counter</span>(h4counter) <span class="string">"."</span></span><br><span class="line">            <span class="built_in">counter</span>(h5counter) <span class="string">"."</span></span><br><span class="line">            <span class="built_in">counter</span>(h6counter) <span class="string">".\0000a0\0000a0"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来只要在md文件中加上引用外部样式表的代码就可以啦：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"auto-number-title.css"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>是不是很方便呢？</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><p>为了能用本文的方法实现标题自动编号，文章必须有主标题，且必须是一级标题“#”，然后在正文中依次使用二级、三级标题等。自动编号是从二级标题开始的。一级标题是主标题，只应该有一个，也不应加上编号。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a href="https://yanwei.github.io/misc/markdown-auto-number-title.html" target="_blank" rel="noopener">MarkDown标题自动添加编号</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何给Markdown文件自动加上标题编号&quot;&gt;&lt;a href=&quot;#如何给Markdown文件自动加上标题编号&quot; class=&quot;headerlink&quot; title=&quot;如何给Markdown文件自动加上标题编号&quot;&gt;&lt;/a&gt;如何给Markdown文件自动加上标题编号&lt;/
      
    
    </summary>
    
      <category term="Markdown" scheme="http://yoursite.com/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/04/02/notebook/learn_markdown/%E5%9C%A8github%E4%B8%8A%E7%9A%84md%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%AC%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/04/02/notebook/learn_markdown/在github上的md文件中添加公式/</id>
    <published>2018-04-02T08:39:27.998Z</published>
    <updated>2018-04-02T08:39:27.998Z</updated>
    
    <content type="html"><![CDATA[<hr><pre><code>如何在github上添加数学公式@author chenkh@createtime 2018-01-02</code></pre><hr><h1 id="如何在github上添加数学公式"><a href="#如何在github上添加数学公式" class="headerlink" title="如何在github上添加数学公式"></a>如何在github上添加数学公式</h1><p>github上添加数学公式有很多种方法，总结起来两种形式：  </p><ul><li>使用公式编辑器生成公式图片链接，直接放在markdown文件中作为公式的图片链接。</li><li>使用MathJax等高级公式编辑器进行数学公式直接书写和显示  </li></ul><p>目前只会使用第一种方法，第二种方法不是github直接支持的，比较复杂。另外github基于简单，快速，安全的理念，推荐使用第一种方法。</p><p>下面介绍第一种方法的使用。第二种方法待补充。</p><h2 id="生成公式图片链接"><a href="#生成公式图片链接" class="headerlink" title="生成公式图片链接"></a>生成公式图片链接</h2><p>CodeCogs 提供了一个<a href="https://link.jianshu.com/?t=https://www.codecogs.com/latex/eqneditor.php" target="_blank" rel="noopener">在线 LaTeX 编辑器</a>，可以将输入的数学公式转换为图片，并自动生成 HTML 代码（也支持其他格式）。<br>比如输入下面的代码：  </p><p align="center">ax^{2} + by^{2} + c = 0</p>  <p>便可以得到：</p><p></p><p align="center"><img src="https://latex.codecogs.com/png.latex?ax^{2}&space;&plus;&space;by^{2}&space;&plus;&space;c&space;=&space;0"></p><p></p><p align="center"><img src="https://latex.codecogs.com/gif.latex?\normal&space;E=mc^{2}">  </p><p>由于 Markdown 允许嵌入 HTML，所以直接把生成的代码粘贴过去就可以了。<br>另例如：<br>质能方程：<a href="https://www.codecogs.com/eqnedit.php?latex=\huge&space;E=mc^{2}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\normal&space;E=mc^{2}" title="\huge E=mc^{2}"></a><br>此在线编辑器功能强大，可以选择文件输出格式，支持 <code>png,gif</code> 等多种；还支持多种表现写法，支持 <code>html, url</code> 等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;pre&gt;&lt;code&gt;如何在github上添加数学公式
@author chenkh
@createtime 2018-01-02
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h1 id=&quot;如何在github上添加数学公式&quot;&gt;&lt;a href=&quot;#如何在github上添加数学公
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/04/02/notebook/learn_markdown/markdown-github/"/>
    <id>http://yoursite.com/2018/04/02/notebook/learn_markdown/markdown-github/</id>
    <published>2018-04-02T08:39:27.997Z</published>
    <updated>2018-04-02T08:39:27.997Z</updated>
    
    <content type="html"><![CDATA[body {    -ms-text-size-adjust: 100%;    -webkit-text-size-adjust: 100%;    line-height: 1.5;    color: #333;    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";    font-size: 16px;    line-height: 1.5;    word-wrap: break-word;}.pl-c {    color: #969896;}.pl-c1,.pl-s .pl-v {    color: #0086b3;}.pl-e,.pl-en {    color: #795da3;}.pl-smi,.pl-s .pl-s1 {    color: #333;}.pl-ent {    color: #63a35c;}.pl-k {    color: #a71d5d;}.pl-s,.pl-pds,.pl-s .pl-pse .pl-s1,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sre,.pl-sr .pl-sra {    color: #183691;}.pl-v {    color: #ed6a43;}.pl-id {    color: #b52a1d;}.pl-ii {    color: #f8f8f8;    background-color: #b52a1d;}.pl-sr .pl-cce {    font-weight: bold;    color: #63a35c;}.pl-ml {    color: #693a17;}.pl-mh,.pl-mh .pl-en,.pl-ms {    font-weight: bold;    color: #1d3e81;}.pl-mq {    color: #008080;}.pl-mi {    font-style: italic;    color: #333;}.pl-mb {    font-weight: bold;    color: #333;}.pl-md {    color: #bd2c00;    background-color: #ffecec;}.pl-mi1 {    color: #55a532;    background-color: #eaffea;}.pl-mdr {    font-weight: bold;    color: #795da3;}.pl-mo {    color: #1d3e81;}.octicon {    display: inline-block;    vertical-align: text-top;    fill: currentColor;}a {    background-color: transparent;    -webkit-text-decoration-skip: objects;}a:active,a:hover {    outline-width: 0;}strong {    font-weight: inherit;}strong {    font-weight: bolder;}h1 {    font-size: 2em;    margin: 0.67em 0;}img {    border-style: none;}svg:not(:root) {    overflow: hidden;}code,kbd,pre {    font-family: monospace, monospace;    font-size: 1em;}hr {    box-sizing: content-box;    height: 0;    overflow: visible;}input {    font: inherit;    margin: 0;}input {    overflow: visible;}[type="checkbox"] {    box-sizing: border-box;    padding: 0;}* {    box-sizing: border-box;}input {    font-family: inherit;    font-size: inherit;    line-height: inherit;}a {    color: #4078c0;    text-decoration: none;}a:hover,a:active {    text-decoration: underline;}strong {    font-weight: 600;}hr {    height: 0;    margin: 15px 0;    overflow: hidden;    background: transparent;    border: 0;    border-bottom: 1px solid #ddd;}hr::before {    display: table;    content: "";}hr::after {    display: table;    clear: both;    content: "";}table {    border-spacing: 0;    border-collapse: collapse;}td,th {    padding: 0;}h1,h2,h3,h4,h5,h6 {    margin-top: 0;    margin-bottom: 0;}h1 {    font-size: 32px;    font-weight: 600;}h2 {    font-size: 24px;    font-weight: 600;}h3 {    font-size: 20px;    font-weight: 600;}h4 {    font-size: 16px;    font-weight: 600;}h5 {    font-size: 14px;    font-weight: 600;}h6 {    font-size: 12px;    font-weight: 600;}p {    margin-top: 0;    margin-bottom: 10px;}blockquote {    margin: 0;}ul,ol {    padding-left: 0;    margin-top: 0;    margin-bottom: 0;}ol ol,ul ol {    list-style-type: lower-roman;}ul ul ol,ul ol ol,ol ul ol,ol ol ol {    list-style-type: lower-alpha;}dd {    margin-left: 0;}code {    font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;    font-size: 12px;}pre {    margin-top: 0;    margin-bottom: 0;    font: 12px Consolas, "Liberation Mono", Menlo, Courier, monospace;}.octicon {    vertical-align: text-bottom;}input {    -webkit-font-feature-settings: "liga" 0;    font-feature-settings: "liga" 0;}.markdown-body::before {    display: table;    content: "";}.markdown-body::after {    display: table;    clear: both;    content: "";}.markdown-body>*:first-child {    margin-top: 0 !important;}.markdown-body>*:last-child {    margin-bottom: 0 !important;}a:not([href]) {    color: inherit;    text-decoration: none;}.anchor {    float: left;    padding-right: 4px;    margin-left: -20px;    line-height: 1;}.anchor:focus {    outline: none;}p,blockquote,ul,ol,dl,table,pre {    margin-top: 0;    margin-bottom: 16px;}hr {    height: 0.25em;    padding: 0;    margin: 24px 0;    background-color: #e7e7e7;    border: 0;}blockquote {    padding: 0 1em;    color: #777;    border-left: 0.25em solid #ddd;}blockquote>:first-child {    margin-top: 0;}blockquote>:last-child {    margin-bottom: 0;}kbd {    display: inline-block;    padding: 3px 5px;    font-size: 11px;    line-height: 10px;    color: #555;    vertical-align: middle;    background-color: #fcfcfc;    border: solid 1px #ccc;    border-bottom-color: #bbb;    border-radius: 3px;    box-shadow: inset 0 -1px 0 #bbb;}h1,h2,h3,h4,h5,h6 {    margin-top: 24px;    margin-bottom: 16px;    font-weight: 600;    line-height: 1.25;}h1 .octicon-link,h2 .octicon-link,h3 .octicon-link,h4 .octicon-link,h5 .octicon-link,h6 .octicon-link {    color: #000;    vertical-align: middle;    visibility: hidden;}h1:hover .anchor,h2:hover .anchor,h3:hover .anchor,h4:hover .anchor,h5:hover .anchor,h6:hover .anchor {    text-decoration: none;}h1:hover .anchor .octicon-link,h2:hover .anchor .octicon-link,h3:hover .anchor .octicon-link,h4:hover .anchor .octicon-link,h5:hover .anchor .octicon-link,h6:hover .anchor .octicon-link {    visibility: visible;}h1 {    padding-bottom: 0.3em;    font-size: 2em;    border-bottom: 1px solid #eee;}h2 {    padding-bottom: 0.3em;    font-size: 1.5em;    border-bottom: 1px solid #eee;}h3 {    font-size: 1.25em;}h4 {    font-size: 1em;}h5 {    font-size: 0.875em;}h6 {    font-size: 0.85em;    color: #777;}ul,ol {    padding-left: 2em;}ul ul,ul ol,ol ol,ol ul {    margin-top: 0;    margin-bottom: 0;}li>p {    margin-top: 16px;}li+li {    margin-top: 0.25em;}dl {    padding: 0;}dl dt {    padding: 0;    margin-top: 16px;    font-size: 1em;    font-style: italic;    font-weight: bold;}dl dd {    padding: 0 16px;    margin-bottom: 16px;}table {    display: block;    width: 100%;    overflow: auto;}table th {    font-weight: bold;}table th,table td {    padding: 6px 13px;    border: 1px solid #ddd;}table tr {    background-color: #fff;    border-top: 1px solid #ccc;}table tr:nth-child(2n) {    background-color: #f8f8f8;}img {    max-width: 100%;    box-sizing: content-box;    background-color: #fff;}code {    padding: 0;    padding-top: 0.2em;    padding-bottom: 0.2em;    margin: 0;    font-size: 85%;    background-color: rgba(0, 0, 0, 0.04);    border-radius: 3px;}code::before,code::after {    letter-spacing: -0.2em;    content: "\00a0";}pre {    word-wrap: normal;}pre>code {    padding: 0;    margin: 0;    font-size: 100%;    word-break: normal;    white-space: pre;    background: transparent;    border: 0;}.highlight {    margin-bottom: 16px;}.highlight pre {    margin-bottom: 0;    word-break: normal;}.highlight pre,pre {    padding: 16px;    overflow: auto;    font-size: 85%;    line-height: 1.45;    background-color: #f7f7f7;    border-radius: 3px;}pre code {    display: inline;    max-width: auto;    padding: 0;    margin: 0;    overflow: visible;    line-height: inherit;    word-wrap: normal;    background-color: transparent;    border: 0;}pre code::before,pre code::after {    content: normal;}.pl-0 {    padding-left: 0 !important;}.pl-1 {    padding-left: 3px !important;}.pl-2 {    padding-left: 6px !important;}.pl-3 {    padding-left: 12px !important;}.pl-4 {    padding-left: 24px !important;}.pl-5 {    padding-left: 36px !important;}.pl-6 {    padding-left: 48px !important;}.full-commit .btn-outline:not(:disabled):hover {    color: #4078c0;    border: 1px solid #4078c0;}kbd {    display: inline-block;    padding: 3px 5px;    font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;    line-height: 10px;    color: #555;    vertical-align: middle;    background-color: #fcfcfc;    border: solid 1px #ccc;    border-bottom-color: #bbb;    border-radius: 3px;    box-shadow: inset 0 -1px 0 #bbb;}:checked+.radio-label {    position: relative;    z-index: 1;    border-color: #4078c0;}.task-list-item {    list-style-type: none;}.task-list-item+.task-list-item {    margin-top: 3px;}.task-list-item input {    margin: 0 0.2em 0.25em -1.6em;    vertical-align: middle;}hr {    border-bottom-color: #eee;}/** Theming **/body {    color: #333;    background: white;    padding: 0 25px;}.vscode-light,.vscode-light pre code {    color: #333;}.vscode-dark,.vscode-dark pre code {    color: #333;}.vscode-high-contrast,.vscode-high-contrast pre code {    color: #333;}.vscode-light code {    color: #333;}.vscode-dark code {    color: #333;}.vscode-light pre:not(.hljs),.vscode-light code>div {    background-color: #F6F8FA;}.vscode-dark pre:not(.hljs),.vscode-dark code>div {    background-color: #F6F8FA;}.vscode-high-contrast pre:not(.hljs),.vscode-high-contrast code>div {    background-color: #F6F8FA;}.vscode-high-contrast h1 {    border-color: transparent;}.vscode-light table>thead>tr>th {    border-color: #EAECEF;}.vscode-dark table>thead>tr>th {    border-color: #EAECEF;}.vscode-light h1,.vscode-light hr,.vscode-light table>tbody>tr+tr>td {    border-color: #EAECEF;}.vscode-dark h1,.vscode-dark hr,.vscode-dark table>tbody>tr+tr>td {    border-color: #EAECEF;}.vscode-light blockquote,.vscode-dark blockquote {    padding: 0 1em;    color: #777;    border-left: 0.25em solid #ddd;    background: transparent;}.vscode-high-contrast blockquote {    padding: 0 1em;    color: #777;    border-left: 0.25em solid #ddd;    background: transparent;}]]></content>
    
    <summary type="html">
    
      
      
        body {
    -ms-text-size-adjust: 100%;
    -webkit-text-size-adjust: 100%;
    line-height: 1.5;
    color: #333;
    font-family: -apple-sy
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/04/02/notebook/learn_markdown/auto-number-title/"/>
    <id>http://yoursite.com/2018/04/02/notebook/learn_markdown/auto-number-title/</id>
    <published>2018-04-02T08:39:27.996Z</published>
    <updated>2018-04-02T08:39:27.997Z</updated>
    
    <content type="html"><![CDATA[h1 { counter-reset: h2counter; }h2 { counter-reset: h3counter; }h3 { counter-reset: h4counter; }h4 { counter-reset: h5counter; }h5 { counter-reset: h6counter; }h6 { }h2:before {  counter-increment: h2counter;  content: counter(h2counter) ".\0000a0\0000a0";}h3:before {  counter-increment: h3counter;  content: counter(h2counter) "."            counter(h3counter) "\0000a0\0000a0";}h4:before {  counter-increment: h4counter;  content: counter(h2counter) "."            counter(h3counter) "."            counter(h4counter) "\0000a0\0000a0";}h5:before {  counter-increment: h5counter;  content: counter(h2counter) "."            counter(h3counter) "."            counter(h4counter) "."            counter(h5counter) "\0000a0\0000a0";}h6:before {  counter-increment: h6counter;  content: counter(h2counter) "."            counter(h3counter) "."            counter(h4counter) "."            counter(h5counter) "."            counter(h6counter) "\0000a0\0000a0";}]]></content>
    
    <summary type="html">
    
      
      
        h1 { counter-reset: h2counter; }
h2 { counter-reset: h3counter; }
h3 { counter-reset: h4counter; }
h4 { counter-reset: h5counter; }
h5 { cou
      
    
    </summary>
    
    
  </entry>
  
</feed>
