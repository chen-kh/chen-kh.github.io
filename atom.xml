<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>其鬼不神</title>
  
  <subtitle>ACT北航愣头青的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-19T08:54:43.913Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kaiheng CHEN</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tcp三次握手与四次挥手</title>
    <link href="http://yoursite.com/2018/04/19/notebook/learn_network/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>http://yoursite.com/2018/04/19/notebook/learn_network/tcp三次握手四次挥手/</id>
    <published>2018-04-19T08:54:43.913Z</published>
    <updated>2018-04-19T08:54:43.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tcp三次握手与四次挥手"><a href="#tcp三次握手与四次挥手" class="headerlink" title="tcp三次握手与四次挥手"></a>tcp三次握手与四次挥手</h1><h2 id="详细过程及状态变化"><a href="#详细过程及状态变化" class="headerlink" title="详细过程及状态变化"></a>详细过程及状态变化</h2><p><img src="tcp34.png" alt="tcp34"><br><img src="tcp3handshake.png" alt="tcp3handshake"><br><img src="tcp4handwave.png" alt="tcp4handwave"></p><p>在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG.<br>其中，对于我们日常的分析有用的就是前面的五个字段。</p><p>它们的含义是：</p><ul><li>SYN表示建立连接，</li><li>FIN表示关闭连接，</li><li>ACK表示响应，</li><li>PSH表示有 DATA数据传输，</li><li>RST表示连接重置。</li></ul><p>其中，ACK是可能与SYN，FIN等同时使用的，比如SYN和ACK可能同时为1，它表示的就是建立连接请求之后的响应，如果只是单个的一个SYN，它表示的只是建立连接。TCP的几次握手就是通过这样的ACK表现出来的。但SYN与FIN是不会同时为1的，因为前者表示的是建立连接，而后者表示的是断开连接。RST一般是在FIN之后才会出现为1的情况，表示的是连接重置。一般地，当出现FIN包或RST包时，我们便认为客户端与服务器端断开了连接；而当出现SYN和SYN＋ACK包时，我们认为客户端与服务器建立了一个连接。PSH为1的情况，一般只出现在 DATA内容不为0的包中，也就是说PSH为1表示的是有真正的TCP数据包内容被传递。TCP的连接建立和连接关闭，都是通过请求－响应的模式完成的。</p><h2 id="为什么需要三次握手和四次挥手"><a href="#为什么需要三次握手和四次挥手" class="headerlink" title="为什么需要三次握手和四次挥手"></a>为什么需要三次握手和四次挥手</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;tcp三次握手与四次挥手&quot;&gt;&lt;a href=&quot;#tcp三次握手与四次挥手&quot; class=&quot;headerlink&quot; title=&quot;tcp三次握手与四次挥手&quot;&gt;&lt;/a&gt;tcp三次握手与四次挥手&lt;/h1&gt;&lt;h2 id=&quot;详细过程及状态变化&quot;&gt;&lt;a href=&quot;#详细过程
      
    
    </summary>
    
      <category term="network" scheme="http://yoursite.com/categories/network/"/>
    
    
      <category term="network" scheme="http://yoursite.com/tags/network/"/>
    
      <category term="tcp" scheme="http://yoursite.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/04/19/notebook/learn_java/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2018/04/19/notebook/learn_java/java网络编程入门/</id>
    <published>2018-04-19T08:54:43.895Z</published>
    <updated>2018-04-19T08:54:43.895Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java的多态</title>
    <link href="http://yoursite.com/2018/04/19/notebook/learn_java/java%E7%9A%84%E5%A4%9A%E6%80%81/"/>
    <id>http://yoursite.com/2018/04/19/notebook/learn_java/java的多态/</id>
    <published>2018-04-19T08:54:43.892Z</published>
    <updated>2018-04-19T08:54:43.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java的多态"><a href="#Java的多态" class="headerlink" title="Java的多态"></a>Java的多态</h1><h2 id="静态绑定与动态绑定"><a href="#静态绑定与动态绑定" class="headerlink" title="静态绑定与动态绑定"></a>静态绑定与动态绑定</h2><ul><li><p>静态绑定/前期绑定：简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定</p><ul><li>private方法不能被继承，只能通过这个类自身的对象来调用，因此private方法和类绑定在了一起。</li><li>final方法可以被继承，但不能被重写（覆盖）， 将方法声明为final类型，一是为了防止方法被覆盖，二是为了有效地关闭java中的动态绑定。</li><li>static方法可以被子类继承，但是不能被子类重写（覆盖），可以被子类隐藏。</li></ul></li><li><p>动态绑定/后期绑定：在运行时根据具体对象的类型进行绑定。动态绑定的过程：虚拟机提取对象的实际类型的方法表 -&gt; 虚拟机搜索方法签名 -&gt; 调用方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Polymorphism</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">List&lt;Animal&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// parent class' constructor is inherited by default, actually it invokes super() by default</span></span><br><span class="line">Animal dog = <span class="keyword">new</span> Dog();</span><br><span class="line">System.out.println(<span class="string">"dog instance of Animal dog: "</span> + dog.getClass());</span><br><span class="line">Animal cat = <span class="keyword">new</span> Cat();</span><br><span class="line">System.out.println(<span class="string">"cat instance of Animal cat: "</span> + cat.getClass());</span><br><span class="line"><span class="comment">// list.add(cat);</span></span><br><span class="line">list.add(dog);</span><br><span class="line"><span class="keyword">for</span> (Animal animal : list) &#123;</span><br><span class="line"><span class="keyword">if</span> (animal.name == <span class="string">"animal"</span>)</span><br><span class="line">System.out.println(<span class="string">"animal.name = animal, so instance fields are statically bound"</span>);</span><br><span class="line"><span class="keyword">if</span> (animal.toString().contains(<span class="string">"color"</span>) || animal.toString().contains(<span class="string">"eyes"</span>))</span><br><span class="line">System.out.println(<span class="string">"invoke subclass method, so instance methods are dynamically bound"</span>);</span><br><span class="line">System.out.println(animal.toString());</span><br><span class="line">&#125;</span><br><span class="line">Animal.staticMethod();</span><br><span class="line"><span class="comment">// static methods can be inherited</span></span><br><span class="line">Cat.staticMethod();</span><br><span class="line"><span class="comment">// static method can be hidden but not override</span></span><br><span class="line">Dog.staticMethod();</span><br><span class="line"><span class="comment">// it's deprecated, but it works and invoke the partent class static method </span></span><br><span class="line">Animal dog2 = <span class="keyword">new</span> Dog();</span><br><span class="line">dog2.staticMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> String staticVar = <span class="string">"Animal StaticVar"</span>;</span><br><span class="line">String name = <span class="string">"animal"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Animal is created"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Override cause compile error</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"I am Animal static method"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> String staticVar = <span class="string">"Dog StaticVar"</span>;</span><br><span class="line">String name = <span class="string">"dog"</span>;</span><br><span class="line">String color = <span class="string">"color"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">":"</span> + color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"I am Dog static method"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> String staticVar = <span class="string">"Cat StaticVar"</span>;</span><br><span class="line">String name = <span class="string">"cat"</span>;</span><br><span class="line">String eyes = <span class="string">"eyes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">super</span>.toString() + <span class="string">":"</span> + eyes;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>参考资料：</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-polymorph/" target="_blank" rel="noopener">IBM: 多态在 Java 和 C++ 编程语言中的实现比较</a></li><li><a href="https://www.jianshu.com/p/7a322d39d963" target="_blank" rel="noopener">JAVA动态绑定与静态绑定</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java的多态&quot;&gt;&lt;a href=&quot;#Java的多态&quot; class=&quot;headerlink&quot; title=&quot;Java的多态&quot;&gt;&lt;/a&gt;Java的多态&lt;/h1&gt;&lt;h2 id=&quot;静态绑定与动态绑定&quot;&gt;&lt;a href=&quot;#静态绑定与动态绑定&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Java知识" scheme="http://yoursite.com/categories/Java%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java知识" scheme="http://yoursite.com/tags/Java%E7%9F%A5%E8%AF%86/"/>
    
      <category term="多态" scheme="http://yoursite.com/tags/%E5%A4%9A%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Java的List总结</title>
    <link href="http://yoursite.com/2018/04/19/notebook/learn_java/java%E7%9A%84list%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/19/notebook/learn_java/java的list总结/</id>
    <published>2018-04-19T08:54:43.891Z</published>
    <updated>2018-04-19T08:54:43.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java的List总结"><a href="#Java的List总结" class="headerlink" title="Java的List总结"></a>Java的List总结</h1><h2 id="ArrayList和LinkedList在使用上的不同"><a href="#ArrayList和LinkedList在使用上的不同" class="headerlink" title="ArrayList和LinkedList在使用上的不同"></a>ArrayList和LinkedList在使用上的不同</h2><p>其实很简单了，就是两种数据结构的不同。<code>ArrayList</code>按照<code>index</code>进行查询十分高效，但是删除和添加元素的过程涉及数据的<code>copy</code>操作，效率较低，但是删除末尾元素的话效率可是不低的，因为不涉及<code>copy</code>操作。<code>LinkedList</code>正好相反，按照<code>index</code>查询十分低效，但是删除和添加元素很高效，因为使用的链表的结构，数据在内存中是分散的。</p><p>总体来说比较容易区分两种类型的数据的使用场景，关键还是在于对jdk源码的理解，搞清楚数据和链表常用操作都是怎么实现的。下面是一些源码与注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 在末尾添加元素只有在数组元素不够的时候才会触发grow操作，也就是Arrays.copyof操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在指定位置插入的话，不光涉及上面的情况，还需要进行System.arraycopy操作移动数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用index进行删除，如果index不是最后一个才会触发System.arraycopy</span></span><br><span class="line">    <span class="comment">// 所以数组进行末尾删除的时候效率还是很高的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                                numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接删除一个对象的话就是涉及到循环查找对象了。fastRemove跟remove基本一样，只是没有返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 核心就是linkLast操作，很简单</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 核心是unlink操作，由于LinkedList是双向链表，操作起来不要太容易，效率不要太高。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除指定小标的元素，首先会遍历数组找到这个元素。方法就是node(index)方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样是遍历的问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        E oldVal = x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java的List总结&quot;&gt;&lt;a href=&quot;#Java的List总结&quot; class=&quot;headerlink&quot; title=&quot;Java的List总结&quot;&gt;&lt;/a&gt;Java的List总结&lt;/h1&gt;&lt;h2 id=&quot;ArrayList和LinkedList在使用上的不同&quot;&gt;
      
    
    </summary>
    
      <category term="Java知识" scheme="http://yoursite.com/categories/Java%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java知识" scheme="http://yoursite.com/tags/Java%E7%9F%A5%E8%AF%86/"/>
    
      <category term="ArrayList" scheme="http://yoursite.com/tags/ArrayList/"/>
    
      <category term="LinkedList" scheme="http://yoursite.com/tags/LinkedList/"/>
    
      <category term="List" scheme="http://yoursite.com/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>Java中关于String的总结</title>
    <link href="http://yoursite.com/2018/04/19/notebook/learn_java/java%E7%9A%84String%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/19/notebook/learn_java/java的String总结/</id>
    <published>2018-04-19T08:54:43.890Z</published>
    <updated>2018-04-19T08:54:43.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java中关于String的总结"><a href="#Java中关于String的总结" class="headerlink" title="Java中关于String的总结"></a>Java中关于String的总结</h1><p>参考资料：</p><ul><li><a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析String#intern</a></li><li><a href="http://www.importnew.com/7418.html" target="_blank" rel="noopener">JDK6和JDK7中的substring()方法</a></li><li><a href="https://blog.csdn.net/zhangjg_blog/article/details/21486985" target="_blank" rel="noopener">深入理解Java Class文件格式（系列一到九）</a></li><li><a href="https://coolshell.cn/articles/9229.html" target="_blank" rel="noopener">实例分析JAVA CLASS的文件结构</a></li><li><a href="https://blog.csdn.net/songylwq/article/details/7028010" target="_blank" rel="noopener">java StringUtils方法全览</a></li></ul><h2 id="Java面试的几个小问题"><a href="#Java面试的几个小问题" class="headerlink" title="Java面试的几个小问题"></a>Java面试的几个小问题</h2><ol><li><p>如何比较两个字符串？使用“==”还是equals()方法？<br>比较字符串指针是否相等用==，只判断值的话就是equals()</p></li><li><p><code>String a = new String(&quot;Hello World&quot;)</code>创建了几个对象？<br>2个。看下面调用构造方法的源码，注意到传入的参数也是一个String对象，因此<code>new String(&quot;Hello World&quot;)</code>创建的第一个对象是构造器里的参数对象相当于<code>String original=&quot;Hello World&quot;</code>，第二个对象是<code>new</code>的返回值。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>为什么针对安全保密高的信息，char[]比String更好?<br>因为String是不可变的，就是说它一旦创建，就不能更改了，直到垃圾收集器将它回收走。而字符数组中的元素是可以更改的（译者注：这就意味着你就可以在使用完之后将其更改，而不会保留原始的数据）。所以使用字符数组的话，安全保密性高的信息(如密码之类的)将不会存在于系统中被他人看到。</p></li><li><p>我们可以针对字符串使用switch条件语句吗？<br>从JDK 7开始, 可以针对字符串使用switch条件语句了；在JDK 6或者之前的版本，不能使用switch条件语句。</p></li><li><p>String是否是线程安全的？<br>因为String是final类型的，所以一定是线程安全的。</p></li><li>String为什么是不可变的，final的类有什么好处？<br>首先是线程安全，第二是节约空间提高访问效率。</li></ol><h2 id="Java中不同的String创建方式"><a href="#Java中不同的String创建方式" class="headerlink" title="Java中不同的String创建方式"></a>Java中不同的String创建方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showInPng</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="comment">// 使用 " " 双引号创建</span></span><br><span class="line">    String s1 = <span class="string">"first"</span>;</span><br><span class="line">    <span class="comment">// 使用字符串连接符拼接</span></span><br><span class="line">    String s2 = <span class="string">"se"</span>+<span class="string">"cond"</span>;</span><br><span class="line">    <span class="comment">// 使用字符串加引用拼接</span></span><br><span class="line">    String s12 = <span class="string">"first"</span> + s2; <span class="comment">// 注意这个是运行期间动态分配的</span></span><br><span class="line">    <span class="comment">// 使用new String("")创建</span></span><br><span class="line">    String s3 = <span class="keyword">new</span> String(<span class="string">"three"</span>);</span><br><span class="line">    <span class="comment">// 使用new String("")拼接</span></span><br><span class="line">    String s4 = <span class="keyword">new</span> String(<span class="string">"fo"</span>) + <span class="string">"ur"</span>;</span><br><span class="line">    <span class="comment">// 使用new String("")拼接</span></span><br><span class="line">    String s5 = <span class="keyword">new</span> String(<span class="string">"fo"</span>) + <span class="keyword">new</span> String(<span class="string">"ur"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="JavaString.png" alt="JavaString"></p><h2 id="String-StringBuilder-StringBuffer之间的差别与使用习惯"><a href="#String-StringBuilder-StringBuffer之间的差别与使用习惯" class="headerlink" title="String, StringBuilder, StringBuffer之间的差别与使用习惯"></a>String, StringBuilder, StringBuffer之间的差别与使用习惯</h2><p>String vs StringBuilder: StringBuilder是可变的，这意味着它创建之后仍旧可以更改它的值。</p><p>StringBuilder vs StringBuffer: StringBuffer是synchronized的,它是线程安全的的，但是比StringBuilder要慢。</p><h2 id="String-intern-方法分析"><a href="#String-intern-方法分析" class="headerlink" title="String.intern()方法分析"></a><code>String.intern()</code>方法分析</h2><p><code>intern()</code>方法描述起来很简单：如果常量池中存在当前字符串, 就会直接返回当前字符串. 如果常量池中没有此字符串, 会将此字符串放入常量池中后, 再返回。有趣的是在jdk的发展过程中，jvm的变化可能导致一些不太一样的结果。就大多数时候而言，并不影响使用。详情参见<a href="https://tech.meituan.com/in_depth_understanding_string_intern.html" target="_blank" rel="noopener">深入解析String#intern</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> act.chenkh.study.test.bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringAck</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">StringAck ack = <span class="keyword">new</span> StringAck();</span><br><span class="line">ack.testIntern();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIntern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">s.intern();</span><br><span class="line">System.out.println(s == s2);</span><br><span class="line">System.out.println(s.intern() == s2);</span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// s3进行intern操作后将"11"这个字符串放进了常量池中，</span></span><br><span class="line"><span class="comment">// 但是常量池也在heap里面(from jdk7)，常量池直接引用heap中的引用。</span></span><br><span class="line"><span class="comment">// 所以相当于把s3指向的地址变成了常量池中的地址。</span></span><br><span class="line">s3.intern();</span><br><span class="line"><span class="comment">// s4创建的时候先看常量池有没有"11"，发现有，所以返回与s3相同的引用。</span></span><br><span class="line">String s4 = <span class="string">"11"</span>;</span><br><span class="line">System.out.println(s3 == s4);</span><br><span class="line"></span><br><span class="line">String s5 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">String s6 = <span class="string">"11"</span>;</span><br><span class="line">System.out.println(s5 == s6);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StringUtils工具"><a href="#StringUtils工具" class="headerlink" title="StringUtils工具"></a>StringUtils工具</h2><p>StringUtils位于org.apache.commons.lang包下，引用时需要导入。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重复一个字符串</span></span><br><span class="line">String str = <span class="string">"abcd"</span>;</span><br><span class="line">String repeated = StringUtils.repeat(str,<span class="number">3</span>); <span class="comment">//abcdabcdabcd</span></span><br><span class="line"><span class="comment">// 计算一个字符串某个字符的出现次数</span></span><br><span class="line"><span class="keyword">int</span> n = StringUtils.countMatches(<span class="string">"11112222"</span>, <span class="string">"1"</span>);</span><br><span class="line">System.out.println(n);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java中关于String的总结&quot;&gt;&lt;a href=&quot;#Java中关于String的总结&quot; class=&quot;headerlink&quot; title=&quot;Java中关于String的总结&quot;&gt;&lt;/a&gt;Java中关于String的总结&lt;/h1&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;
      
    
    </summary>
    
      <category term="Java知识" scheme="http://yoursite.com/categories/Java%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>java根类Object的说明</title>
    <link href="http://yoursite.com/2018/04/19/notebook/learn_java/java%E6%A0%B9%E7%B1%BBobject%E7%9A%84%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/04/19/notebook/learn_java/java根类object的说明/</id>
    <published>2018-04-19T08:54:43.889Z</published>
    <updated>2018-04-19T08:54:43.889Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java根类Object的说明"><a href="#Java根类Object的说明" class="headerlink" title="Java根类Object的说明"></a>Java根类Object的说明</h1><!-- TOC --><ul><li><a href="#1-初识object">1. 初识Object</a></li><li><a href="#2-方法分析">2. 方法分析</a><ul><li><a href="#21-registernatives">2.1. registerNatives()</a></li><li><a href="#22-getclass">2.2. getClass()</a></li><li><a href="#23-hashcode">2.3. hashCode()</a></li><li><a href="#24-equals">2.4. equals()</a></li><li><a href="#25-clone">2.5. clone()</a></li><li><a href="#26-tostring">2.6. toString()</a></li><li><a href="#27-notify">2.7. notify()</a></li><li><a href="#28-notifyall">2.8. notifyAll()</a></li><li><a href="#29-waitlong-timeout-throws-">2.9. wait(long timeout) throws …</a></li><li><a href="#210-finalize">2.10. finalize()</a></li></ul></li></ul><!-- /TOC --><p>参考资料：</p><ul><li><a href="https://fangjian0423.github.io/2016/03/12/java-Object-method/" target="_blank" rel="noopener">Java根类Object的方法说明</a></li><li><a href="https://zhuanlan.zhihu.com/p/29511703" target="_blank" rel="noopener">java object类详解</a><h2 id="1-初识Object"><a href="#1-初识Object" class="headerlink" title="1. 初识Object"></a>1. 初识Object</h2></li><li>Object类是Java中其他所有类的父类。</li><li>Object类位于java.lang包中，java.lang包包含着Java最基础和核心的类，在编译时会自动导入</li><li>可以使用类型为Object的变量指向任意类型的对象。</li><li>Object类有一个默认构造方法pubilc Object()，在构造子类实例时，都会先调用这个默认构造方法。</li><li><p>Object类的变量只能用作各种值的通用持有者。要对他们进行任何专门的操作，都需要知道它们的原始类型并进行类型转换。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> MyObject();</span><br><span class="line">MyObject x = (MyObject)obj;</span><br></pre></td></tr></table></figure></li><li><p>Object类没有定义属性，一共有13个方法，具体的类定义结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.Object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            timeout++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        wait(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-方法分析"><a href="#2-方法分析" class="headerlink" title="2. 方法分析"></a>2. 方法分析</h2><p>分析Object最基本的方法是本文的主要内容。</p><h3 id="2-1-registerNatives"><a href="#2-1-registerNatives" class="headerlink" title="2.1. registerNatives()"></a>2.1. registerNatives()</h3><p>native方法。</p><p>native关键字修饰的函数表明该方法的实现并不是在Java中去完成，而是由C/C++去完成，并被编译成了.dll，由Java去调用</p><p>其主要作用是将C/C++中的方法映射到Java中的native方法，实现方法命名的解耦。所以类加载时首先执行的就是这个函数。</p><h3 id="2-2-getClass"><a href="#2-2-getClass" class="headerlink" title="2.2. getClass()"></a>2.2. getClass()</h3><p>native方法：返回此对象的类对象。</p><p><strong>类对象解释</strong></p><blockquote><p>在Java中，类是是对具有一组相同特征或行为的实例的抽象并进行描述，对象则是此类所描述的特征或行为的具体实例。作为概念层次的类，其本身也具有某些共同的特性，如都具有类名称、由类加载器去加载，都具有包，具有父类，属性和方法等。于是，Java中有专门定义了一个类，Class，去描述其他类所具有的这些特性，因此，从此角度去看，类本身也都是属于Class类的对象。为与经常意义上的对象相区分，在此称之为”类对象”。</p></blockquote><h3 id="2-3-hashCode"><a href="#2-3-hashCode" class="headerlink" title="2.3. hashCode()"></a>2.3. hashCode()</h3><p>hashCode()具有如下约定：</p><ol><li><p>在Java应用程序执行期间，对于同一对象多次调用hashCode()方法时，其返回的哈希码是相同的，前提是将对象进行equals比较时所用的标尺信息未做修改。在Java应用程序的一次执行到另外一次执行，同一对象的hashCode()返回的哈希码无须保持一致；</p></li><li><p>如果两个对象相等（依据：调用equals()方法），那么这两个对象调用hashCode()返回的哈希码也必须相等；</p></li><li><p>反之，两个对象调用hasCode()返回的哈希码相等，这两个对象不一定相等。</p></li></ol><h3 id="2-4-equals"><a href="#2-4-equals" class="headerlink" title="2.4. equals()"></a>2.4. equals()</h3><p>默认是同一个对象才能相等，但是可以进行覆盖啊。覆盖equals需要遵守一些规定：</p><ul><li>自反性 (reflexive)：对于任何一个非null的引用值x，x.equals(x)为true。</li><li>对称性 (symmetric)：对于任何一个非null的引用值x和y，x.equals(y)为true时y.equals(x)为true。</li><li>传递性 (transitive)：对于任何一个非null的引用值x、y和z，当x.equals(y)为true 且 y.equals(z)为true 则 x.equals(z)为true。</li><li>一致性 (consistent)：对于任何一个非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)的结果依然一致。<br>(PS：对于任何非null的引用值x，x.equals(null)必须返回false。)</li></ul><p><strong>Java中的约定：重写equals()方法必须重写hasCode()方法</strong>。其关键问题在于，<code>public V get(Object key)</code>使用get等方法的时候，这里的key是Object类型，而不是泛型K。至于原因，参见<a href="https://stackoverflow.com/questions/857420/what-are-the-reasons-why-map-getobject-key-is-not-fully-generic" target="_blank" rel="noopener">StackOverFlow: What are the reasons why Map.get(Object key) is not (fully) generic</a>。因此，如果equals重写了，但是hashCode没有重写的话，很有可能造成equals相等，但是hashcode不相同。</p><p>参考：</p><ul><li><a href="http://www.cnblogs.com/kavlez/p/4185547.html" target="_blank" rel="noopener">Java - 谨慎覆盖equals</a>：提到了很多注意点，以及建议覆盖equals和hashCode的技巧。</li><li><a href="https://blog.csdn.net/javazejian/article/details/51348320" target="_blank" rel="noopener">重写equal()时为什么也得重写hashCode()之深度解读equal方法与hashCode方法渊源</a><h3 id="2-5-clone"><a href="#2-5-clone" class="headerlink" title="2.5. clone()"></a>2.5. clone()</h3>native方法。</li></ul><p>protected修饰：在同一个包内或者不同包的子类可以访问。（不同包的情况下，必须是子类的引用主动调用方法，原父类调用是不行的）</p><p>java语法规定：clone()的正确调用是需要实现Cloneable接口，如果没有实现Cloneable接口，并且子类直接调用Object类的clone()方法，则会抛出CloneNotSupportedException异常。</p><h3 id="2-6-toString"><a href="#2-6-toString" class="headerlink" title="2.6. toString()"></a>2.6. toString()</h3><h3 id="2-7-notify"><a href="#2-7-notify" class="headerlink" title="2.7. notify()"></a>2.7. notify()</h3><h3 id="2-8-notifyAll"><a href="#2-8-notifyAll" class="headerlink" title="2.8. notifyAll()"></a>2.8. notifyAll()</h3><h3 id="2-9-wait-long-timeout-throws-…"><a href="#2-9-wait-long-timeout-throws-…" class="headerlink" title="2.9. wait(long timeout) throws …"></a>2.9. wait(long timeout) throws …</h3><h3 id="2-10-finalize"><a href="#2-10-finalize" class="headerlink" title="2.10. finalize()"></a>2.10. finalize()</h3><p>finalize方法主要与Java垃圾回收机制有关。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java根类Object的说明&quot;&gt;&lt;a href=&quot;#Java根类Object的说明&quot; class=&quot;headerlink&quot; title=&quot;Java根类Object的说明&quot;&gt;&lt;/a&gt;Java根类Object的说明&lt;/h1&gt;&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="Java知识" scheme="http://yoursite.com/categories/Java%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java知识" scheme="http://yoursite.com/tags/Java%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程总结</title>
    <link href="http://yoursite.com/2018/04/19/notebook/learn_java/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/04/19/notebook/learn_java/java多线程总结/</id>
    <published>2018-04-19T08:54:43.888Z</published>
    <updated>2018-04-19T08:54:43.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java多线程总结"><a href="#Java多线程总结" class="headerlink" title="Java多线程总结"></a>Java多线程总结</h1><h2 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h2><h2 id="Java线程的生命周期"><a href="#Java线程的生命周期" class="headerlink" title="Java线程的生命周期"></a>Java线程的生命周期</h2><p>参考：<a href="https://www.cnblogs.com/sunddenly/p/4106562.html" target="_blank" rel="noopener">线程的生命周期</a></p><ul><li>新建(New)、就绪（Runnable）、运行（Running）、阻塞(Blocked)和死亡(Dead)5种状态</li></ul><ol><li>新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值</li><li>就绪状态，当线程对象调用了<code>start()</code>方法之后，该线程处于就绪状态。<strong>Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行</strong></li><li>运行状态，如果处于就绪状态的线程获得了CPU，开始执行<code>run()</code>方法的线程执行体，则该线程处于运行状态</li><li>阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态</li><li>在线程的生命周期当中，线程的各种状态的转换过程</li></ol><p><img src="线程状态转换图.png" alt="线程状态转换图"></p><h2 id="Thread和Runnable的区别与联系"><a href="#Thread和Runnable的区别与联系" class="headerlink" title="Thread和Runnable的区别与联系"></a>Thread和Runnable的区别与联系</h2><h2 id="线程池-ThreadPool"><a href="#线程池-ThreadPool" class="headerlink" title="线程池: ThreadPool"></a>线程池: ThreadPool</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java多线程总结&quot;&gt;&lt;a href=&quot;#Java多线程总结&quot; class=&quot;headerlink&quot; title=&quot;Java多线程总结&quot;&gt;&lt;/a&gt;Java多线程总结&lt;/h1&gt;&lt;h2 id=&quot;线程与进程的区别&quot;&gt;&lt;a href=&quot;#线程与进程的区别&quot; class=&quot;
      
    
    </summary>
    
      <category term="Java知识" scheme="http://yoursite.com/categories/Java%E7%9F%A5%E8%AF%86/"/>
    
      <category term="多线程" scheme="http://yoursite.com/categories/Java%E7%9F%A5%E8%AF%86/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Java知识" scheme="http://yoursite.com/tags/Java%E7%9F%A5%E8%AF%86/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java.io与Java.nio总结</title>
    <link href="http://yoursite.com/2018/04/19/notebook/learn_java/java.io%E4%B8%8Ejava.nio/"/>
    <id>http://yoursite.com/2018/04/19/notebook/learn_java/java.io与java.nio/</id>
    <published>2018-04-19T08:54:43.863Z</published>
    <updated>2018-04-19T08:54:43.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-IO"><a href="#Java-IO" class="headerlink" title="Java IO"></a>Java IO</h2><h3 id="java读取文件有哪几种方法，区别是什么"><a href="#java读取文件有哪几种方法，区别是什么" class="headerlink" title="java读取文件有哪几种方法，区别是什么"></a>java读取文件有哪几种方法，区别是什么</h3><p>参考：</p><ul><li><a href="http://www.cnblogs.com/lovebread/archive/2009/11/23/1609122.html" target="_blank" rel="noopener">Java文件读取方式</a></li><li><a href="https://zhuanlan.zhihu.com/p/28757397" target="_blank" rel="noopener">Java IO流学习总结</a></li></ul><p><img src="IOStream.png" alt="IO Stream"><br><img src="java_io_byte.png" alt="java_io_byte"><br><img src="javaio.png" alt="javaio"></p><ol><li>按字节读取文件内容：常用于读二进制文件，如图片、声音、影像等文件。</li><li>按字符读取文件内容：以字符为单位读取文件，常用于读文本，数字等类型的文件</li><li>按行读取文件内容：以行为单位读取文件，常用于读面向行的格式化文件</li><li>随机读取文件内容 </li></ol><ul><li>关于一次性读取文件内容：<br>一次性读取文件比按行读取效率要高很多，因为每次调用readLine()方法都需要转换编码，而一次性读取只需要转换一次。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readToString</span><span class="params">(String fileName)</span> </span>&#123;  </span><br><span class="line">        String encoding = <span class="string">"ISO-8859-1"</span>;  </span><br><span class="line">        File file = <span class="keyword">new</span> File(fileName);  </span><br><span class="line">        Long filelength = file.length();  </span><br><span class="line">        <span class="keyword">byte</span>[] filecontent = <span class="keyword">new</span> <span class="keyword">byte</span>[filelength.intValue()];  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            FileInputStream in = <span class="keyword">new</span> FileInputStream(file);  </span><br><span class="line">            in.read(filecontent);  </span><br><span class="line">            in.close();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(filecontent, encoding);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;  </span><br><span class="line">            System.err.println(<span class="string">"The OS does not support "</span> + encoding);  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>参考：</p><ul><li><a href="https://tech.meituan.com/nio.html" target="_blank" rel="noopener">Java nio浅析</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">NIO 入门</a></li><li><a href="http://ifeve.com/java-nio-all/" target="_blank" rel="noopener">Java NIO 系列教程</a></li><li><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">Java NIO Tutorials</a><h3 id="什么是java-nio"><a href="#什么是java-nio" class="headerlink" title="什么是java.nio?"></a>什么是java.nio?</h3>NIO（Non-blocking I/O，在Java领域，也称为New I/O），是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。</li></ul><h3 id="与io的主要区别"><a href="#与io的主要区别" class="headerlink" title="与io的主要区别"></a>与io的主要区别</h3><table><thead><tr><th style="text-align:left">IO</th><th style="text-align:left">NIO</th></tr></thead><tbody><tr><td style="text-align:left">面向流</td><td style="text-align:left">面向缓冲</td></tr><tr><td style="text-align:left">阻塞IO</td><td style="text-align:left">非阻塞IO</td></tr><tr><td style="text-align:left">无</td><td style="text-align:left">选择器</td></tr></tbody></table><ul><li><p>面向流与面向缓冲<br>Java NIO和IO之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p></li><li><p>阻塞与非阻塞IO<br>Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p></li><li><p>选择器（Selectors）<br>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这种选择机制，使得一个单独的线程很容易来管理多个通道。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-IO&quot;&gt;&lt;a href=&quot;#Java-IO&quot; class=&quot;headerlink&quot; title=&quot;Java IO&quot;&gt;&lt;/a&gt;Java IO&lt;/h2&gt;&lt;h3 id=&quot;java读取文件有哪几种方法，区别是什么&quot;&gt;&lt;a href=&quot;#java读取文件有哪几种方
      
    
    </summary>
    
      <category term="Java知识" scheme="http://yoursite.com/categories/Java%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="Java知识" scheme="http://yoursite.com/tags/Java%E7%9F%A5%E8%AF%86/"/>
    
      <category term="io" scheme="http://yoursite.com/tags/io/"/>
    
      <category term="nio" scheme="http://yoursite.com/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop面试内容整理</title>
    <link href="http://yoursite.com/2018/04/19/notebook/learn_hadoop/Hadoop%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/19/notebook/learn_hadoop/Hadoop知识整理/</id>
    <published>2018-04-19T08:54:43.831Z</published>
    <updated>2018-04-19T08:54:43.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hadoop面试内容整理"><a href="#Hadoop面试内容整理" class="headerlink" title="Hadoop面试内容整理"></a>Hadoop面试内容整理</h1><p>Hadoop的面试内容主要分为3各部分，首先接触过Hadoop的一定会问MapReduce编程模型的详细过程，然后可以问一些文件系统的东西，最后可能问一下与Hadoop相关的衍生品：HBase等。</p><ul><li>MapReduce</li><li>Hadoop Distributed File System（HDFS）  </li><li>HBase等  </li></ul><p>参考资料： </p><ul><li><a href="https://www.jianshu.com/p/c97ff0ab5f49" target="_blank" rel="noopener">Hadoop 面试，有它就够了</a>、<a href="http://k.sina.com.cn/article_1708729084_65d922fc034002mnt.html" target="_blank" rel="noopener">同名另外一版本</a></li><li><a href="https://my.oschina.net/itblog/blog/275294" target="_blank" rel="noopener">Hadoop MapReduce执行过程详解（带hadoop例子）</a></li><li><a href="https://www.csdn.net/article/2014-02-17/2818431-HDFS+MapReduce+Hbase" target="_blank" rel="noopener">Hadoop核心架构HDFS+MapReduce+Hbase+Hive内部机理详解</a></li></ul><h2 id="Hadoop-MapReduce"><a href="#Hadoop-MapReduce" class="headerlink" title="Hadoop MapReduce"></a>Hadoop MapReduce</h2><p>只要搞懂下面这个架构图就可以了。<br><img src="https://upload-images.jianshu.io/upload_images/697231-2fd012f3d2074e26" alt="MR架构"></p><p>下面把这个过程分为Mapper和Reducer两个阶段进行分析。</p><h3 id="Mapper任务的执行过程详解"><a href="#Mapper任务的执行过程详解" class="headerlink" title="Mapper任务的执行过程详解"></a>Mapper任务的执行过程详解</h3><p>每个Mapper是一个java进程，Mapper之间做的工作都一样，数量可以配置。任务执行过程如下。</p><ol><li><p><strong>InputSplit</strong>：把输入文件按照一定的标准分片，每个输入片的大小是固定的。默认情况下，输入片(InputSplit)的大小与数据块(Block)的大小是相同的，默认值64MB。输入文件有两个，一个是32MB，一个是72MB。那么小的文件是一个输入片，大文件会分为两个数据块，那么是两个输入片。一共产生三个输入片。每一个输入片由一个Mapper进程处理。这里的三个输入片，会有三个Mapper进程处理。</p></li><li><p><strong>Map Phase</strong>：其实有两个阶段，如果我们看<code>WordCount</code>的源码就会发现，<code>Mapper</code>的输入包含<code>Object key, Text value, Context context</code>，输入已经包含了key-value对。根据第一步输入的分片，首先按行划分成key=行号，value=行内容的结构，然后Mapper使用map函数对没一个键值对进行处理，可以对value进行进一步的单词划分。其输出结果是单词-计数级别的键值对。</p></li><li><p><strong>Partition</strong>：对第二步的输出进行基于key的分区，分区数量与reducer数量相当。这样相同key的数据就到了一个分区中。</p></li><li><p><strong>Sort</strong>：相同分区中的键值对进行按照先键后值的比较方式排序。</p></li><li><p><strong>Combine</strong>：排序完成后，相同key（也相邻）进行整合以减少网络开销。一次partition级别的reduce</p></li></ol><p>注意：为了减少网络开销，每个Mapper设置一个缓冲区，并设置一个溢出值，分别为100M和0.8。当数据量大的时候会有多个溢出文件，在进入Reduce阶段会进行多个溢出文件整合。</p><h3 id="Reducer任务的执行过程详解"><a href="#Reducer任务的执行过程详解" class="headerlink" title="Reducer任务的执行过程详解"></a>Reducer任务的执行过程详解</h3><ol><li><p>第一阶段是Reducer任务会主动从Mapper任务复制其输出的键值对。Mapper任务可能会有很多，因此Reducer会复制多个Mapper的输出。</p></li><li><p>第二阶段是把复制到Reducer本地数据，全部进行合并，即把分散的数据合并成一个大的数据。再对合并后的数据排序。这里复制的数据是某个<code>key.hash()</code>的partition数据，然后多个partition的数据进行融合。</p></li><li><p>第三阶段是对排序后的键值对调用reduce方法。键相等的键值对调用一次reduce方法，每次调用会产生零个或者多个键值对。最后把这些输出的键值对写入到HDFS文件中。</p></li></ol><p>注意：由于一次Reducer处理过程只处理某相同<code>key.hash()</code>的分区，因此多个reducer的结果数据不需要合并。</p><h2 id="Hadoop-Distributed-File-System"><a href="#Hadoop-Distributed-File-System" class="headerlink" title="Hadoop Distributed File System"></a>Hadoop Distributed File System</h2><p><img src="https://hadoop.apache.org/docs/r1.0.4/cn/images/hdfsarchitecture.gif" alt="HDFS架构1"></p><p>参考：</p><ul><li><a href="https://hadoop.apache.org/docs/r1.0.4/cn/hdfs_design.html" target="_blank" rel="noopener">Hadoop分布式文件系统：架构与设计</a>：这是很早的一个文档，不过也挺有参考价值。</li><li><a href="https://hadoop.apache.org/docs/r2.8.0/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html#HDFS_Architecture" target="_blank" rel="noopener">HDFS_Architecture</a>：上个文件比较新的版本，基本内容差不多。</li><li><a href="https://troywu0.gitbooks.io/spark/content/hdfs.html" target="_blank" rel="noopener">HDFS·面试宝典</a>：简略版面试总结，看完上面详细的文档之后可以看一下这个，梳理主要内容。</li></ul><h3 id="总结性介绍"><a href="#总结性介绍" class="headerlink" title="总结性介绍"></a>总结性介绍</h3><ul><li>Hadoop分布式文件系统(HDFS)被设计成适合运行在通用硬件(commodity hardware)上的分布式文件系统。</li><li>HDFS是一个高度容错性的系统，适合部署在廉价的机器上。</li><li>HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。</li></ul><h3 id="一些缺点"><a href="#一些缺点" class="headerlink" title="一些缺点"></a>一些缺点</h3><ul><li>不适合低延迟数据访问</li><li>无法高效存储大量小文件</li><li>不支持多用户写入及任意修改文件。<blockquote><p>副本系数可以在文件创建的时候指定，也可以在之后改变。HDFS中的文件都是一次性写入的，并且<strong>严格要求在任何时候只能有一个写入者</strong></p></blockquote><h3 id="简化的一致性模型"><a href="#简化的一致性模型" class="headerlink" title="简化的一致性模型"></a>简化的一致性模型</h3>HDFS应用需要一个“一次写入多次读取”的文件访问模型。一个文件经过创建、写入和关闭之后就不需要改变。这一假设简化了数据一致性问题，并且使高吞吐量的数据访问成为可能。Map/Reduce应用或者网络爬虫应用都非常适合这个模型。目前还有计划在将来扩充这个模型，使之支持文件的附加写操作。</li></ul><h2 id="Hadoop-DataBase"><a href="#Hadoop-DataBase" class="headerlink" title="Hadoop DataBase"></a>Hadoop DataBase</h2><p>参见: <a href="HBase知识整理.md">HBase知识整理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hadoop面试内容整理&quot;&gt;&lt;a href=&quot;#Hadoop面试内容整理&quot; class=&quot;headerlink&quot; title=&quot;Hadoop面试内容整理&quot;&gt;&lt;/a&gt;Hadoop面试内容整理&lt;/h1&gt;&lt;p&gt;Hadoop的面试内容主要分为3各部分，首先接触过Hadoo
      
    
    </summary>
    
      <category term="分布式系统" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Hadooop" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/Hadooop/"/>
    
    
      <category term="分布式系统" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>HBase面试整理</title>
    <link href="http://yoursite.com/2018/04/19/notebook/learn_hadoop/HBase%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/19/notebook/learn_hadoop/HBase知识整理/</id>
    <published>2018-04-19T08:54:43.830Z</published>
    <updated>2018-04-19T08:54:43.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HBase面试整理"><a href="#HBase面试整理" class="headerlink" title="HBase面试整理"></a>HBase面试整理</h1><!-- TOC --><ul><li><a href="#1-总结性介绍">1. 总结性介绍</a></li><li><a href="#2-存储结构">2. 存储结构</a></li></ul><!-- /TOC --><p>参考资料：</p><ul><li><a href="http://www.ixirong.com/2015/07/16/learn-about-hbase/" target="_blank" rel="noopener">列式存储hbase系统架构学习</a></li><li><a href="https://blog.csdn.net/woshiwanxin102213/article/details/17584043" target="_blank" rel="noopener">Hbase原理、基本概念、基本架构</a></li><li><a href="http://blog.javachen.com/2013/06/15/hbase-note-about-data-structure.html" target="_blank" rel="noopener">HBase笔记：存储结构</a></li></ul><h2 id="1-总结性介绍"><a href="#1-总结性介绍" class="headerlink" title="1. 总结性介绍"></a>1. 总结性介绍</h2><ul><li>HBase是一个构建在HDFS上的分布式列存储系统，是基于Google BigTable模型开发的，典型的key/value系统。</li><li>与传统mysql、Oracle数据库的主要区别就是列式存储和夯实存储的区别。</li><li>Hbase适合大量插入同时又有读的情况。输入一个Key获取一个value或输入一些key获得一些value。</li><li>Hbase目标主要依靠横向扩展，通过不断增加廉价的商用服务器，来增加计算和存储能力。</li><li>Hbase表的特点<ul><li>大：一个表可以有数十亿行，上百万列；</li><li>无模式：每行都有一个可排序的主键和任意多的列，列可以根据需要动态的增加，同一张表中不同的行可以有截然不同的列；</li><li>面向列：面向列（族）的存储和权限控制，列（族）独立检索；</li><li>稀疏：空（null）列并不占用存储空间，表可以设计的非常稀疏；</li><li>数据多版本：每个单元中的数据可以有多个版本，默认情况下版本号自动分配，是单元格插入时的时间戳；</li><li>数据类型单一：Hbase中的数据都是字符串，没有类型。</li></ul></li></ul><h2 id="2-存储结构"><a href="#2-存储结构" class="headerlink" title="2. 存储结构"></a>2. 存储结构</h2><p><img src="hbase_structure.png" alt="HBase架构1"></p><p>Zookeeper：</p><ul><li>保证任何时候，集群中只有一个master</li><li>存贮所有Region的寻址入口。</li><li>实时监控Region Server的状态，将Region server的上线和下线信息实时通知给Master</li><li>存储Hbase的schema,包括有哪些table，每个table有哪些column family</li></ul><p>HMaster: </p><ul><li>为Region server分配region，负责region server的负载均衡</li><li>管理用户对Table的增、删、改、查操作</li><li>发现失效的region server并重新分配其上的region</li><li>GFS上的垃圾文件回收</li><li>在HRegionServer停机后，负责失效HRegionServer 上的Regions迁移<blockquote><p>client访问Hbase上数据的过程并不需要master参与(寻址访问zookeeper和region server，数据读写访问regione server)，master仅仅维护着<strong>table</strong>和<strong>region</strong>的元数据信息，负载很低。</p></blockquote></li></ul><p>HRegion Server</p><ul><li>Region server维护Master分配给它的region，处理对这些region的IO请求</li><li>Region server负责切分在运行过程中变得过大的region</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HBase面试整理&quot;&gt;&lt;a href=&quot;#HBase面试整理&quot; class=&quot;headerlink&quot; title=&quot;HBase面试整理&quot;&gt;&lt;/a&gt;HBase面试整理&lt;/h1&gt;&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-总结性介绍&quot;&gt;1. 总
      
    
    </summary>
    
      <category term="分布式系统" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="HBase" scheme="http://yoursite.com/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/HBase/"/>
    
    
      <category term="分布式系统" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="HBase" scheme="http://yoursite.com/tags/HBase/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构：跳跃表</title>
    <link href="http://yoursite.com/2018/04/19/notebook/data_struc_algo/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/04/19/notebook/data_struc_algo/跳跃表/</id>
    <published>2018-04-19T08:54:43.828Z</published>
    <updated>2018-04-19T08:54:43.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构：跳跃表"><a href="#数据结构：跳跃表" class="headerlink" title="数据结构：跳跃表"></a>数据结构：跳跃表</h1><p>参考：</p><ul><li><a href="http://www.duyongfeng.com/2016/12/22/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8-Skip-list-%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">跳跃列表(Skip list)原理和实现</a></li><li><a href="https://www.ezlippi.com/blog/2014/12/skip-list.html" target="_blank" rel="noopener">skip list跳跃表实现</a></li></ul><h2 id="看图识表"><a href="#看图识表" class="headerlink" title="看图识表"></a>看图识表</h2><p>其实就是每个节点都存储一个动态的数组，充当索引的角色。</p><p><img src="skiplist.png" alt="跳跃表"></p><h2 id="数据结构分析"><a href="#数据结构分析" class="headerlink" title="数据结构分析"></a>数据结构分析</h2><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>代码来自：<a href="http://www.duyongfeng.com/2016/12/22/%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8-Skip-list-%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">跳跃列表(Skip list)原理和实现</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipNode</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">K k;</span><br><span class="line">V v;</span><br><span class="line">SkipNode&lt;K, V&gt;[] forward;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipNode</span><span class="params">(K k, V v, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.k = k;</span><br><span class="line"><span class="keyword">this</span>.v = v;</span><br><span class="line">forward = (SkipNode&lt;K, V&gt;[]) <span class="keyword">new</span> SkipNode[level + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">forward[i] = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"SkipNode [k="</span> + k + <span class="string">", v="</span> + v + <span class="string">", forward="</span> + Arrays.toString(forward) + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkipList</span>&lt;<span class="title">K</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;? <span class="title">super</span> <span class="title">K</span>&gt;, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">SkipNode&lt;K, V&gt; head;</span><br><span class="line"><span class="keyword">int</span> level;</span><br><span class="line"><span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SkipList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">head = <span class="keyword">new</span> SkipNode&lt;K, V&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 刚开始只有一层，也就是第0层</span></span><br><span class="line">level = <span class="number">0</span>;</span><br><span class="line">size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:随机生成层数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:int</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">randomLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lev;</span><br><span class="line"><span class="keyword">for</span> (lev = <span class="number">1</span>; Util.random(<span class="number">2</span>) == <span class="number">0</span>; lev++)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(K k, V v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> newLevel = randomLevel();</span><br><span class="line"><span class="comment">// 调整头节点</span></span><br><span class="line"><span class="keyword">if</span> (newLevel &gt; level) &#123;</span><br><span class="line">SkipNode&lt;K, V&gt; tmp = head;</span><br><span class="line">head = <span class="keyword">new</span> SkipNode&lt;K, V&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, newLevel);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.forward.length; i++) &#123;</span><br><span class="line">head.forward[i] = tmp.forward[i];</span><br><span class="line">&#125;</span><br><span class="line">level = newLevel;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">SkipNode&lt;K, V&gt;[] update = <span class="keyword">new</span> SkipNode[level + <span class="number">1</span>];</span><br><span class="line">SkipNode&lt;K, V&gt; x = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">while</span> (x.forward[i] != <span class="keyword">null</span> &amp;&amp; x.forward[i].k.compareTo(k) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x = x.forward[i];</span><br><span class="line">&#125;</span><br><span class="line">update[i] = x;</span><br><span class="line">&#125;</span><br><span class="line">x = x.forward[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp; x.k != <span class="keyword">null</span> &amp;&amp; x.k.compareTo(k) == <span class="number">0</span>) &#123;</span><br><span class="line">x.v = v;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">x = <span class="keyword">new</span> SkipNode&lt;K, V&gt;(k, v, newLevel);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newLevel; i++) &#123;</span><br><span class="line">x.forward[i] = update[i].forward[i];</span><br><span class="line">update[i].forward[i] = x;</span><br><span class="line">&#125;</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">find</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line">SkipNode&lt;K, V&gt; x = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">while</span> (x.forward[i] != <span class="keyword">null</span> &amp;&amp; x.forward[i].k.compareTo(k) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x = x.forward[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">x = x.forward[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (k.compareTo(x.k) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> x.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(K k)</span> </span>&#123;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">SkipNode&lt;K, V&gt;[] update = <span class="keyword">new</span> SkipNode[level + <span class="number">1</span>];</span><br><span class="line">SkipNode&lt;K, V&gt; x = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">while</span> (x.forward[i] != <span class="keyword">null</span> &amp;&amp; x.forward[i].k.compareTo(k) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">x = x.forward[i];</span><br><span class="line">&#125;</span><br><span class="line">update[i] = x;</span><br><span class="line">&#125;</span><br><span class="line">x = x.forward[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> (k.compareTo(x.k) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (update[i].forward[i] != x) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">update[i].forward[i] = x.forward[i];</span><br><span class="line">&#125;</span><br><span class="line">x = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span> (level &gt; <span class="number">0</span> &amp;&amp; head.forward[level] == <span class="keyword">null</span>) &#123;</span><br><span class="line">level = level - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">size--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:按层输出(只输出key)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printKeyByLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SkipNode&lt;K, V&gt; x = head;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">System.out.print(<span class="string">"level-"</span> + i + <span class="string">":"</span>);</span><br><span class="line">x = head.forward[<span class="number">0</span>];</span><br><span class="line">String headCurLevelForward = head.forward[i] != <span class="keyword">null</span> ? head.forward[i].k.toString() : <span class="string">"NULL"</span>;</span><br><span class="line">System.out.print(String.format(<span class="string">"%5s"</span>, headCurLevelForward) + <span class="string">" "</span>);</span><br><span class="line"><span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.forward.length &lt;= i) &#123;</span><br><span class="line">System.out.print(String.format(<span class="string">"%5s"</span>, <span class="string">" "</span>) + <span class="string">" "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (x.forward[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(String.format(<span class="string">"%5s"</span>, <span class="string">" "</span>) + <span class="string">" "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.print(String.format(<span class="string">"%5s"</span>, x.forward[i].k) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">x = x.forward[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:按节点输出(只输出key)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>:void</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printKeyByNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SkipNode&lt;K, V&gt; x = head;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(String.format(<span class="string">"%4s forward-size-%s:"</span>, x.k == <span class="keyword">null</span> ? <span class="string">"head"</span> : x.k, x.forward.length) + <span class="string">" "</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x.forward.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x.forward[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.print(String.format(<span class="string">"%3s"</span>, <span class="string">" "</span>) + <span class="string">" "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.print(String.format(<span class="string">"%3s"</span>, x.forward[i].k, x.forward[i].v) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">x = x.forward[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 随机数生成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">random</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Math.abs(random.nextInt()) % n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SkipList&lt;Integer, Integer&gt; skipList = <span class="keyword">new</span> SkipList&lt;Integer, Integer&gt;();</span><br><span class="line">skipList.insert(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">skipList.insert(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">skipList.insert(<span class="number">17</span>, <span class="number">17</span>);</span><br><span class="line">skipList.insert(<span class="number">19</span>, <span class="number">19</span>);</span><br><span class="line">skipList.insert(<span class="number">23</span>, <span class="number">23</span>);</span><br><span class="line">skipList.insert(<span class="number">26</span>, <span class="number">26</span>);</span><br><span class="line">skipList.insert(<span class="number">21</span>, <span class="number">21</span>);</span><br><span class="line">System.out.println(<span class="string">"printKeyByLevel:"</span>);</span><br><span class="line">skipList.printKeyByLevel();</span><br><span class="line">System.out.println(<span class="string">"printKeyByNode:"</span>);</span><br><span class="line">skipList.printKeyByNode();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构：跳跃表&quot;&gt;&lt;a href=&quot;#数据结构：跳跃表&quot; class=&quot;headerlink&quot; title=&quot;数据结构：跳跃表&quot;&gt;&lt;/a&gt;数据结构：跳跃表&lt;/h1&gt;&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.duyongfen
      
    
    </summary>
    
      <category term="数据结构" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="跳跃表" scheme="http://yoursite.com/tags/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    
      <category term="链表" scheme="http://yoursite.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
      <category term="查询索引" scheme="http://yoursite.com/tags/%E6%9F%A5%E8%AF%A2%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配算法</title>
    <link href="http://yoursite.com/2018/04/19/notebook/data_struc_algo/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/19/notebook/data_struc_algo/字符串匹配算法/</id>
    <published>2018-04-19T08:54:43.827Z</published>
    <updated>2018-04-19T08:54:43.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h1><h2 id="朴素算法"><a href="#朴素算法" class="headerlink" title="朴素算法"></a>朴素算法</h2><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>参考资料：</p><ul><li><a href="http://wiki.jikexueyuan.com/project/kmp-algorithm/define.html" target="_blank" rel="noopener">极客学院：KMP算法</a></li><li><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="noopener">阮一峰：字符串匹配的KMP算法</a></li></ul><p>推荐关注：<strong>Robert Sedgewick</strong>老头算法讲的很清楚。有空可以一看他coursera上的课程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串匹配算法&quot;&gt;&lt;a href=&quot;#字符串匹配算法&quot; class=&quot;headerlink&quot; title=&quot;字符串匹配算法&quot;&gt;&lt;/a&gt;字符串匹配算法&lt;/h1&gt;&lt;h2 id=&quot;朴素算法&quot;&gt;&lt;a href=&quot;#朴素算法&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>字符串匹配/包含问题</title>
    <link href="http://yoursite.com/2018/04/19/notebook/data_struc_algo/stringmatchproblem/"/>
    <id>http://yoursite.com/2018/04/19/notebook/data_struc_algo/stringmatchproblem/</id>
    <published>2018-04-19T08:54:43.826Z</published>
    <updated>2018-04-19T08:54:43.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串匹配-包含问题算法"><a href="#字符串匹配-包含问题算法" class="headerlink" title="字符串匹配/包含问题算法"></a>字符串匹配/包含问题算法</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><h2 id="普通思路"><a href="#普通思路" class="headerlink" title="普通思路"></a>普通思路</h2><h2 id="高效算法"><a href="#高效算法" class="headerlink" title="高效算法"></a>高效算法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符串匹配-包含问题算法&quot;&gt;&lt;a href=&quot;#字符串匹配-包含问题算法&quot; class=&quot;headerlink&quot; title=&quot;字符串匹配/包含问题算法&quot;&gt;&lt;/a&gt;字符串匹配/包含问题算法&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; cla
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="字符串匹配" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>PostGIS 学习笔记</title>
    <link href="http://yoursite.com/2018/04/12/notebook/OSMandPostGISandMapMatcher/postgresql%E5%92%8Cpostgis%E6%8B%93%E5%B1%95/"/>
    <id>http://yoursite.com/2018/04/12/notebook/OSMandPostGISandMapMatcher/postgresql和postgis拓展/</id>
    <published>2018-04-12T06:40:38.462Z</published>
    <updated>2018-04-19T08:54:43.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="postgresql和postgis拓展"><a href="#postgresql和postgis拓展" class="headerlink" title="postgresql和postgis拓展"></a>postgresql和postgis拓展</h1><!-- TOC --><ul><li><a href="#1-postgresql安装">1. postgresql安装</a></li><li><a href="#2-postgresql使用">2. postgresql使用</a></li><li><a href="#3-postgis扩展安装">3. postgis扩展安装</a><ul><li><a href="#31-ubuntu-安装">3.1. ubuntu 安装</a></li><li><a href="#32-centos-7-安装">3.2. centos 7 安装</a></li><li><a href="#33-创建扩展">3.3. 创建扩展</a></li></ul></li><li><a href="#4-什么是-postgis">4. 什么是 PostGIS</a></li><li><a href="#5-如何使用-postgis">5. 如何使用 PostGIS</a><ul><li><a href="#51-简单示例">5.1. 简单示例</a></li><li><a href="#52-postgis的geometry数据类型">5.2. PostGIS的Geometry数据类型</a></li><li><a href="#53-postgis函数的分类">5.3. PostGIS函数的分类</a><ul><li><a href="#531-字段处理函数">5.3.1. 字段处理函数</a></li><li><a href="#532-几何关系函数">5.3.2. 几何关系函数</a></li><li><a href="#533-几何分析函数">5.3.3. 几何分析函数</a></li><li><a href="#534-读写函数">5.3.4. 读写函数</a></li></ul></li><li><a href="#54-使用postgis扩展函数">5.4. 使用PostGIS扩展函数</a><ul><li><a href="#541-管理类函数">5.4.1. 管理类函数</a></li><li><a href="#542-数据类型的输入输出函数">5.4.2. 数据类型的输入输出函数</a></li><li><a href="#543-量算函数">5.4.3. 量算函数</a></li><li><a href="#544-几何操作函数">5.4.4. 几何操作函数</a></li><li><a href="#545-postgis函数使用示例">5.4.5. PostGIS函数使用示例</a></li></ul></li><li><a href="#55-建立postgis索引">5.5. 建立PostGIS索引</a></li></ul></li><li><a href="#6-参考资料">6. 参考资料</a></li></ul><!-- /TOC --><h2 id="1-postgresql安装"><a href="#1-postgresql安装" class="headerlink" title="1. postgresql安装"></a>1. postgresql安装</h2><p>安装过程参见<a href="http://www.cnblogs.com/z-sm/archive/2016/07/05/5644165.html" target="_blank" rel="noopener">博客</a>,其中涉及到的主要问题： </p><ul><li>postgresql的版本选择问题</li><li>postgresql安装之后修改配置、添加用户、添加用户权限更改等等问题</li></ul><h2 id="2-postgresql使用"><a href="#2-postgresql使用" class="headerlink" title="2. postgresql使用"></a>2. postgresql使用</h2><h2 id="3-postgis扩展安装"><a href="#3-postgis扩展安装" class="headerlink" title="3. postgis扩展安装"></a>3. postgis扩展安装</h2><h3 id="3-1-ubuntu-安装"><a href="#3-1-ubuntu-安装" class="headerlink" title="3.1. ubuntu 安装"></a>3.1. ubuntu 安装</h3><p>参考：<a href="https://www.howtoing.com/how-to-install-and-configure-postgis-on-ubuntu-14-04" target="_blank" rel="noopener">博客</a>  </p><p><strong>注意</strong>：很多博客中的安装过程只需要 <code>apt-get install postgis</code>，实际测试发现 <code>apt-get install postgis*</code> 最好。第一种安装方式可能没有postgis-scripts，导致在数据库中<code>create extension</code>执行时出现<em>[ERROR: could not open extension control file “/usr/share/postgresql/9.3/extension/ postgis.control”: No such file or directory]</em>的错误。  </p><h3 id="3-2-centos-7-安装"><a href="#3-2-centos-7-安装" class="headerlink" title="3.2. centos 7 安装"></a>3.2. centos 7 安装</h3><p>参考博客：<a href="https://my.oschina.net/freegis/blog/781657" target="_blank" rel="noopener">CentOS 7 源码安装PostGIS</a>：文章写得算是很不错了，只是需要注意一下postgres这个目录，有的时候指的是你自己的postgres的安装目录。</p><h3 id="3-3-创建扩展"><a href="#3-3-创建扩展" class="headerlink" title="3.3. 创建扩展"></a>3.3. 创建扩展</h3><p>创建扩展：postgis安装后在使用时，需要在使用的数据库中添加拓展，在相应数据库执行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> extension postgis</span><br></pre></td></tr></table></figure></p><p>出现<code>CREAT EXTENSION</code>表示安装成功，可使用一下命令查看版本。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> PostGIS_version()</span><br></pre></td></tr></table></figure></p><ul><li>具体使用见<a href="https://www.howtoing.com/how-to-install-and-configure-postgis-on-ubuntu-14-04" target="_blank" rel="noopener">博客</a></li></ul><h2 id="4-什么是-PostGIS"><a href="#4-什么是-PostGIS" class="headerlink" title="4. 什么是 PostGIS"></a>4. 什么是 PostGIS</h2><p>参考：<a href="https://postgis.net/" target="_blank" rel="noopener">PostGIS官网</a><br><strong>Wiki定义</strong>：<br>PostGIS 是一个开源程序，它为对象－关系型数据库PostgreSQL提供了存储空间地理数据的支持，使PostgreSQL成为了一个空间数据库，能够进行空间数据管理、数量测量与几何拓扑分析。PostGIS 实现了Open Geospatial Consortium所提出的基本要素类（点、线、面、多点、多线、多面等）的SQL实现参考。</p><h2 id="5-如何使用-PostGIS"><a href="#5-如何使用-PostGIS" class="headerlink" title="5. 如何使用 PostGIS"></a>5. 如何使用 PostGIS</h2><h3 id="5-1-简单示例"><a href="#5-1-简单示例" class="headerlink" title="5.1. 简单示例"></a>5.1. 简单示例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> demo <span class="keyword">TEMPLATE</span>=template_postgis;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cities ( <span class="keyword">id</span> int4, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>) );</span><br><span class="line"><span class="keyword">select</span> AddGeometryColumn(<span class="string">'cities'</span>,<span class="string">'the_geom'</span>,<span class="number">-1</span>,<span class="string">'GEOMETRY'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* SELECT * from cities; */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (<span class="keyword">id</span>, the_geom, <span class="keyword">name</span>) <span class="keyword">VALUES</span> (<span class="number">1</span>,ST_GeomFromText(<span class="string">'POINT(-0.1257 51.508)'</span>,<span class="number">4326</span>),<span class="string">'London, England'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (<span class="keyword">id</span>, the_geom, <span class="keyword">name</span>) <span class="keyword">VALUES</span> (<span class="number">2</span>,ST_GeomFromText(<span class="string">'POINT(-81.233 42.983)'</span>,<span class="number">4326</span>),<span class="string">'London, Ontario'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cities (<span class="keyword">id</span>, the_geom, <span class="keyword">name</span>) <span class="keyword">VALUES</span> (<span class="number">3</span>,ST_GeomFromText(<span class="string">'POINT(27.91162491 -33.01529)'</span>,<span class="number">4326</span>),<span class="string">'East London,SA'</span>);</span><br><span class="line"><span class="comment">/* 简单查询 */</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> cities;</span><br></pre></td></tr></table></figure><p>结果显示为下表:</p><pre><code>id |      name       |                      the_geom----+-----------------+----------------------------------------------------1 | London, England | 0101000020E6100000BBB88D06F016C0BF1B2FDD2406C149402 | London, Ontario | 0101000020E6100000F4FDD478E94E54C0E7FBA9F1D27D45403 | East London,SA  | 0101000020E610000040AB064060E93B4059FAD005F58140C0(3 rows)</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span>, ST_AsText(the_geom), ST_AsEwkt(the_geom), ST_X(the_geom), ST_Y(the_geom) <span class="keyword">FROM</span> cities;</span><br></pre></td></tr></table></figure><p>结果显示为下表:</p><pre><code>id |          st_astext           |               st_asewkt                |    st_x     |   st_y----+------------------------------+----------------------------------------+-------------+-----------1 | POINT(-0.1257 51.508)        | SRID=4326;POINT(-0.1257 51.508)        |     -0.1257 |    51.5082 | POINT(-81.233 42.983)        | SRID=4326;POINT(-81.233 42.983)        |     -81.233 |    42.9833 | POINT(27.91162491 -33.01529) | SRID=4326;POINT(27.91162491 -33.01529) | 27.91162491 | -33.01529</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*空间查询*/</span></span><br><span class="line"><span class="keyword">SELECT</span> p1.name,p2.name,ST_Distance_Sphere(p1.the_geom,p2.the_geom) <span class="keyword">FROM</span> cities <span class="keyword">AS</span> p1, cities <span class="keyword">AS</span> p2 <span class="keyword">WHERE</span> p1.id &gt; p2.id;</span><br></pre></td></tr></table></figure><pre><code>    name       |      name       | st_distance_sphere-----------------+-----------------+--------------------London, Ontario | London, England |   5875766.85191657East London,SA  | London, England |   9789646.96784908East London,SA  | London, Ontario |   13892160.9525778(3 rows)</code></pre><h3 id="5-2-PostGIS的Geometry数据类型"><a href="#5-2-PostGIS的Geometry数据类型" class="headerlink" title="5.2. PostGIS的Geometry数据类型"></a>5.2. PostGIS的Geometry数据类型</h3><p>Geometry可以说是PostGIS最重要的一个概念，是“几何体”的意思，由于PostGIS很好地遵守OGC的”Simple Feature for Specification for SQL”规范，目前支持的几何体类型包含其实例有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POINT(1 1)</span><br><span class="line">MULTIPOINT(1 1, 3 4, -1 3)</span><br><span class="line">LINESTRING(1 1, 2 2, 3 4)</span><br><span class="line">POLYGON((0 0, 0 1, 1 1, 1 0, 0 0))</span><br><span class="line">MULTIPOLYGON((0 0, 0 1, 1 1, 1 0, 0 0), (5 5, 5 6, 6 6, 6 5, 5 5))</span><br><span class="line">MULTILINESTRING((1 1, 2 2, 3 4),(2 2, 3 3, 4 5))</span><br></pre></td></tr></table></figure></p><p>而geometry具体表现又有两种形式，一种叫做WKT(Well Known Text)形式，如上面的例子。或者使用如下SQL语句浏览：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> AsText(pt) <span class="keyword">from</span> test1;</span><br><span class="line"><span class="keyword">select</span> AddGeometryColumn(<span class="string">'test1'</span>,<span class="string">'pt'</span>,<span class="number">-1</span>,<span class="string">'GEOMETRY'</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>另一种叫做“Canonical Form”形式，看上去是一串古怪的数字，其实是一种增强的十六进制编码，使用如下SQL语句就可以浏览了：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> pt <span class="keyword">from</span> test1;</span><br></pre></td></tr></table></figure></p><h3 id="5-3-PostGIS函数的分类"><a href="#5-3-PostGIS函数的分类" class="headerlink" title="5.3. PostGIS函数的分类"></a>5.3. PostGIS函数的分类</h3><p>PostGIS函数大致可以分为以下四类:</p><h4 id="5-3-1-字段处理函数"><a href="#5-3-1-字段处理函数" class="headerlink" title="5.3.1. 字段处理函数"></a>5.3.1. 字段处理函数</h4><p>这类函数当前一共有3个，分别是：</p><ul><li><p><code>AddGeometryColumn(var1,var2,var3,var4,var5,var6)</code>：<br>为已有的数据表增加一个地理几何数据字段。Var1代表数据表的模式(schema)的名字，一般是public，也可以省略，则使用当前的缺省模式；var2是已有的数据表的名字；var3是新的地理数据字段的名字；var4是SRID值，不确定的话就取-1吧；var5是地理数据的类型，可以是POINT等；var6是指该几何数据是二维还是三维数据。<br>前面的SQL语句<code>create table test1 (myID int4, pt geometry, myName varchar)</code>更规范的写法为：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test1 (myID int4, myName <span class="built_in">varchar</span> );</span><br><span class="line"><span class="keyword">select</span> AddGeometryColumn(<span class="string">'test1'</span>,<span class="string">'pt'</span>,<span class="number">-1</span>,<span class="string">'GEOMETRY'</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p><code>DropGeometryColumn</code> 函数：<br>显然是删除一个地理数据字段的；</p></li><li><code>SetSRID</code> 函数：<br>显然是设置SRID值的。<h4 id="5-3-2-几何关系函数"><a href="#5-3-2-几何关系函数" class="headerlink" title="5.3.2. 几何关系函数"></a>5.3.2. 几何关系函数</h4>这类函数目前共有10个，分别是：<br><code>Distance Equals Disjoint Intersects Touches Crosses Within Overlaps Contains Relate</code><h4 id="5-3-3-几何分析函数"><a href="#5-3-3-几何分析函数" class="headerlink" title="5.3.3. 几何分析函数"></a>5.3.3. 几何分析函数</h4>这类函数目前共有12个，分别是：<br><code>Centroid Area Lenth PointOnSurface Boundary Buffer ConvexHull Intersection SymDifference Difference GeomUnion MemGeomUnion</code><h4 id="5-3-4-读写函数"><a href="#5-3-4-读写函数" class="headerlink" title="5.3.4. 读写函数"></a>5.3.4. 读写函数</h4>这类函数很多，主要是用于在各种数据类型之间的转换，尤其是在于Geometry数据类型与其他如字符型等数据类型之间的转换，函数名如<code>AsText、GeomFromText</code>等，其作用是显然的。<h3 id="5-4-使用PostGIS扩展函数"><a href="#5-4-使用PostGIS扩展函数" class="headerlink" title="5.4. 使用PostGIS扩展函数"></a>5.4. 使用PostGIS扩展函数</h3>除了上述遵循OpenGIS的函数之外，PostGIS还自行扩展了一些当前OpenGIS规范之外的函数，主要包括以下几类：<h4 id="5-4-1-管理类函数"><a href="#5-4-1-管理类函数" class="headerlink" title="5.4.1. 管理类函数"></a>5.4.1. 管理类函数</h4>扩展的管理类函数主要包括一些软件版本查询函数，如postgis_version()、postgis_geos_version()、postgis_proj_version()函数等，分别查询当前的PostGIS的版本及其使用的Geos和Proj库的版本。<h4 id="5-4-2-数据类型的输入输出函数"><a href="#5-4-2-数据类型的输入输出函数" class="headerlink" title="5.4.2. 数据类型的输入输出函数"></a>5.4.2. 数据类型的输入输出函数</h4>除了OpenGIS定义的地理数据类型之外，PostGIS还对数据类型进行了扩展，这种扩展主要是两方面的扩展，一是把二维的数据向三维和四维扩展；二就是在WKT和WKB数据类型基础上扩展出EWKT和EWKB数据类型。PostGIS提供了在这些地理数据类型和常用数据类型如字符型、浮点型数据之间进行转换的函数。<h4 id="5-4-3-量算函数"><a href="#5-4-3-量算函数" class="headerlink" title="5.4.3. 量算函数"></a>5.4.3. 量算函数</h4>如length3d函数是对length2d函数的扩展。<h4 id="5-4-4-几何操作函数"><a href="#5-4-4-几何操作函数" class="headerlink" title="5.4.4. 几何操作函数"></a>5.4.4. 几何操作函数</h4>如addBBox(geometry)函数给所给的几何体加上一个边框。如simplify(geometry,tolerance)函数可以对折线和多边形利用Douglas-Peuker算法进行一些节点进行删除，从而使表现的图形更简单而清晰，在网络传输数据时具有更高的效率。<h4 id="5-4-5-PostGIS函数使用示例"><a href="#5-4-5-PostGIS函数使用示例" class="headerlink" title="5.4.5. PostGIS函数使用示例"></a>5.4.5. PostGIS函数使用示例</h4></li><li><p>integer ST_NPoints(geometry g1); 返回geometry中包含多少个point</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ST_NPoints(ST_GeomFromText(<span class="string">'LINESTRING(77.29 29.07,77.42 29.26,77.27 29.31,77.29 29.07)'</span>));</span><br><span class="line"><span class="comment">--result: 4</span></span><br></pre></td></tr></table></figure></li><li><p>geometry ST_PointN(geometry a_linestring, integer n); 返回linestring中的第n个point</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ST_AsText(ST_PointN(ST_GeomFromText(<span class="string">'CIRCULARSTRING(1 2, 3 2, 1 2)'</span>),<span class="number">2</span>));</span><br><span class="line"><span class="comment">--result:POINT(3 2)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="5-5-建立PostGIS索引"><a href="#5-5-建立PostGIS索引" class="headerlink" title="5.5. 建立PostGIS索引"></a>5.5. 建立PostGIS索引</h3><p>当数据库的记录增大的时候，如果没有建立索引的话，操作的效率就显著下降。POstGIS建议当记录数超过几千的时候就应该建立索引，而GIS数据库一般都是海量数据，所以对PostGIS而言，索引就非常重要。 </p><h2 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h2><ul><li><a href="https://zh.wikipedia.org/wiki/PostGIS" target="_blank" rel="noopener">PostGIS维基百科介绍</a>  </li><li><a href="https://live.osgeo.org/zh/quickstart/postgis_quickstart.html" target="_blank" rel="noopener">PostGIS快速入门</a>  </li><li><a href="http://blog.csdn.net/shixiaoguo90/article/details/30034429" target="_blank" rel="noopener">PostGIS简介</a>  </li><li><a href="http://www.cnblogs.com/LCGIS/archive/2013/03/08/2949119.html" target="_blank" rel="noopener">PostGIS管理函数</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;postgresql和postgis拓展&quot;&gt;&lt;a href=&quot;#postgresql和postgis拓展&quot; class=&quot;headerlink&quot; title=&quot;postgresql和postgis拓展&quot;&gt;&lt;/a&gt;postgresql和postgis拓展&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="postgres" scheme="http://yoursite.com/categories/postgres/"/>
    
    
      <category term="postgres" scheme="http://yoursite.com/tags/postgres/"/>
    
      <category term="postgis" scheme="http://yoursite.com/tags/postgis/"/>
    
  </entry>
  
  <entry>
    <title>OSM 介绍与使用</title>
    <link href="http://yoursite.com/2018/04/12/notebook/OSMandPostGISandMapMatcher/OSM%20%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/04/12/notebook/OSMandPostGISandMapMatcher/OSM 介绍与使用/</id>
    <published>2018-04-12T06:33:09.934Z</published>
    <updated>2018-04-12T06:33:09.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OSM-介绍与使用"><a href="#OSM-介绍与使用" class="headerlink" title="OSM 介绍与使用"></a>OSM 介绍与使用</h1><!-- TOC --><ul><li><a href="#什么是osm">什么是OSM?</a></li><li><a href="#获取地图数据">获取地图数据</a></li><li><a href="#osm数据导入">osm数据导入</a><ul><li><a href="#centos-7-osm2pgsql安装">centos 7: osm2pgsql安装</a></li><li><a href="#ubuntu-osm2pgsql安装">ubuntu: osm2pgsql安装</a></li><li><a href="#导入地图数据">导入地图数据</a></li></ul></li><li><a href="#基于osm的开源导航服务">基于OSM的开源导航服务</a><ul><li><a href="#osrm安装">OSRM安装</a></li><li><a href="#导航api重要参数记录">导航API重要参数记录</a></li></ul></li><li><a href="#参考资料">参考资料</a></li></ul><!-- /TOC --><h2 id="什么是OSM"><a href="#什么是OSM" class="headerlink" title="什么是OSM?"></a>什么是OSM?</h2><p>开放街道地图（OpenStreetMap，简称OSM）是一个网上地图协作计划，目标是创造一个内容自由且能让所有人编辑的世界地图[wiki：<a href="http://wiki.openstreetmap.org/wiki/Main_Page].尤其值得称道的是，osm数据开源，可以自由下载使用。" target="_blank" rel="noopener">http://wiki.openstreetmap.org/wiki/Main_Page].尤其值得称道的是，osm数据开源，可以自由下载使用。</a></p><h2 id="获取地图数据"><a href="#获取地图数据" class="headerlink" title="获取地图数据"></a>获取地图数据</h2><p>获取地图数据主要分两种情况，获取大范围数据还是小范围数据。</p><p><strong>小范围数据的获取</strong>比较简单，基本<code>进入官网-&gt;点击导出-&gt;手动选择不同的区域-&gt;在地图选定导出范围-&gt;点击导出</code>就出来了。其实就是做了一个url请求，也可以根据在url中直接填写经纬度。</p><p><img src="export_osm_smallrange.png" alt="export osm data for small range"></p><p><strong>大范围数据的获取</strong> 有多种方式，主要参考上图中的篮框中的内容，这里不多记录，如果在地图中框选范围太大，导出失败，可以直接点击Overpass API的连接，就能够导出数据来了，数据格式可以定义为xml文件。另外，知乎上有个介绍写的很好，参考<a href="https://zhuanlan.zhihu.com/p/25889246" target="_blank" rel="noopener">获取OpenStreetMap（OSM）数据方法知多少？</a>，主要参考其中的第一种方法。</p><h2 id="osm数据导入"><a href="#osm数据导入" class="headerlink" title="osm数据导入"></a>osm数据导入</h2><h3 id="centos-7-osm2pgsql安装"><a href="#centos-7-osm2pgsql安装" class="headerlink" title="centos 7: osm2pgsql安装"></a>centos 7: osm2pgsql安装</h3><p>这个简直太神奇了，参照博客：<a href="http://www.cnblogs.com/think8848/p/6011073.html" target="_blank" rel="noopener">centos 7 osm2pgsql安装</a>。基本内容/过程没有问题，只是我安装过程中出现了这么几个问题。</p><ul><li>boost-devel版本太低</li><li>gcc版本太低</li><li>gcc多个版本存在选择最低的版本</li><li><code>make install</code>成功后运行<code>osm2pgsql -version</code>出现GLIBCXX问题</li></ul><p><strong>解决办法</strong>  </p><ol><li><p>升级boost-devel： </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主要是由于更新源的问题，有些源跟踪不到</span></span><br><span class="line"><span class="comment"># 大部分网址的推荐方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我这里可以用的方法</span></span><br><span class="line">sudo wget https://bintray.com/vicendominguez/CentOS6/rpm -O etc/yum.repos.d/bintray-vicendominguez-CentOS6.repo</span><br><span class="line">sudo yum install boost-devel</span><br></pre></td></tr></table></figure></li><li><p>gcc升级版本（4.4.7 -&gt; 4.8.1）<br>centos 7最烦我的就是安装什么东西都需要源码安装，好烦的说。安装过程如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取源码</span></span><br><span class="line">wget http://ftp.gnu.org/gnu/gcc/gcc-4.8.1/gcc-4.8.1.tar.gz</span><br><span class="line">tar -xvzf gcc-4.8.1.tar.gz -C /opt/gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载prerequisites时，如果连接不上服务地址</span></span><br><span class="line"><span class="comment"># 就去看一下这个文件的内容（下载，解压，建立连接，删除）</span></span><br><span class="line"><span class="comment"># 用别的方式下载一下。然后更改这个文件的内容。</span></span><br><span class="line"><span class="built_in">cd</span> /opt/gcc/gcc-4.8.1 </span><br><span class="line">./contrib/download_prerequisites  </span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..  </span><br><span class="line">mkdir build_gcc_4.8.1 </span><br><span class="line"><span class="built_in">cd</span> build_gcc_4.8.1  </span><br><span class="line">../gcc-4.8.1/configure --<span class="built_in">enable</span>-checking=release --<span class="built_in">enable</span>-languages=c,c++ --<span class="built_in">disable</span>-multilib    </span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译时间很长</span></span><br><span class="line">make -j4  </span><br><span class="line">make install  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级版本</span></span><br><span class="line">/usr/sbin/update-alternatives --install  /usr/bin/gcc gcc /usr/<span class="built_in">local</span>/bin/x86_64-unknown-linux-gnu-gcc-4.8.1 40    </span><br><span class="line">/usr/sbin/update-alternatives --install /usr/bin/g++ g++ /usr/<span class="built_in">local</span>/bin/g++ 40</span><br></pre></td></tr></table></figure></li><li><p>改掉旧版本的链接文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因为系统默认使用低版本的gcc，如果同时存在多个版本也会出问题，所以进行下面操作。</span></span><br><span class="line">mv /usr/bin/gcc /usr/bin/gcc4.4.7</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/gcc /usr/bin/gcc</span><br><span class="line">mv /usr/bin/g++ /usr/bin/g++4.4.7</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/g++ /usr/bin/g++</span><br><span class="line">mv /usr/bin/cc /usr/bin/cc4.4.7</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/cc /usr/bin/cc</span><br><span class="line">mv /usr/bin/c++ /usr/bin/c++4.4.7</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/c++ /usr/bin/c++</span><br></pre></td></tr></table></figure></li><li><p>对文件进行补充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings /usr/lib64/libstdc++.so.6|grep GLIBCXX</span><br></pre></td></tr></table></figure><pre><code>GLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6  GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH</code></pre></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 到编译时的目录下面找到文件：libstdc++.so.6.0.18</span></span><br><span class="line"><span class="comment"># 我编译的时候，建立build_gcc_4.8.1文件夹，具体方法参见：centos升级gcc到4.8.1</span></span><br><span class="line"><span class="comment"># 注意，进入目录是，.libs是隐藏的：</span></span><br><span class="line"><span class="comment"># /home/build_gcc_4.8.1/x86_64-unknown-linux-gnu/libstdc++-v3/src/.libs</span></span><br><span class="line"><span class="comment"># 用下面的命令查看：</span></span><br><span class="line">strings libstdc++.so.6.0.18|grep GLIBCXX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一般来讲，里面就有满足需要的GLIBCXX版本了。</span></span><br><span class="line"><span class="comment"># 然后，把该文件拷贝到了/usr/lib64下.</span></span><br><span class="line"><span class="comment"># 然后将libstdc++.so.6指向libstdc++.so.6.0.18:</span></span><br><span class="line">rm -r libstdc++.so.6</span><br><span class="line">ln -s libstdc++.so.6.0.18 libstdc++.so.6</span><br></pre></td></tr></table></figure><p>参考资料：</p><ul><li><a href="https://github.com/qiwsir/ITArticles/blob/master/Linux/How_to_solve_GLIBCXX_3.4.19.md" target="_blank" rel="noopener">How_to_solve_GLIBCXX_3.4.19</a></li><li><a href="https://blog.csdn.net/clirus/article/details/62424517" target="_blank" rel="noopener">CentOS gcc升级4.8步骤</a></li><li><a href="https://www.bbsmax.com/A/GBJrlMBd0e/" target="_blank" rel="noopener">CentOS7部署osm2pgsql</a></li></ul><h3 id="ubuntu-osm2pgsql安装"><a href="#ubuntu-osm2pgsql安装" class="headerlink" title="ubuntu: osm2pgsql安装"></a>ubuntu: osm2pgsql安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ubuntu版本安装就很简单了，一条命令</span></span><br><span class="line">apt-get intall osm2pgsql</span><br></pre></td></tr></table></figure><h3 id="导入地图数据"><a href="#导入地图数据" class="headerlink" title="导入地图数据"></a>导入地图数据</h3><p>地图数据导入pg数据库，使用osm2pgsql导入，命令类似于<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果出现ident authentication <span class="keyword">for</span> user postgres问题的话，su - postgres切换用户</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是需要注意postgres读取文件权限问题，把owner和group都改成postgres就好了。</span></span><br><span class="line">osm2pgsql -s -U postgres -d osm /tmp/map.xml -H 192.168.6.133 -W</span><br></pre></td></tr></table></figure></p><p><strong>注</strong>：osm2pgsql导入数据有两种模式， normal and slim mode。</p><ul><li><p>normal mode会在内存中产生如下三张中间表，并在导入结束后丢弃，因此速度较快。<br>planet_osm_nodes<br>planet_osm_ways<br>planet_osm_rels</p></li><li><p>而slim mode则将中间结果完全放置到数据库中。slim模式的好处是方便更新。</p></li></ul><p>两者使用的区别在于是否加“-s”，加了表示slim mode，本文使用slim mode。<br>使用slim mode导入数据后在数据库中会产生如下表。</p><p><img src="osm_table_imported.png" alt="osm数据导入后的表"></p><ul><li><p>三张临时表：planet_osm_nodes, planet_osm_ways, planet_osm_rels<br>需要注意的是nodes表中的lat和lon是bigint类型的数据，它们并不是经纬度的多少倍或是什么样子，而是一种表示方式（你可以认为是一种编码方式）。从bigint类型转换到经纬度编码的过程，在进行osm2pgsql的时候其实已经做了，只不过数据改存到了point表里面的way值中，这是一种geometry数据类型，更方便使用。这也是这张临时表没什么用的原因。</p></li><li><p>planet_osm_point<br>将原始geometry数据展示成4326（也就是wgs84标准）格式的经纬度的代码类似于：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ST_AsText(ST_Transform(way, <span class="number">4326</span>)) <span class="keyword">from</span> planet_osm_point <span class="keyword">where</span> osm_id = <span class="number">1422005356</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="基于OSM的开源导航服务"><a href="#基于OSM的开源导航服务" class="headerlink" title="基于OSM的开源导航服务"></a>基于OSM的开源导航服务</h2><p>基于OSM的开源导航服务有OSRM和GraphHopper。这里重点记录OSRM，项目放在了github上，叫做<a href="https://github.com/Project-OSRM/osrm-backend" target="_blank" rel="noopener">Open Source Routing Machine</a>。</p><p>官网地址：<a href="http://project-osrm.org/" target="_blank" rel="noopener">http://project-osrm.org/</a><br>API文档说明地址：<a href="http://project-osrm.org/docs/v5.10.0/api/#general-options" target="_blank" rel="noopener">http://project-osrm.org/docs/v5.10.0/api/#general-options</a></p><h3 id="OSRM安装"><a href="#OSRM安装" class="headerlink" title="OSRM安装"></a>OSRM安装</h3><p>参见github项目的<a href="https://github.com/Project-OSRM/osrm-backend" target="_blank" rel="noopener"><strong>README</strong></a>和<a href="https://my.oschina.net/u/1266171/blog/918232" target="_blank" rel="noopener">OSRM笔记</a>（博客），都写的很详细，后者基本是前者的翻译。</p><p>涉及的主要过程记录在下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install docker</span></span><br><span class="line"><span class="comment"># daocloud.io 国内镜像</span></span><br><span class="line">curl -sSL https://get.daocloud.io/docker | sh</span><br><span class="line"><span class="comment"># Download OpenStreetMap extracts for example from Geofabrik</span></span><br><span class="line">wget http://download.geofabrik.de/europe/germany/berlin-latest.osm.pbf</span><br><span class="line"><span class="comment"># Pre-process the extract with the car profile and start a routing engine HTTP server on port 5000</span></span><br><span class="line">docker run -t -v $(<span class="built_in">pwd</span>):/data osrm/osrm-backend osrm-extract -p /opt/car.lua /data/berlin-latest.osm.pbf</span><br><span class="line">docker run -t -v $(<span class="built_in">pwd</span>):/data osrm/osrm-backend osrm-partition /data/berlin-latest.osrm</span><br><span class="line">docker run -t -v $(<span class="built_in">pwd</span>):/data osrm/osrm-backend osrm-customize /data/berlin-latest.osrm</span><br><span class="line"></span><br><span class="line">docker run -t -i -p 5000:5000 -v $(<span class="built_in">pwd</span>):/data osrm/osrm-backend osrm-routed --algorithm mld /data/berlin-latest.osrm</span><br><span class="line"><span class="comment"># Make requests against the HTTP server</span></span><br><span class="line">curl <span class="string">"http://127.0.0.1:5000/route/v1/driving/13.388860,52.517037;13.385983,52.496891?steps=true"</span></span><br><span class="line"><span class="comment"># Optionally start a user-friendly frontend on port 9966, and open it up in your browser</span></span><br><span class="line">docker run -p 9966:9966 osrm/osrm-frontend</span><br><span class="line">xdg-open <span class="string">'http://127.0.0.1:9966'</span></span><br></pre></td></tr></table></figure></p><ul><li>几点说明</li></ul><ol><li><strong>customize过程</strong>比较费时，也比较占用计算资源。在10.1.1.58上运行china-latest时，这一步可以把32个cpu都用上，并且至少花费10分钟才能算完。</li><li><p><strong>遗留的问题</strong>：9966端口的页面可以展示，但是无法真正使用。</p><p> 不正常工作</p><p> <img src="osrm_route_exception.png" alt="route_exception"></p><p> 正常工作</p><p> <img src="osrm_route_workwell.png" alt="route_workwell"></p></li></ol><h3 id="导航API重要参数记录"><a href="#导航API重要参数记录" class="headerlink" title="导航API重要参数记录"></a>导航API重要参数记录</h3><p><a href="http://project-osrm.org/docs/v5.10.0/api/#general-options" target="_blank" rel="noopener">API文档</a>中的说明很详细，仔细读一遍就知道各个字段是什么意思了。</p><ul><li><p>RouteLeg对象中的annotations属性</p><p>  distance和duration单位分别为米和秒，speed单位米/秒，由distance/duration计算得到。nodes就是osm_node表中的id（也是osm_line表中的osm_id）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"distance"</span>: <span class="number">30.0</span>,</span><br><span class="line">  <span class="attr">"duration"</span>: <span class="number">100.0</span>,</span><br><span class="line">  <span class="attr">"weight"</span>: <span class="number">100.0</span>,</span><br><span class="line">  <span class="attr">"steps"</span>: [],</span><br><span class="line">  <span class="attr">"annotation"</span>: &#123;</span><br><span class="line">    <span class="attr">"distance"</span>: [<span class="number">5</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">5</span>],</span><br><span class="line">    <span class="attr">"duration"</span>: [<span class="number">15</span>,<span class="number">15</span>,<span class="number">40</span>,<span class="number">15</span>,<span class="number">15</span>],</span><br><span class="line">    <span class="attr">"datasources"</span>: [<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],</span><br><span class="line">    <span class="attr">"nodes"</span>: [<span class="number">49772551</span>,<span class="number">49772552</span>,<span class="number">49786799</span>,<span class="number">49786800</span>,<span class="number">49786801</span>,<span class="number">49786802</span>],</span><br><span class="line">    <span class="attr">"speed"</span>: [<span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>, <span class="number">0.3</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://www.cnblogs.com/LBSer/p/4451471.html" target="_blank" rel="noopener">OSM入门+搭建地图服务</a>, 讲的很详细，值得参考一看</li><li><a href="https://gis.stackexchange.com/questions/163173/how-do-i-convert-the-coordinate-data-from-osm-into-actual-longitude-latitude-poi" target="_blank" rel="noopener">How do I convert the coordinate data from osm into actual longitude latitude points</a></li><li><a href="https://gis.stackexchange.com/questions/57003/what-format-is-lat-long-stored-in-osm-postgis" target="_blank" rel="noopener">What format is lat/long stored in OSM PostGIS?</a></li><li><a href="http://www.cnblogs.com/Micang/p/6346446.html" target="_blank" rel="noopener">OpenStreetMap、googleMap等经纬度和行列号之间相互转化</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OSM-介绍与使用&quot;&gt;&lt;a href=&quot;#OSM-介绍与使用&quot; class=&quot;headerlink&quot; title=&quot;OSM 介绍与使用&quot;&gt;&lt;/a&gt;OSM 介绍与使用&lt;/h1&gt;&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#什么是osm&quot;&gt;什么是OS
      
    
    </summary>
    
      <category term="OSM" scheme="http://yoursite.com/categories/OSM/"/>
    
    
      <category term="OSM" scheme="http://yoursite.com/tags/OSM/"/>
    
      <category term="osm2ogsql" scheme="http://yoursite.com/tags/osm2ogsql/"/>
    
  </entry>
  
  <entry>
    <title>leetcode 题目与总结</title>
    <link href="http://yoursite.com/2018/04/07/notebook/offer/leetcode/"/>
    <id>http://yoursite.com/2018/04/07/notebook/offer/leetcode/</id>
    <published>2018-04-07T12:54:24.014Z</published>
    <updated>2018-04-12T06:33:09.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode-题目与总结"><a href="#leetcode-题目与总结" class="headerlink" title="leetcode 题目与总结"></a>leetcode 题目与总结<!-- TOC --></h1><ul><li><a href="#1-二叉树">1. 二叉树</a><ul><li><a href="#11-前序遍历递归非递归">1.1. 前序遍历（递归、非递归）</a></li><li><a href="#12-中序遍历递归非递归">1.2. 中序遍历（递归、非递归）</a></li><li><a href="#13-后序遍历递归非递归">1.3. 后序遍历（递归、非递归）</a></li><li><a href="#14-层次遍历与层次输出">1.4. 层次遍历与层次输出</a></li><li><a href="#15-树的深度略">1.5. 树的深度（略）</a></li><li><a href="#16-对称树">1.6. 对称树</a></li><li><a href="#17-路径和略">1.7. 路径和（略）</a></li><li><a href="#18-中序遍历加后序遍历恢复原树结构">1.8. 中序遍历加后序遍历恢复原树结构</a></li><li><a href="#19-使用链表连接每一层">1.9. 使用链表连接每一层</a></li><li><a href="#110-给定一棵树和一个节点输出从根节点到这个节点的路径">1.10. 给定一棵树和一个节点，输出从根节点到这个节点的路径</a></li><li><a href="#111-两个节点的最小公共祖先">1.11. 两个节点的最小公共祖先</a></li><li><a href="#112-树的序列化和反序列化">1.12. 树的序列化和反序列化</a></li></ul></li></ul><!-- /TOC --><h2 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h2><h3 id="1-1-前序遍历（递归、非递归）"><a href="#1-1-前序遍历（递归、非递归）" class="headerlink" title="1.1. 前序遍历（递归、非递归）"></a>1.1. 前序遍历（递归、非递归）</h3><p>递归版本是最基本的了。非递归的版本需要使用stack来保存访问的路径。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        <span class="comment">// preorderTraversalIter(root,list);</span></span><br><span class="line">        <span class="comment">// method 2</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop().right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversalIter</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            preorderTraversalIter(root.left, list);</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            preorderTraversalIter(root.right, list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-2-中序遍历（递归、非递归）"><a href="#1-2-中序遍历（递归、非递归）" class="headerlink" title="1.2. 中序遍历（递归、非递归）"></a>1.2. 中序遍历（递归、非递归）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        <span class="comment">// inorderTraversalIter(root,list);</span></span><br><span class="line">        <span class="comment">// method 2</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                list.add(root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorderTraversalIter</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                inorderTraversalIter(root.left, list);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                inorderTraversalIter(root.right, list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-后序遍历（递归、非递归）"><a href="#1-3-后序遍历（递归、非递归）" class="headerlink" title="1.3. 后序遍历（递归、非递归）"></a>1.3. 后序遍历（递归、非递归）</h3><p>后序遍历其实是镜像+颠倒版的前序遍历。使用右先前序遍历（先访问右节点）思想，最后倒着输出。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// method 1</span></span><br><span class="line">        <span class="comment">// postorderTraversalIter(root,list);</span></span><br><span class="line">        <span class="comment">// method 2</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                list.add(<span class="number">0</span>, root.val);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = stack.pop();</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postorderTraversalIter</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">                postorderTraversalIter(root.left, list);</span><br><span class="line">            <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">                postorderTraversalIter(root.right, list);</span><br><span class="line">            list.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-4-层次遍历与层次输出"><a href="#1-4-层次遍历与层次输出" class="headerlink" title="1.4. 层次遍历与层次输出"></a>1.4. 层次遍历与层次输出</h3><p>层次遍历很简单，使用队列辅助就行了。但是如何进行层次输出呢？这就是102号题目：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a>。思路如下。</p><p>思路1：递归。设置level记录层数。每进行一次子节点访问，层数加1。不同层用不同list存储。具体见代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; levelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root, levelList, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> levelList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode node, List&lt;List&lt;Integer&gt;&gt; levelList, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (levelList.size() &lt;= level) &#123;</span><br><span class="line">            levelList.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        levelList.get(level).add(node.val);</span><br><span class="line">        helper(node.left, levelList, level+<span class="number">1</span>);</span><br><span class="line">        helper(node.right, levelList, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路2：迭代。记录上下两层的数量。使用队列进行存储，但是记录前一层和当前层分别有多少个节点被存储了。当前一层还剩下0个节点的时候，存储成新的list。详见代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; lists = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">int</span> preCount=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curCount=<span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">            preCount++;</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode node = queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                preCount--;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    curCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    curCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(preCount == <span class="number">0</span>)&#123;</span><br><span class="line">                    lists.add(<span class="keyword">new</span> ArrayList(list));</span><br><span class="line">                    list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    preCount = curCount;</span><br><span class="line">                    curCount = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路3：迭代。双队列，第一个队列存储已经访问过的上一层的节点值，第二个队列存储当前访问层的节点值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Queue&lt;TreeNode&gt; temp=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">                TreeNode node=queue.poll();</span><br><span class="line">                list.add(node.val);</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.add(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    temp.add(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            queue=temp;     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-5-树的深度（略）"><a href="#1-5-树的深度（略）" class="headerlink" title="1.5. 树的深度（略）"></a>1.5. 树的深度（略）</h3><h3 id="1-6-对称树"><a href="#1-6-对称树" class="headerlink" title="1.6. 对称树"></a>1.6. 对称树</h3><p>判断两棵子树是否对称是关键点，其它就是使用这个方法进行递归了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isEqual(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(TreeNode left, TreeNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> &amp;&amp; right == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="keyword">null</span> || right == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left.val != right.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isEqual(left.left, right.right) &amp;&amp; isEqual(left.right, right.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-7-路径和（略）"><a href="#1-7-路径和（略）" class="headerlink" title="1.7. 路径和（略）"></a>1.7. 路径和（略）</h3><h3 id="1-8-中序遍历加后序遍历恢复原树结构"><a href="#1-8-中序遍历加后序遍历恢复原树结构" class="headerlink" title="1.8. 中序遍历加后序遍历恢复原树结构"></a>1.8. 中序遍历加后序遍历恢复原树结构</h3><p>需要对中后序遍历的关系搞得非常清楚才能写出这样的代码。真的很神奇。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p_inorder, p_postorder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>&#123;</span><br><span class="line">        p_inorder = inorder.length - <span class="number">1</span>;</span><br><span class="line">        p_postorder = postorder.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> buildTree(inorder, postorder, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder, TreeNode end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p_postorder &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(postorder[p_postorder]);</span><br><span class="line">        p_postorder--;</span><br><span class="line">        <span class="comment">// 判断是否存在右节点</span></span><br><span class="line">        <span class="keyword">if</span>(inorder[p_inorder] != root.val)</span><br><span class="line">            root.right = buildTree(inorder, postorder, root);</span><br><span class="line">        p_inorder--;</span><br><span class="line">        <span class="comment">// 判断是否存在左点， 当end==null时都是一棵左子树开始创建的时候</span></span><br><span class="line">        <span class="keyword">if</span>(end == <span class="keyword">null</span> || inorder[p_inorder] != end.val)</span><br><span class="line">            root.left = buildTree(inorder, postorder, end);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-9-使用链表连接每一层"><a href="#1-9-使用链表连接每一层" class="headerlink" title="1.9. 使用链表连接每一层"></a>1.9. 使用链表连接每一层</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// for complete binary tree</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( root.left != <span class="keyword">null</span> )&#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( root.next != <span class="keyword">null</span> )&#123;</span><br><span class="line">                root.right.next = root.next.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        connect( root.left );</span><br><span class="line">        connect( root.right );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for normal binary tree</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( root == <span class="keyword">null</span> )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( root.left != <span class="keyword">null</span> )&#123;</span><br><span class="line">            root.left.next = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( root.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>( root.next != <span class="keyword">null</span> )&#123;</span><br><span class="line">                root.right.next = root.next.left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        connect( root.left );</span><br><span class="line">        connect( root.right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-给定一棵树和一个节点，输出从根节点到这个节点的路径"><a href="#1-10-给定一棵树和一个节点，输出从根节点到这个节点的路径" class="headerlink" title="1.10. 给定一棵树和一个节点，输出从根节点到这个节点的路径"></a>1.10. 给定一棵树和一个节点，输出从根节点到这个节点的路径</h3><p>思路就是，首先判断边界条件，如果根节点或者目标节点为空的话，就不用找了。正常情况下，使用一个列表记录路径，这个列表也相当于一个栈，使用遍历（回溯）的方法。当前节点不为空，入栈，如果栈顶节点等于目标节点，则找到了。如果不等于则需要判断是否需要出栈，情况有2，第一种，如果当前节点已经是叶节点了，出栈；第二种，如果当前节点的左右子树都没有找到这个节点，出栈。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">findPath</span><span class="params">(TreeNode root, TreeNode target, List&lt;TreeNode&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || target == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> found;</span><br><span class="line">    list.add(root);</span><br><span class="line">    <span class="keyword">if</span> (root == target) &#123;</span><br><span class="line">        found = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> leftFound = <span class="keyword">false</span>, rightFound = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftFound = findPath(root.left, target, list);</span><br><span class="line">            rightFound = findPath(root.right, target, list);</span><br><span class="line">            found = (leftFound || rightFound);</span><br><span class="line">            <span class="keyword">if</span> (!found)</span><br><span class="line">                list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-11-两个节点的最小公共祖先"><a href="#1-11-两个节点的最小公共祖先" class="headerlink" title="1.11. 两个节点的最小公共祖先"></a>1.11. 两个节点的最小公共祖先</h3><blockquote><p>If the current (sub)tree contains both p and q, then the function result is their LCA. If only one of them is in that subtree, then the result is that one of them. If neither are in that subtree, the result is null/None/nil.</p></blockquote><p>算法的整体思路是：以当前节点为父节点（或者叫祖先节点），看它的左右两棵子树是否都包含p和q，由于p和q使用的是对象等于判断方法，所以如果两棵子树都包含的话，必定分别包含p和q，则直接返回当前节点。如果都不包含，那就是没有。如果一个包含一个不包含，返回包含的那个节点。</p><p>但是注意：这种编程方法只适合于两个节点都存在于树中的情况。如果有一个不存在的话输出的结果是有问题的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-12-树的序列化和反序列化"><a href="#1-12-树的序列化和反序列化" class="headerlink" title="1.12. 树的序列化和反序列化"></a>1.12. 树的序列化和反序列化</h3><p>思路是将叶节点的子节点（null)也记录在案，这样无论是哪种遍历顺序（前中后，层次）都方便恢复。这里选择前序遍历进行序列化，反序列化就是前序遍历结果的反推。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"N,"</span>;</span><br><span class="line">    String res = root.val + <span class="string">","</span>;</span><br><span class="line">    res += serialize(root.left);</span><br><span class="line">    res += serialize(root.right);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.length() &lt;= <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// method 1</span></span><br><span class="line">    <span class="comment">// String[] vals = data.split(",");</span></span><br><span class="line">    <span class="comment">// return deserializeCore(vals);</span></span><br><span class="line">    <span class="comment">// method 2</span></span><br><span class="line">    <span class="keyword">return</span> deserializeCore2(<span class="keyword">new</span> StringBuilder(data));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserializeCore</span><span class="params">(String[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (MyCounter.count &gt;= data.length)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    String valStr = data[MyCounter.count];</span><br><span class="line">    MyCounter.count++;</span><br><span class="line">    <span class="keyword">if</span> (valStr.equals(<span class="string">"N"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(valStr));</span><br><span class="line">    node.left = deserializeCore(data);</span><br><span class="line">    node.right = deserializeCore(data);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserializeCore2</span><span class="params">(StringBuilder data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.length() &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> idx = data.indexOf(<span class="string">","</span>);</span><br><span class="line">    String valStr = data.substring(<span class="number">0</span>, idx);</span><br><span class="line">    data.delete(<span class="number">0</span>, idx + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (valStr.equals(<span class="string">"N"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode node = <span class="keyword">new</span> TreeNode(Integer.parseInt(valStr));</span><br><span class="line">    node.left = deserializeCore2(data);</span><br><span class="line">    <span class="comment">// data.delete(0, data.indexOf(",") + 1);</span></span><br><span class="line">    node.right = deserializeCore2(data);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCounter</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;leetcode-题目与总结&quot;&gt;&lt;a href=&quot;#leetcode-题目与总结&quot; class=&quot;headerlink&quot; title=&quot;leetcode 题目与总结&quot;&gt;&lt;/a&gt;leetcode 题目与总结&lt;!-- TOC --&gt;&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a h
      
    
    </summary>
    
      <category term="offer" scheme="http://yoursite.com/categories/offer/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/categories/offer/leetcode/"/>
    
    
      <category term="offer" scheme="http://yoursite.com/tags/offer/"/>
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>操作系统随笔</title>
    <link href="http://yoursite.com/2018/04/02/notebook/linux%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/os/%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2018/04/02/notebook/linux和操作系统/os/随笔/</id>
    <published>2018-04-02T09:13:51.992Z</published>
    <updated>2018-04-02T09:13:51.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="操作系统随笔"><a href="#操作系统随笔" class="headerlink" title="操作系统随笔"></a>操作系统随笔</h1><!-- TOC --><ul><li><a href="#1-锁的概念以及死锁的概念">1. 锁的概念以及死锁的概念</a></li><li><a href="#2-计算机ip保留地址">2. 计算机IP保留地址</a></li></ul><!-- /TOC --><h2 id="1-锁的概念以及死锁的概念"><a href="#1-锁的概念以及死锁的概念" class="headerlink" title="1. 锁的概念以及死锁的概念"></a>1. 锁的概念以及死锁的概念</h2><ul><li><p>牛客网参考答案：<a href="https://www.nowcoder.com/ta/review-java/review?page=16" target="_blank" rel="noopener">JAVA面试常考知识点：page16</a></p><blockquote><p>所谓死锁是指多个进 程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：</p><ul><li>互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li><li>不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。</li></ul></blockquote></li><li><p>如何解决死锁问题</p></li></ul><p>目标就是破坏产生死锁的四个条件，一般最后一个条件比较容易破坏，也就是所有锁的需求都是按照一定顺序来的。可参考：<a href="https://www.jianshu.com/p/44125bb12ebf" target="_blank" rel="noopener">死锁是什么？如何避免死锁？</a></p><h2 id="2-计算机IP保留地址"><a href="#2-计算机IP保留地址" class="headerlink" title="2. 计算机IP保留地址"></a>2. 计算机IP保留地址</h2><p>参考文章：<a href="http://www.cnblogs.com/ZJoy/archive/2011/03/24/1994308.html" target="_blank" rel="noopener">IP地址中的保留地址</a><br>根据用途和安全性级别的不同，IP地址还可以大致分为两类：公共地址和私有地址。</p><ul><li>公用地址在Internet中使用，可以在Internet中随意访问。</li><li>私有地址只能在内部网络中使用，只有通过代理服务器才能与Internet通信。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;操作系统随笔&quot;&gt;&lt;a href=&quot;#操作系统随笔&quot; class=&quot;headerlink&quot; title=&quot;操作系统随笔&quot;&gt;&lt;/a&gt;操作系统随笔&lt;/h1&gt;&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-锁的概念以及死锁的概念&quot;&gt;1. 锁的概念以及死
      
    
    </summary>
    
      <category term="操作系统" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>各种排序方法的简单总结</title>
    <link href="http://yoursite.com/2018/04/02/notebook/data_struc_algo/sortsummary/"/>
    <id>http://yoursite.com/2018/04/02/notebook/data_struc_algo/sortsummary/</id>
    <published>2018-04-02T09:13:51.939Z</published>
    <updated>2018-04-02T09:13:51.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种排序方法的简单总结"><a href="#各种排序方法的简单总结" class="headerlink" title="各种排序方法的简单总结"></a>各种排序方法的简单总结</h1><p>排序算法算是计算机的经典算法，解决很多问题的时候排序算法的思想都值得参考。<br><!-- TOC --></p><ul><li><a href="#1-快速排序的思想">1. 快速排序的思想</a></li><li><a href="#2-归并排序的思想">2. 归并排序的思想</a></li><li><a href="#3-堆排序的思路">3. 堆排序的思路</a></li></ul><!-- /TOC --><h2 id="1-快速排序的思想"><a href="#1-快速排序的思想" class="headerlink" title="1. 快速排序的思想"></a>1. 快速排序的思想</h2><p>学习容易记住的快排算法过程（Partition函数式最重要的，有两种写法，一种高效，另一种普通，参考<a href="http://selfboot.cn/2016/09/01/lost_partition/" target="_blank" rel="noopener">这里</a>）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main sort function</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(start == end)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> index = partition(arr, len, start, end);</span><br><span class="line">print_arr(arr, len);</span><br><span class="line"><span class="keyword">if</span>(index &gt; start)</span><br><span class="line">qsort(arr, len, start, index - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(index &lt; end)</span><br><span class="line">qsort(arr, len, index + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition function 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr == <span class="literal">NULL</span> || start &lt; <span class="number">0</span> || end &lt; <span class="number">0</span> || end &gt;= len || end &lt; start)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"partition input invalid\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[end];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> small = start - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = start; i &lt; end; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[i] &lt; pivot)&#123;</span><br><span class="line">small++;</span><br><span class="line"><span class="keyword">if</span>(i != small)</span><br><span class="line">swap(&amp;arr[small], &amp;arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">small++;</span><br><span class="line">swap(&amp;arr[small], &amp;arr[end]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> small;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// partition function which is more efficient</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(arr == <span class="literal">NULL</span> || start &lt; <span class="number">0</span> || end &lt; <span class="number">0</span> || end &gt;= len || end &lt; start)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"partition input invalid\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pivot = arr[end];</span><br><span class="line">start--;</span><br><span class="line"><span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line"><span class="keyword">while</span>(start &lt; end &amp;&amp; arr[++start] &lt;= pivot);</span><br><span class="line">arr[end] = arr[start];</span><br><span class="line"><span class="keyword">while</span>(start &lt; end &amp;&amp; arr[--end] &gt;= pivot);</span><br><span class="line">arr[start] = arr[end];</span><br><span class="line">&#125;</span><br><span class="line">arr[start] = pivot;</span><br><span class="line"><span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-归并排序的思想"><a href="#2-归并排序的思想" class="headerlink" title="2. 归并排序的思想"></a>2. 归并排序的思想</h2><p>归并排序就是将数组分成两个部分，然后分别对两个部分进行排序，然后再融合起来。可以递归实现，算法时间复杂度时O(nlogn)，空间复杂度O(n)，也就是需要辅助空间。</p><h2 id="3-堆排序的思路"><a href="#3-堆排序的思路" class="headerlink" title="3. 堆排序的思路"></a>3. 堆排序的思路</h2><p>参考：<a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">常见排序算法 - 堆排序 (Heap Sort)</a></p><p>堆排序就是把最大堆堆顶的最大数取出，将剩余的堆继续调整为最大堆，再次将堆顶的最大数取出，这个过程持续到剩余数只有一个时结束。在堆中定义以下几种操作：</p><ul><li>最大堆调整（Max-Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点</li><li>创建最大堆（Build-Max-Heap）：将堆所有数据重新排序，使其成为最大堆</li><li>堆排序（Heap-Sort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算</li></ul><p>最大堆调整（MAX‐HEAPIFY）的作用是保持最大堆的性质，是创建最大堆的核心子程序。下面是Java版本的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/* 堆排序的思路：</span></span><br><span class="line"><span class="comment"> * 1. 首先明确堆是一种数据结构，利用堆这种数据结构的特性可以很高效地做排序算法。</span></span><br><span class="line"><span class="comment"> * 2. 第一步：堆化。将原本不是堆结构的数组转换成堆，方法时从第一个不是叶节点的节点开始，到根节点，进行堆化操作。堆化操作就是数字的上浮和下沉，要注意的是下沉要彻底，也就是需要递归或者迭代处理下沉的点。</span></span><br><span class="line"><span class="comment"> * 3. 第二步：排序。以最大堆为例，堆顶（也就是树结构的根节点，也就是数组第一个元素）存的是最大值，堆顶元素与最末尾叶节点交换，交换后堆就不是最大堆了，需要重新调整，但是调整的时候就不管最后一个元素了，所以堆的长度减少1。循环此过程直到堆内只剩下一个元素。排序完成。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSortWiki</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeapSortWiki</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.arr = arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序的主要入口方法，共两步。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第一步：将数组堆化 beginIndex = 第一个非叶子节点。 从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。</span></span><br><span class="line"><span class="comment"> * 叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> len = arr.length - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> beginIndex = (len - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = beginIndex; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">maxHeapify(i, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 第二步：对堆化数据排序 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。</span></span><br><span class="line"><span class="comment"> * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。 直至未排序的堆长度为 0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">swap(<span class="number">0</span>, i);</span><br><span class="line">maxHeapify(<span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调整索引为 index 处的数据，使其符合堆的特性。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment"> *            需要堆化处理的数据的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment"> *            未排序的堆（数组）的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> li = (index &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// 左子节点索引</span></span><br><span class="line"><span class="keyword">int</span> ri = li + <span class="number">1</span>; <span class="comment">// 右子节点索引</span></span><br><span class="line"><span class="keyword">int</span> cMax = li; <span class="comment">// 子节点值最大索引，默认左子节点。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (li &gt; len)</span><br><span class="line"><span class="keyword">return</span>; <span class="comment">// 左子节点索引超出计算范围，直接返回。</span></span><br><span class="line"><span class="keyword">if</span> (ri &lt;= len &amp;&amp; arr[ri] &gt; arr[li]) <span class="comment">// 先判断左右子节点，哪个较大。</span></span><br><span class="line">cMax = ri;</span><br><span class="line"><span class="keyword">if</span> (arr[cMax] &gt; arr[index]) &#123;</span><br><span class="line">swap(cMax, index); <span class="comment">// 如果父节点被子节点调换，</span></span><br><span class="line">maxHeapify(cMax, len); <span class="comment">// 则需要继续判断换下后的父节点是否符合堆的特性。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试用例</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 输出： [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7,</span></span><br><span class="line"><span class="comment"> * 7, 8, 8, 8, 9, 9, 9]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">new</span> HeapSortWiki(arr).sort();</span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;各种排序方法的简单总结&quot;&gt;&lt;a href=&quot;#各种排序方法的简单总结&quot; class=&quot;headerlink&quot; title=&quot;各种排序方法的简单总结&quot;&gt;&lt;/a&gt;各种排序方法的简单总结&lt;/h1&gt;&lt;p&gt;排序算法算是计算机的经典算法，解决很多问题的时候排序算法的思想都值得
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法随笔</title>
    <link href="http://yoursite.com/2018/04/02/notebook/data_struc_algo/data%20structure/"/>
    <id>http://yoursite.com/2018/04/02/notebook/data_struc_algo/data structure/</id>
    <published>2018-04-02T09:13:51.937Z</published>
    <updated>2018-04-02T09:13:51.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data-Struture-Note"><a href="#Data-Struture-Note" class="headerlink" title="Data Struture Note"></a>Data Struture Note</h1><!-- TOC --><ul><li><a href="#1-如何解决hash冲突有哪几种方案">1. 如何解决<code>hash</code>冲突，有哪几种方案</a><ul><li><a href="#11-开放定址法">1.1. 开放定址法</a></li><li><a href="#12-链地址法拉链法">1.2. 链地址法（拉链法）</a></li><li><a href="#13-再哈希法">1.3. 再哈希法</a></li><li><a href="#14-建立公共溢出区">1.4. 建立公共溢出区</a></li></ul></li></ul><!-- /TOC --><h2 id="1-如何解决hash冲突，有哪几种方案"><a href="#1-如何解决hash冲突，有哪几种方案" class="headerlink" title="1. 如何解决hash冲突，有哪几种方案"></a>1. 如何解决<code>hash</code>冲突，有哪几种方案</h2><p>参考：<a href="https://www.jianshu.com/p/4d3cb99d7580" target="_blank" rel="noopener">解决哈希冲突的常用方法分析</a></p><h3 id="1-1-开放定址法"><a href="#1-1-开放定址法" class="headerlink" title="1.1. 开放定址法"></a>1.1. 开放定址法</h3><ul><li>线性探查法：找到下一个有空的位置放进去，查找的时候遍历（其实也可以有一个辅助的数组专门记录移动的位置），这个方法容易出现“聚集”的现象</li><li>平方探查法：二次探测法的地址增量序列为 di = 12， -12， 22， -22，… ， q2, -q2 (q &lt;= m/2)。二次探测能有效避免“聚集”现象，但是不能够探测到哈希表上所有的存储单元，但是至少能够探测到一半。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</li><li>双散列函数探查法： hp (key)若h(key)出现冲突，则再使用hp (key)求取散列地址。探查序列为：<code>h(k), h(k)+ hp(k),…, h((k)+ i*hp(k))</code>。</li></ul><h3 id="1-2-链地址法（拉链法）"><a href="#1-2-链地址法（拉链法）" class="headerlink" title="1.2. 链地址法（拉链法）"></a>1.2. 链地址法（拉链法）</h3><p><code>Java</code>中<code>HashMap</code>的经典实现算法。</p><h3 id="1-3-再哈希法"><a href="#1-3-再哈希法" class="headerlink" title="1.3. 再哈希法"></a>1.3. 再哈希法</h3><p>当发生冲突时，使用第二个、第三个、哈希函数计算地址，直到无冲突时。缺点：计算时间增加。</p><h3 id="1-4-建立公共溢出区"><a href="#1-4-建立公共溢出区" class="headerlink" title="1.4. 建立公共溢出区"></a>1.4. 建立公共溢出区</h3><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Data-Struture-Note&quot;&gt;&lt;a href=&quot;#Data-Struture-Note&quot; class=&quot;headerlink&quot; title=&quot;Data Struture Note&quot;&gt;&lt;/a&gt;Data Struture Note&lt;/h1&gt;&lt;!-- TOC 
      
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>面试随笔</title>
    <link href="http://yoursite.com/2018/04/02/notebook/offer/%E9%9D%A2%E8%AF%95%E9%9A%8F%E7%AC%94/"/>
    <id>http://yoursite.com/2018/04/02/notebook/offer/面试随笔/</id>
    <published>2018-04-02T08:39:28.014Z</published>
    <updated>2018-04-19T08:54:43.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试随笔"><a href="#面试随笔" class="headerlink" title="面试随笔"></a>面试随笔</h1><p>记录一些在面试过程中遇到的问题</p><!-- TOC --><ul><li><a href="#1-程序lang掉无响应">1. 程序lang掉（无响应）</a></li><li><a href="#3-网易的两道题">3. 网易的两道题</a><ul><li><a href="#31-符合nk的数对有多少种">3.1. 符合n，k的数对有多少种</a></li><li><a href="#32-有多少种装法">3.2. 有多少种装法</a></li></ul></li><li><a href="#腾讯面试题">腾讯面试题</a><ul><li><a href="#带符号大数加减">带符号大数加减</a></li></ul></li><li><a href="#阿里电话面试">阿里电话面试</a><ul><li><a href="#jstorm流程-和-jstorm-slotworker和task的关系">JStorm流程 和 JStorm Slot、Worker和task的关系</a></li><li><a href="#b树为什么适合数据库为什么快">B+树为什么适合数据库，为什么快</a></li><li><a href="#红黑树的五个特点">红黑树的五个特点</a></li><li><a href="#hbase流程">HBase流程</a></li><li><a href="#kafka数据压缩">kafka数据压缩</a></li><li><a href="#java-线程池">java 线程池</a></li><li><a href="#tcp三次握手和四次挥手详细过程及状态变化">tcp三次握手和四次挥手详细过程及状态变化</a></li></ul></li><li><a href="#阿里第二次电话面">阿里第二次电话面</a><ul><li><a href="#hashmap使用类的实例作为key需要注意哪些内容">HashMap使用类的实例作为Key需要注意哪些内容</a></li><li><a href="#如何优化一个链表使得查询效率变高">如何优化一个链表使得查询效率变高</a></li></ul></li><li><a href="#阿里第三次电话面">阿里第三次电话面</a><ul><li><a href="#字符串匹配算法">字符串匹配算法</a></li></ul></li><li><a href="#阿里第四次电话面">阿里第四次电话面</a><ul><li><a href="#数据库的索引结构">数据库的索引结构？</a></li><li><a href="#操作系统中的虚拟内存的概念">操作系统中的虚拟内存的概念</a></li><li><a href="#网络中tcpip和http的关系java网络编程的知识">网络中TCP/IP和http的关系（Java网络编程的知识）</a></li><li><a href="#socket与session的区别">socket与session的区别</a></li><li><a href="#java多线程">java多线程</a></li></ul></li></ul><!-- /TOC --><h2 id="1-程序lang掉（无响应）"><a href="#1-程序lang掉（无响应）" class="headerlink" title="1. 程序lang掉（无响应）"></a>1. 程序lang掉（无响应）</h2><h2 id="3-网易的两道题"><a href="#3-网易的两道题" class="headerlink" title="3. 网易的两道题"></a>3. 网易的两道题</h2><h3 id="3-1-符合n，k的数对有多少种"><a href="#3-1-符合n，k的数对有多少种" class="headerlink" title="3.1. 符合n，k的数对有多少种"></a>3.1. 符合n，k的数对有多少种</h3><h3 id="3-2-有多少种装法"><a href="#3-2-有多少种装法" class="headerlink" title="3.2. 有多少种装法"></a>3.2. 有多少种装法</h3><h2 id="腾讯面试题"><a href="#腾讯面试题" class="headerlink" title="腾讯面试题"></a>腾讯面试题</h2><h3 id="带符号大数加减"><a href="#带符号大数加减" class="headerlink" title="带符号大数加减"></a>带符号大数加减</h3><h2 id="阿里电话面试"><a href="#阿里电话面试" class="headerlink" title="阿里电话面试"></a>阿里电话面试</h2><h3 id="JStorm流程-和-JStorm-Slot、Worker和task的关系"><a href="#JStorm流程-和-JStorm-Slot、Worker和task的关系" class="headerlink" title="JStorm流程 和 JStorm Slot、Worker和task的关系"></a>JStorm流程 和 JStorm Slot、Worker和task的关系</h3><h3 id="B-树为什么适合数据库，为什么快"><a href="#B-树为什么适合数据库，为什么快" class="headerlink" title="B+树为什么适合数据库，为什么快"></a>B+树为什么适合数据库，为什么快</h3><ul><li>为什么B+树索引结构是存储在磁盘上的？</li><li>为什么比B树更好？<h3 id="红黑树的五个特点"><a href="#红黑树的五个特点" class="headerlink" title="红黑树的五个特点"></a>红黑树的五个特点</h3></li></ul><h3 id="HBase流程"><a href="#HBase流程" class="headerlink" title="HBase流程"></a>HBase流程</h3><h3 id="kafka数据压缩"><a href="#kafka数据压缩" class="headerlink" title="kafka数据压缩"></a>kafka数据压缩</h3><h3 id="java-线程池"><a href="#java-线程池" class="headerlink" title="java 线程池"></a>java 线程池</h3><h3 id="tcp三次握手和四次挥手详细过程及状态变化"><a href="#tcp三次握手和四次挥手详细过程及状态变化" class="headerlink" title="tcp三次握手和四次挥手详细过程及状态变化"></a>tcp三次握手和四次挥手详细过程及状态变化</h3><h2 id="阿里第二次电话面"><a href="#阿里第二次电话面" class="headerlink" title="阿里第二次电话面"></a>阿里第二次电话面</h2><h3 id="HashMap使用类的实例作为Key需要注意哪些内容"><a href="#HashMap使用类的实例作为Key需要注意哪些内容" class="headerlink" title="HashMap使用类的实例作为Key需要注意哪些内容"></a>HashMap使用类的实例作为Key需要注意哪些内容</h3><p>需要注意的是，HashMap里面的Key和Value其实可以是自定义的类的实例。</p><ul><li>但是这个类的必须实现<code>hashCode()</code>和<code>equals()</code>方法，原因可想而知</li><li><code>hashCode()</code>在进行put和get的时候至关重要</li><li><code>equals()</code>则在get的时候发挥作用。</li><li>这里<code>hashCode()</code>方法也需要注意：对于同一个对象，hashcode需要是<strong>不可变</strong>的。</li><li>如果是可变的，当我们把这个key的引用进行一定的操作之后，导致hashcode变化了，那可能永远都找不到这个元素了。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以，但是ClassA需要一定的注意事项</span></span><br><span class="line">hashMap.put(<span class="keyword">instanceof</span>(ClassA), value);</span><br></pre></td></tr></table></figure></li></ul><h3 id="如何优化一个链表使得查询效率变高"><a href="#如何优化一个链表使得查询效率变高" class="headerlink" title="如何优化一个链表使得查询效率变高"></a>如何优化一个链表使得查询效率变高</h3><p>答案就是跳表啊。<a href="../data_struc_algo/跳跃表.md">数据结构与算法：跳跃表</a></p><h2 id="阿里第三次电话面"><a href="#阿里第三次电话面" class="headerlink" title="阿里第三次电话面"></a>阿里第三次电话面</h2><h3 id="字符串匹配算法"><a href="#字符串匹配算法" class="headerlink" title="字符串匹配算法"></a>字符串匹配算法</h3><h2 id="阿里第四次电话面"><a href="#阿里第四次电话面" class="headerlink" title="阿里第四次电话面"></a>阿里第四次电话面</h2><h3 id="数据库的索引结构？"><a href="#数据库的索引结构？" class="headerlink" title="数据库的索引结构？"></a>数据库的索引结构？</h3><h3 id="操作系统中的虚拟内存的概念"><a href="#操作系统中的虚拟内存的概念" class="headerlink" title="操作系统中的虚拟内存的概念"></a>操作系统中的虚拟内存的概念</h3><h3 id="网络中TCP-IP和http的关系（Java网络编程的知识）"><a href="#网络中TCP-IP和http的关系（Java网络编程的知识）" class="headerlink" title="网络中TCP/IP和http的关系（Java网络编程的知识）"></a>网络中TCP/IP和http的关系（Java网络编程的知识）</h3><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/qq_35181209/article/details/75212533" target="_blank" rel="noopener">TCP/IP、Http、Socket的关系理解</a></li><li><a href="https://www.jianshu.com/p/a5410f895d6b" target="_blank" rel="noopener">懵逼的HTTP、Socket与TCP</a></li></ul><p>TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。</p><p><img src="https://raw.githubusercontent.com/zqjflash/tcp-ip-protocal/master/tcp-ip-protocal.png" alt="TCP/IP协议栈"></p><p><img src="https://upload-images.jianshu.io/upload_images/735757-e38faee729cc7dfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/540" alt="TCP/IP协议族中的位置关系"></p><h3 id="socket与session的区别"><a href="#socket与session的区别" class="headerlink" title="socket与session的区别"></a>socket与session的区别</h3><p>参考资料：</p><ul><li><a href="https://juejin.im/entry/5766c29d6be3ff006a31b84e" target="_blank" rel="noopener">Cookie 与 Session 的区别</a></li></ul><p>总结来看：</p><ul><li>Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；</li><li>Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</li></ul><h3 id="java多线程"><a href="#java多线程" class="headerlink" title="java多线程"></a>java多线程</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面试随笔&quot;&gt;&lt;a href=&quot;#面试随笔&quot; class=&quot;headerlink&quot; title=&quot;面试随笔&quot;&gt;&lt;/a&gt;面试随笔&lt;/h1&gt;&lt;p&gt;记录一些在面试过程中遇到的问题&lt;/p&gt;
&lt;!-- TOC --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#1-程序lang掉无
      
    
    </summary>
    
      <category term="面试" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
